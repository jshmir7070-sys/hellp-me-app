import type { Express, Request } from "express";
import type { Server } from "http";
import { randomUUID, randomBytes } from "crypto";
import { storage, db } from "./storage";
import { api } from "@shared/routes";
import { insertCarrierRateItemSchema, insertAdminBankAccountSchema, insertCustomerServiceInquirySchema, updateCustomerServiceInquirySchema, userLocationLogs, userLocationLatest, teamIncentives, incentiveDetails, requesterRefundAccounts, insertRequesterRefundAccountSchema, SettlementStatement, authAuditLogs, insertDestinationPricingSchema, insertColdChainSettingSchema, destinationRegions, timeSlots, regionPricingRules, vatSettings, minimumGuaranteeRules, minimumGuaranteeApplications, settlementAuditLogs, settlementPayoutAttempts, orderForceStatusLogs, manualDispatchLogs, proofUploadFailures, orders, settlementStatements, helperBankAccounts, carrierMinRates, pricingTables, pricingTableRows, identityVerifications, documentReviewTasks, orderStatusEvents, smsTemplates, smsLogs, webhookLogs, integrationHealth, systemEvents, refunds, supportTicketEscalations, closingReports, contracts, incidentReports, incidentEvidence, incidentActions, auditLogs, orderStartTokens, integrationEvents, users, orderApplications, closingFieldSettings, carrierPricingPolicies, urgentFeePolicies, platformFeePolicies, extraCostCatalog, orderPolicySnapshots, settlementRecords, customerServiceInquiries, refundPolicies, insertRefundPolicySchema, customerInquiries, inquiryComments, ticketEscalations, pushNotificationLogs, deductions } from "@shared/schema";
import { sql, eq, desc, and, or, inArray, not, isNull, gte, lte } from "drizzle-orm";
import { z } from "zod";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import multer from "multer";
import path from "path";
import fs from "fs";
import { notificationWS } from "./websocket";
import { registerObjectStorageRoutes, ObjectStorageService } from "./replit_integrations/object_storage";
import { smsService } from "./sms-service";
import { requireAuth, adminAuth, AuthenticatedRequest, requireRole, requireOwner } from "./utils/auth-middleware";
import { isValidImageBuffer, sanitizeFilename, MAX_FILE_SIZE } from "./utils/file-validation";
import { canTransitionSettlementStatus, SETTLEMENT_STATUS, logAdminAction, canTransitionOrderStatus, validateOrderStatus, ORDER_STATUS as ADMIN_ORDER_STATUS } from "./utils/admin-audit";
import { calculateSettlement, calculateHelperPayout, parseClosingReport } from "./lib/settlement-calculator";
import {
  ORDER_STATUS,
  CAN_APPLY_STATUSES,
  CAN_SELECT_HELPER_STATUSES,
  CAN_SUBMIT_CLOSING_STATUSES,
  CAN_APPROVE_CLOSING_STATUSES,
  CAN_CONFIRM_BALANCE_STATUSES,
  CAN_REVIEW_STATUSES,
  CANNOT_EDIT_STATUSES,
  CANNOT_DELETE_STATUSES,
  COMPLETED_STATUSES,
  IN_PROGRESS_STATUSES,
  normalizeOrderStatus,
  isOneOfStatus,
} from "./constants/order-status";
import { checkIdempotency, storeIdempotencyResponse, getIdempotencyKeyFromRequest } from "./utils/idempotency";
import { validateBody, authSchemas, orderSchemas, settlementSchemas, disputeSchemas, pushSchemas, adminSchemas, clientErrorSchema } from "./utils/validation";
import { authRateLimiter, signupRateLimiter, passwordResetRateLimiter, uploadRateLimiter, pushRateLimiter, strictRateLimiter } from "./utils/rate-limiter";
import { DEFAULT_COURIERS } from "./constants/defaultCouriers";
import { popbill } from "./lib/popbill";

// ============================================
// OAuth Redirect URI 환경변수 (배포/개발 환경별 명시 설정)
// ============================================
const OAUTH_BASE_URL = process.env.OAUTH_BASE_URL || "";

// ============================================
// 인증 감사 로그 헬퍼 함수
// ============================================
type AuthEventType = 
  | "login" | "login_failed" | "logout"
  | "signup" | "signup_failed"
  | "social_login" | "social_login_failed" | "social_signup"
  | "identity_verification" | "identity_verification_failed"
  | "password_change" | "password_reset";

async function logAuthEvent(
  req: Request,
  eventType: AuthEventType,
  status: "success" | "failure" | "pending",
  options: {
    userId?: string | null;
    provider?: string;
    metadata?: Record<string, any>;
  } = {}
) {
  try {
    const ipAddress = (req.headers["x-forwarded-for"] as string)?.split(",")[0]?.trim() 
      || req.socket.remoteAddress 
      || "unknown";
    const userAgent = req.headers["user-agent"] || "unknown";
    const requestId = (req as any).requestId || randomUUID().slice(0, 8);

    await db.insert(authAuditLogs).values({
      userId: options.userId || null,
      eventType,
      provider: options.provider || null,
      status,
      ipAddress,
      userAgent,
      requestId,
      metadata: options.metadata ? JSON.stringify(options.metadata) : null,
    });
  } catch (err) {
    console.error("[AuthAudit] Failed to log event:", err);
  }
}


// ============================================
// 계약금 정보 조회 (SSOT - Single Source of Truth)
// ============================================
interface DepositInfo {
  depositAmount: number;
  paymentStatus: 'paid' | 'unpaid';
}

async function getOrderDepositInfo(orderId: number): Promise<DepositInfo> {
  console.log('[DepositInfo] Calculating for order:', orderId);
  
  // 1. contracts 테이블에서 확정된 계약금 조회
  const [existingContract] = await db.select()
    .from(contracts)
    .where(eq(contracts.orderId, orderId))
    .limit(1);
  
  if (existingContract && existingContract.depositAmount) {
    console.log('[DepositInfo] Found contract deposit:', existingContract.depositAmount);
    return {
      depositAmount: Number(existingContract.depositAmount),
      paymentStatus: 'paid'
    };
  }
  
  // 2. 계약 없으면 오더 정보로 예상 계약금 계산
  const [order] = await db.select()
    .from(orders)
    .where(eq(orders.id, orderId))
    .limit(1);
  
  if (!order) {
    console.log('[DepositInfo] Order not found');
    return { depositAmount: 0, paymentStatus: 'unpaid' };
  }
  
  const pricePerUnit = Number(order.pricePerUnit) || 0;
  const quantity = parseInt(String(order.averageQuantity || "0").replace(/[^0-9]/g, "")) || 0;
  console.log('[DepositInfo] pricePerUnit:', pricePerUnit, 'quantity:', quantity);
  const supplyAmount = pricePerUnit * quantity;
  const totalAmountWithVat = Math.round(supplyAmount * 1.1);
  const depositAmount = Math.round(totalAmountWithVat * 0.2);
  console.log('[DepositInfo] Calculated deposit:', depositAmount);
  
  // order.paymentStatus가 deposit_confirmed이면 결제완료로 처리
  const isPaid = order.paymentStatus === 'deposit_confirmed' || order.paymentStatus === 'paid';
  return { depositAmount, paymentStatus: isPaid ? 'paid' : 'unpaid' };
}

// ============================================
// 연락처 공개 여부 확인 (계약금 입금 후에만 공개)
// ============================================
async function canRevealContact(orderId: number): Promise<boolean> {
  try {
    const [contract] = await db.select()
      .from(contracts)
      .where(eq(contracts.orderId, orderId))
      .limit(1);

    // 계약이 존재하고 계약금이 입금되었으면 true
    return !!(contract && contract.depositPaidAt);
  } catch (err) {
    console.error('[canRevealContact] Error:', err);
    return false;
  }
}

// ============================================
// 개인식별 코드 생성 (12자리 영문+숫자, 암호학적 안전)
// ============================================
function generatePersonalCode(): string {
  const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789"; // 혼동 방지: I,O,0,1 제외
  const bytes = randomBytes(12); // 암호학적 안전한 난수 사용
  let code = "";
  for (let i = 0; i < 12; i++) {
    code += chars.charAt(bytes[i] % chars.length);
  }
  return code;
}

async function getOrCreatePersonalCode(userId: string): Promise<string> {
  const user = await storage.getUser(userId);
  if (!user) throw new Error("User not found");
  
  if (user.personalCode) {
    return user.personalCode;
  }
  
  // 새 코드 생성 (중복 및 유니크 제약조건 충돌 처리)
  const maxAttempts = 10;
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const code = generatePersonalCode();
    try {
      // 먼저 중복 검사
      const existing = await storage.getUserByPersonalCode(code);
      if (existing) continue;
      
      // DB 업데이트 시도 (유니크 제약조건으로 atomic 처리)
      await storage.updateUser(userId, { personalCode: code });
      return code;
    } catch (err: any) {
      // 유니크 제약조건 위반 시 재시도 (23505 = unique_violation)
      if (err?.code === "23505" && attempt < maxAttempts - 1) {
        continue;
      }
      throw err;
    }
  }
  
  throw new Error("Failed to generate unique personal code after max attempts");
}

const uploadDir = path.join(process.cwd(), "uploads", "vehicles");
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}

const vehicleImageStorage = multer.diskStorage({
  destination: (_req, _file, cb) => {
    cb(null, uploadDir);
  },
  filename: (_req, file, cb) => {
    const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  },
});

const uploadVehicleImage = multer({
  storage: vehicleImageStorage,
  limits: { fileSize: 10 * 1024 * 1024 },
  fileFilter: (_req, file, cb) => {
    const allowedTypes = /jpeg|jpg|png|webp/;
    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
    const mimetype = allowedTypes.test(file.mimetype);
    if (extname && mimetype) {
      cb(null, true);
    } else {
      cb(new Error("이미지 파일만 업로드 가능합니다 (jpg, png, webp)"));
    }
  },
});

// JWT 시크릿 설정 - 운영 환경에서는 반드시 설정 필요
const isProduction = process.env.NODE_ENV === "production";
if (isProduction && !process.env.JWT_SECRET) {
  console.error("[SECURITY] JWT_SECRET is not set in production environment!");
  console.error("[SECURITY] Please set JWT_SECRET environment variable for security.");
}
const JWT_SECRET = process.env.JWT_SECRET || (isProduction ? "" : "dev-secret-key-change-in-production");
if (!JWT_SECRET) {
  throw new Error("JWT_SECRET must be set in production environment");
}

// Helper function to broadcast updates to all connected admin users
async function broadcastToAllAdmins(eventType: string, action: string, entityId?: number | string, data?: any) {
  try {
    const allUsers = await storage.getAllUsers();
    const adminUserIds = allUsers
      .filter(u => u.isHqStaff === true || u.isTeamLeader === true)
      .map(u => u.id);
    
    if (adminUserIds.length > 0) {
      notificationWS.broadcastToAdmins(adminUserIds, {
        type: eventType,
        action,
        entityId,
        data,
      });
    }
  } catch (e) {
    console.error("Failed to broadcast to admins:", e);
  }
}

// Helper function to notify all helpers on an order
async function notifyOrderHelpers(orderId: number, eventType: string, status: string) {
  try {
    const applications = await storage.getOrderApplications(orderId);
    const approvedApps = applications.filter(a => a.status === "approved" || a.status === "matched");
    
    for (const app of approvedApps) {
      notificationWS.sendOrderStatusUpdate(app.helperId, {
        orderId,
        status,
      });
    }
  } catch (e) {
    console.error("Failed to notify order helpers:", e);
  }
}

// Broadcast new order to all active helpers (for real-time job list updates)
async function broadcastNewOrderToHelpers(orderData: {
  orderId: number;
  courierCompany?: string;
  deliveryArea?: string;
  scheduledDate?: string;
}) {
  try {
    const allUsers = await storage.getAllUsers();
    const helperUserIds = allUsers
      .filter(u => u.role === "helper" && u.status === "active")
      .map(u => u.id);
    
    if (helperUserIds.length > 0) {
      notificationWS.broadcastNewOrderToHelpers(helperUserIds, orderData);
    }
  } catch (e) {
    console.error("Failed to broadcast new order to helpers:", e);
  }
}

// Seed master data for app/admin compatibility
async function seedMasterData() {
  // 앱 기본 택배사 목록 (DEFAULT_COURIERS 기반)
  const couriers = DEFAULT_COURIERS.map(name => ({
    courierName: name,
    minDeliveryFee: 0,
    commissionRate: 0,
    isDefault: name === "기타",
  }));

  // 5개 차종
  const vehicleTypes = [
    { vehicleTypeName: "1톤 하이탑", sortOrder: 1 },
    { vehicleTypeName: "1톤 정탑", sortOrder: 2 },
    { vehicleTypeName: "1톤 저탑", sortOrder: 3 },
    { vehicleTypeName: "1톤 냉탑", sortOrder: 4 },
    { vehicleTypeName: "무관", sortOrder: 5, isDefault: true },
  ];

  // 4개 카테고리
  const categories = [
    { categoryName: "택배사", sortOrder: 1 },
    { categoryName: "기타택배", sortOrder: 2 },
    { categoryName: "냉잡전용", sortOrder: 3 },
    { categoryName: "채용공고", sortOrder: 4, isAdminOnly: true },
  ];

  // Seed couriers
  for (const courier of couriers) {
    const existing = await storage.getCourierSettingByName(courier.courierName);
    if (!existing) {
      await storage.createCourierSetting(courier);
      console.log(`Seeded courier: ${courier.courierName}`);
    }
  }

  // Seed vehicle types
  for (const vt of vehicleTypes) {
    const existing = await storage.getVehicleTypeSettingByName(vt.vehicleTypeName);
    if (!existing) {
      await storage.createVehicleTypeSetting(vt);
      console.log(`Seeded vehicle type: ${vt.vehicleTypeName}`);
    }
  }

  // Seed categories
  for (const cat of categories) {
    const existing = await storage.getOrderCategorySettingByName(cat.categoryName);
    if (!existing) {
      await storage.createOrderCategorySetting(cat);
      console.log(`Seeded category: ${cat.categoryName}`);
    }
  }
}

// Helper function to send FCM push notifications to native devices
async function sendFcmToUser(userId: string, payload: { title: string; body: string; url?: string; tag?: string }) {
  try {
    const allTokens = await storage.getFcmTokensByUser(userId);
    // Filter out Expo Push Tokens (handled by sendExpoPushToUser)
    const fcmTokens = allTokens.filter(t => !t.token.startsWith('ExponentPushToken['));
    if (fcmTokens.length === 0) {
      return { sent: 0, failed: 0 };
    }

    const firebaseConfig = process.env.FIREBASE_SERVICE_ACCOUNT_KEY;
    if (!firebaseConfig) {
      console.log("[FCM] Firebase service account not configured");
      return { sent: 0, failed: 0 };
    }

    let serviceAccount;
    try {
      serviceAccount = JSON.parse(firebaseConfig);
    } catch {
      console.error("[FCM] Invalid Firebase service account JSON");
      return { sent: 0, failed: 0 };
    }

    const { GoogleAuth } = await import("google-auth-library");
    const auth = new GoogleAuth({
      credentials: serviceAccount,
      scopes: ["https://www.googleapis.com/auth/firebase.messaging"],
    });

    const accessToken = await auth.getAccessToken();
    if (!accessToken) {
      console.error("[FCM] Failed to get access token");
      return { sent: 0, failed: 0 };
    }

    const projectId = serviceAccount.project_id;
    const fcmUrl = `https://fcm.googleapis.com/v1/projects/${projectId}/messages:send`;

    let sent = 0;
    let failed = 0;

    for (const tokenRecord of fcmTokens) {
      try {
        const message = {
          message: {
            token: tokenRecord.token,
            notification: {
              title: payload.title,
              body: payload.body,
            },
            data: {
              url: payload.url || "/",
              tag: payload.tag || "notification-" + Date.now(),
            },
            android: {
              priority: "high" as const,
              notification: {
                click_action: "FLUTTER_NOTIFICATION_CLICK",
                channel_id: "default",
              },
            },
            apns: {
              payload: {
                aps: {
                  sound: "default",
                  badge: 1,
                },
              },
            },
          },
        };

        const response = await fetch(fcmUrl, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${accessToken}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify(message),
        });

        if (response.ok) {
          sent++;
        } else {
          const errorData = await response.json().catch(() => ({}));
          console.error("[FCM] Send error:", errorData);
          failed++;
          
          // Remove invalid tokens
          if (response.status === 404 || response.status === 410 || 
              (errorData as any)?.error?.details?.some((d: any) => 
                d.errorCode === "UNREGISTERED" || d.errorCode === "INVALID_ARGUMENT")) {
            await storage.deleteFcmToken(tokenRecord.token);
          }
        }
      } catch (err: any) {
        console.error("[FCM] Token send error:", err.message);
        failed++;
      }
    }

    console.log(`[FCM] Sent to user ${userId}: ${sent} success, ${failed} failed`);
    return { sent, failed };
  } catch (err) {
    console.error("[FCM] sendFcmToUser error:", err);
    return { sent: 0, failed: 0 };
  }
}
// Send push notification via Expo Push API (for Expo Push Tokens)
async function sendExpoPushToUser(userId: string, payload: { title: string; body: string; url?: string; tag?: string }) {
  try {
    const fcmTokens = await storage.getFcmTokensByUser(userId);
    // Filter for Expo Push Tokens (format: ExponentPushToken[xxx])
    const expoTokens = fcmTokens.filter(t => t.token.startsWith('ExponentPushToken['));
    
    if (expoTokens.length === 0) {
      return { sent: 0, failed: 0 };
    }

    const messages = expoTokens.map(tokenRecord => ({
      to: tokenRecord.token,
      sound: 'default',
      title: payload.title,
      body: payload.body,
      data: { url: payload.url || '/', tag: payload.tag || 'notification-' + Date.now() },
    }));

    // Send via Expo Push API
    const response = await fetch('https://exp.host/--/api/v2/push/send', {
      method: 'POST',
      headers: {
        'Accept': 'application/json',
        'Accept-encoding': 'gzip, deflate',
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(messages),
    });

    if (!response.ok) {
      console.error('[Expo Push] API error:', await response.text());
      return { sent: 0, failed: expoTokens.length };
    }

    const result = await response.json();
    let sent = 0;
    let failed = 0;

    // Handle response tickets
    if (result.data && Array.isArray(result.data)) {
      for (let i = 0; i < result.data.length; i++) {
        const ticket = result.data[i];
        if (ticket.status === 'ok') {
          sent++;
        } else {
          failed++;
          // Remove invalid tokens
          if (ticket.details?.error === 'DeviceNotRegistered') {
            await storage.deleteFcmToken(expoTokens[i].token);
          }
        }
      }
    }

    console.log(`[Expo Push] Sent to user ${userId}: ${sent} success, ${failed} failed`);
    return { sent, failed };
  } catch (err) {
    console.error('[Expo Push] Error:', err);
    return { sent: 0, failed: 0 };
  }
}


// Helper function to send web push notifications to a user (includes both Web Push and FCM)
async function sendPushToUser(userId: string, payload: { title: string; body: string; url?: string; tag?: string }) {
  // Send to Web Push, FCM, and Expo Push in parallel
  const [webResult, fcmResult, expoResult] = await Promise.all([
    sendWebPushToUser(userId, payload),
    sendFcmToUser(userId, payload),
    sendExpoPushToUser(userId, payload),
  ]);

  const totalSent = webResult.sent + fcmResult.sent + expoResult.sent;
  const totalFailed = webResult.failed + fcmResult.failed + expoResult.failed;
  
  if (totalSent > 0 || totalFailed > 0) {
    console.log(`[Push] Total sent to user ${userId}: ${totalSent} success, ${totalFailed} failed (Web: ${webResult.sent}, FCM: ${fcmResult.sent})`);
  }
  
  return { sent: totalSent, failed: totalFailed };
}

// Send push notifications to all admin/HQ staff users
async function sendPushToAdmins(payload: { title: string; body: string; url?: string; tag?: string }) {
  try {
    const admins = await storage.getAdminAndHQStaffUsers();
    const results = await Promise.all(
      admins.map(admin => sendPushToUser(admin.id, payload))
    );
    const totalSent = results.reduce((sum, r) => sum + r.sent, 0);
    const totalFailed = results.reduce((sum, r) => sum + r.failed, 0);
    console.log(`[Push] Sent to ${admins.length} admins: ${totalSent} success, ${totalFailed} failed`);
    return { sent: totalSent, failed: totalFailed };
  } catch (error) {
    console.error('[Push] Error sending to admins:', error);
    return { sent: 0, failed: 0 };
  }
}

// Helper function to send web push notifications via VAPID
async function sendWebPushToUser(userId: string, payload: { title: string; body: string; url?: string; tag?: string }) {
  try {
    const subscriptions = await storage.getPushSubscriptionsByUser(userId);
    if (subscriptions.length === 0) {
      return { sent: 0, failed: 0 };
    }

    const webpush = await import("web-push");
    const vapidPublicKey = process.env.VAPID_PUBLIC_KEY;
    const vapidPrivateKey = process.env.VAPID_PRIVATE_KEY;

    if (!vapidPublicKey || !vapidPrivateKey) {
      console.log("[WebPush] VAPID keys not configured");
      return { sent: 0, failed: 0 };
    }

    webpush.setVapidDetails(
      "mailto:admin@hellpme.com",
      vapidPublicKey,
      vapidPrivateKey
    );

    const pushPayload = JSON.stringify({
      title: payload.title,
      body: payload.body,
      url: payload.url || "/",
      tag: payload.tag || "notification-" + Date.now(),
    });

    let sent = 0;
    let failed = 0;

    for (const sub of subscriptions) {
      try {
        await webpush.sendNotification(
          {
            endpoint: sub.endpoint,
            keys: { p256dh: sub.p256dh, auth: sub.auth },
          },
          pushPayload
        );
        sent++;
      } catch (err: any) {
        console.error("[WebPush] Send error:", err.message);
        failed++;
        if (err.statusCode === 404 || err.statusCode === 410) {
          await storage.deletePushSubscription(sub.id);
        }
      }
    }

    return { sent, failed };
  } catch (err) {
    console.error("[WebPush] sendWebPushToUser error:", err);
    return { sent: 0, failed: 0 };
  }
}

// Seed RBAC roles, permissions, and role-permission mappings
async function seedRbacData() {
  console.log("Verifying RBAC data...");
  
  const existingRoles = await storage.getAllAdminRoles();
  const existingPerms = await storage.getAllAdminPermissions();
  const existingRoleMap = Object.fromEntries(existingRoles.map(r => [r.code, r.id]));
  const existingPermMap = Object.fromEntries(existingPerms.map(p => [p.key, p.id]));
  
  // 7 Roles
  const roles = [
    { code: "SUPER_ADMIN", name: "최고관리자", description: "모든 권한을 가진 최고 관리자", level: 100, isActive: true },
    { code: "ADMIN", name: "관리자", description: "대부분의 관리 권한을 가진 관리자", level: 80, isActive: true },
    { code: "MANAGER", name: "매니저", description: "운영 관리 권한을 가진 매니저", level: 60, isActive: true },
    { code: "FINANCE", name: "재무담당", description: "정산 및 결제 관련 권한", level: 50, isActive: true },
    { code: "TEAM_LEAD", name: "팀장", description: "팀 관리 권한", level: 40, isActive: true },
    { code: "CS", name: "고객지원", description: "고객 지원 및 문의 처리 권한", level: 30, isActive: true },
    { code: "STAFF", name: "일반직원", description: "기본 조회 권한만 가진 직원", level: 10, isActive: true },
  ];

  const createdRoles: Record<string, number> = {};
  let rolesCreated = 0;
  for (const role of roles) {
    if (existingRoleMap[role.code]) {
      createdRoles[role.code] = existingRoleMap[role.code];
    } else {
      const created = await storage.createAdminRole(role);
      createdRoles[role.code] = created.id;
      rolesCreated++;
      console.log(`Created role: ${role.code}`);
    }
  }

  // 62 Permissions across 13 domains
  const permissionDefs = [
    // Orders
    { key: "orders.view", domain: "orders", resource: "orders", action: "view", description: "오더 목록 및 상세 조회" },
    { key: "orders.create", domain: "orders", resource: "orders", action: "create", description: "새 오더 생성" },
    { key: "orders.edit", domain: "orders", resource: "orders", action: "edit", description: "오더 정보 수정" },
    { key: "orders.delete", domain: "orders", resource: "orders", action: "delete", description: "오더 삭제" },
    { key: "orders.assign", domain: "orders", resource: "orders", action: "assign", description: "헬퍼에게 오더 배정" },
    { key: "orders.force_override", domain: "orders", resource: "orders", action: "force_override", description: "오더 상태 강제 변경 (상태 머신 우회)" },
    { key: "orders.manage", domain: "orders", resource: "orders", action: "manage", description: "오더 관리" },
    // Enterprise
    { key: "enterprise.view", domain: "enterprise", resource: "enterprise", action: "view", description: "본사 계약 업체 및 오더 조회" },
    { key: "enterprise.create", domain: "enterprise", resource: "enterprise", action: "create", description: "본사 계약 업체 생성" },
    { key: "enterprise.edit", domain: "enterprise", resource: "enterprise", action: "edit", description: "본사 계약 정보 수정" },
    { key: "enterprise.upload", domain: "enterprise", resource: "enterprise", action: "upload", description: "CSV 오더 일괄 업로드" },
    // Dispatch
    { key: "dispatch.view", domain: "dispatch", resource: "dispatch", action: "view", description: "대행배차 신청 목록 조회" },
    { key: "dispatch.assign", domain: "dispatch", resource: "dispatch", action: "assign", description: "헬퍼 배정" },
    { key: "dispatch.edit", domain: "dispatch", resource: "dispatch", action: "edit", description: "배차 정보 수정" },
    // Matching
    { key: "matching.view", domain: "matching", resource: "matching", action: "view", description: "오더-헬퍼 매칭 현황 조회" },
    { key: "matching.assign", domain: "matching", resource: "matching", action: "assign", description: "수동 매칭 배정" },
    // Contracts
    { key: "contracts.view", domain: "contracts", resource: "contracts", action: "view", description: "계약 목록 및 상세 조회" },
    { key: "contracts.edit", domain: "contracts", resource: "contracts", action: "edit", description: "계약 정보 수정" },
    { key: "contracts.execute", domain: "contracts", resource: "contracts", action: "execute", description: "계약 법적 효력 발생" },
    // Payments
    { key: "payments.view", domain: "payments", resource: "payments", action: "view", description: "결제 내역 조회" },
    { key: "payments.refund", domain: "payments", resource: "payments", action: "refund", description: "결제 환불 처리" },
    { key: "payments.capture", domain: "payments", resource: "payments", action: "capture", description: "결제 확정 처리" },
    { key: "payments.create", domain: "payments", resource: "payments", action: "create", description: "결제 생성" },
    { key: "payments.edit", domain: "payments", resource: "payments", action: "edit", description: "결제 정보 수정" },
    // Settlements
    { key: "settlements.view", domain: "settlements", resource: "settlements", action: "view", description: "정산 내역 조회" },
    { key: "settlements.create", domain: "settlements", resource: "settlements", action: "create", description: "정산서 생성" },
    { key: "settlements.approve", domain: "settlements", resource: "settlements", action: "approve", description: "정산 승인" },
    { key: "settlements.pay", domain: "settlements", resource: "settlements", action: "pay", description: "정산 지급 처리" },
    { key: "settlements.edit", domain: "settlements", resource: "settlements", action: "edit", description: "정산 정보 수정" },
    { key: "settlements.confirm", domain: "settlements", resource: "settlements", action: "confirm", description: "정산 확정" },
    { key: "settlements.manage", domain: "settlements", resource: "settlements", action: "manage", description: "정산 관리" },
    // Incentives
    { key: "incentives.view", domain: "incentives", resource: "incentives", action: "view", description: "팀장 인센티브 조회" },
    { key: "incentives.calc", domain: "incentives", resource: "incentives", action: "calc", description: "인센티브 계산 실행" },
    { key: "incentives.approve", domain: "incentives", resource: "incentives", action: "approve", description: "인센티브 지급 승인" },
    { key: "incentives.pay", domain: "incentives", resource: "incentives", action: "pay", description: "인센티브 지급 처리" },
    // Disputes
    { key: "disputes.view", domain: "disputes", resource: "disputes", action: "view", description: "분쟁/사고 내역 조회" },
    { key: "disputes.review", domain: "disputes", resource: "disputes", action: "review", description: "분쟁 검토 시작" },
    { key: "disputes.resolve", domain: "disputes", resource: "disputes", action: "resolve", description: "분쟁 해결 처리" },
    { key: "disputes.escalate", domain: "disputes", resource: "disputes", action: "escalate", description: "상위자에게 분쟁 회부" },
    { key: "disputes.edit", domain: "disputes", resource: "disputes", action: "edit", description: "분쟁 정보 수정" },
    // Sanctions
    { key: "sanctions.view", domain: "sanctions", resource: "sanctions", action: "view", description: "제재/블랙리스트 조회" },
    { key: "sanctions.create", domain: "sanctions", resource: "sanctions", action: "create", description: "제재 부과" },
    { key: "sanctions.edit", domain: "sanctions", resource: "sanctions", action: "edit", description: "제재 정보 수정" },
    { key: "sanctions.delete", domain: "sanctions", resource: "sanctions", action: "delete", description: "제재 해제" },
    // Helpers
    { key: "helpers.view", domain: "helpers", resource: "helpers", action: "view", description: "헬퍼 목록 및 상세 조회" },
    { key: "helpers.edit", domain: "helpers", resource: "helpers", action: "edit", description: "헬퍼 정보 수정" },
    { key: "helpers.verify", domain: "helpers", resource: "helpers", action: "verify", description: "헬퍼 자격 심사" },
    { key: "helpers.manage", domain: "helpers", resource: "helpers", action: "manage", description: "헬퍼 관리" },
    // Requesters
    { key: "requesters.view", domain: "requesters", resource: "requesters", action: "view", description: "요청자 목록 및 상세 조회" },
    { key: "requesters.edit", domain: "requesters", resource: "requesters", action: "edit", description: "요청자 정보 수정" },
    // Users
    { key: "users.view", domain: "users", resource: "users", action: "view", description: "사용자 목록 조회" },
    { key: "users.edit", domain: "users", resource: "users", action: "edit", description: "사용자 정보 수정" },
    // Teams
    { key: "teams.view", domain: "teams", resource: "teams", action: "view", description: "팀 목록 및 상세 조회" },
    { key: "teams.create", domain: "teams", resource: "teams", action: "create", description: "새 팀 생성" },
    { key: "teams.edit", domain: "teams", resource: "teams", action: "edit", description: "팀 정보 수정" },
    { key: "teams.qr", domain: "teams", resource: "teams", action: "qr", description: "팀 QR 코드 관리" },
    { key: "teams.delete", domain: "teams", resource: "teams", action: "delete", description: "팀 삭제" },
    // Carriers
    { key: "carriers.view", domain: "carriers", resource: "carriers", action: "view", description: "운송사 및 최저요금 조회" },
    { key: "carriers.edit", domain: "carriers", resource: "carriers", action: "edit", description: "운송사 정보 및 요금 수정" },
    // Pricing
    { key: "pricing.view", domain: "pricing", resource: "pricing", action: "view", description: "요금 설정 조회" },
    { key: "pricing.edit", domain: "pricing", resource: "pricing", action: "edit", description: "요금 설정 변경" },
    // Policies
    { key: "policies.view", domain: "policies", resource: "policies", action: "view", description: "정책 설정 조회" },
    { key: "policies.edit", domain: "policies", resource: "policies", action: "edit", description: "정책 설정 변경" },
    // Tax
    { key: "tax.view", domain: "tax", resource: "tax", action: "view", description: "세금계산서 조회" },
    { key: "tax.issue", domain: "tax", resource: "tax", action: "issue", description: "정발행 처리" },
    { key: "tax.reverse", domain: "tax", resource: "tax", action: "reverse", description: "역발행 처리" },
    { key: "tax.cancel", domain: "tax", resource: "tax", action: "cancel", description: "세금계산서 취소" },
    // Staff
    { key: "staff.view", domain: "staff", resource: "staff", action: "view", description: "본사 직원 조회" },
    { key: "staff.create", domain: "staff", resource: "staff", action: "create", description: "본사 직원 추가" },
    { key: "staff.edit", domain: "staff", resource: "staff", action: "edit", description: "직원 정보 수정" },
    { key: "staff.roles", domain: "staff", resource: "staff", action: "roles", description: "역할 및 권한 관리" },
    // Notifications
    { key: "notifications.view", domain: "notifications", resource: "notifications", action: "view", description: "알림 템플릿 및 내역 조회" },
    { key: "notifications.send", domain: "notifications", resource: "notifications", action: "send", description: "알림 발송" },
    { key: "notifications.edit", domain: "notifications", resource: "notifications", action: "edit", description: "알림 템플릿 수정" },
    // Support
    { key: "support.view", domain: "support", resource: "support", action: "view", description: "고객지원 조회" },
    { key: "support.edit", domain: "support", resource: "support", action: "edit", description: "고객지원 처리" },
    // Settings
    { key: "settings.view", domain: "settings", resource: "settings", action: "view", description: "시스템 설정 조회" },
    { key: "settings.edit", domain: "settings", resource: "settings", action: "edit", description: "시스템 설정 변경" },
  ];

  const createdPermissions: Record<string, number> = {};
  let permsCreated = 0;
  for (const perm of permissionDefs) {
    if (existingPermMap[perm.key]) {
      createdPermissions[perm.key] = existingPermMap[perm.key];
    } else {
      const created = await storage.createAdminPermission({
        key: perm.key,
        domain: perm.domain,
        resource: perm.resource,
        action: perm.action,
        description: perm.description,
        isActive: true,
      });
      createdPermissions[perm.key] = created.id;
      permsCreated++;
      console.log(`Created permission: ${perm.key}`);
    }
  }

  // Role-Permission Mappings (derived from canonical permissionDefs)
  const canonicalPermKeys = permissionDefs.map(p => p.key);
  // Dangerous permissions that bypass normal workflows - only SUPER_ADMIN gets these
  const dangerousPerms = ["orders.force_override"];
  const roleMappings: Record<string, string[]> = {
    SUPER_ADMIN: canonicalPermKeys, // All 63 permissions
    ADMIN: canonicalPermKeys.filter(k => k !== "staff.roles" && !dangerousPerms.includes(k)),
    MANAGER: canonicalPermKeys.filter(k => 
      ["orders", "enterprise", "dispatch", "matching", "contracts", "helpers", "requesters", "teams"].some(d => k.startsWith(d + ".")) &&
      !dangerousPerms.includes(k)
    ),
    FINANCE: canonicalPermKeys.filter(k => 
      ["payments", "settlements", "incentives", "tax", "contracts"].some(d => k.startsWith(d + "."))
    ),
    TEAM_LEAD: canonicalPermKeys.filter(k => 
      (["teams", "helpers", "orders", "dispatch"].some(d => k.startsWith(d + "."))) && 
      ["view", "edit", "assign"].some(a => k.endsWith("." + a))
    ),
    CS: canonicalPermKeys.filter(k => 
      (["orders", "helpers", "requesters", "disputes", "notifications"].some(d => k.startsWith(d + "."))) && 
      ["view", "review", "send"].some(a => k.endsWith("." + a))
    ),
    STAFF: canonicalPermKeys.filter(k => k.endsWith(".view")),
  };

  // Build canonical 203 role-permission pairs (fail if IDs missing)
  const expectedMappingPairs: Array<{roleId: number, permId: number, roleCode: string, permKey: string}> = [];
  const missingIds: string[] = [];
  for (const [roleCode, permKeys] of Object.entries(roleMappings)) {
    const roleId = createdRoles[roleCode];
    if (!roleId) {
      missingIds.push(`role:${roleCode}`);
      continue;
    }
    for (const permKey of permKeys) {
      const permId = createdPermissions[permKey];
      if (!permId) {
        missingIds.push(`perm:${permKey}`);
        continue;
      }
      expectedMappingPairs.push({ roleId, permId, roleCode, permKey });
    }
  }
  if (missingIds.length > 0) {
    throw new Error(`RBAC FATAL: Cannot seed - missing IDs for ${missingIds.slice(0, 10).join(", ")}${missingIds.length > 10 ? "..." : ""}`);
  }

  // Always reconcile role-permission mappings (idempotent upsert)
  let mappingsCreated = 0;
  let mappingErrors = 0;
  for (const { roleId, permId, roleCode, permKey } of expectedMappingPairs) {
    try {
      await storage.assignPermissionToRole(roleId, permId);
      mappingsCreated++;
    } catch (err: any) {
      // Ignore duplicate constraint errors (PostgreSQL 23505, SQLite/Prisma variants)
      const isDuplicate = err?.code === "23505" || 
        err?.code === "P2002" || 
        err?.message?.includes("duplicate") || 
        err?.message?.includes("UNIQUE constraint");
      if (!isDuplicate) {
        mappingErrors++;
        console.error(`Failed to assign permission ${permKey} to role ${roleCode}: ${err?.message || err}`);
      }
    }
  }

  // Verification: check exact role codes, permission keys, and mapping count
  const finalRoles = await storage.getAllAdminRoles();
  const finalPerms = await storage.getAllAdminPermissions();
  const finalRoleCodes = new Set(finalRoles.map(r => r.code));
  const finalPermKeys = new Set(finalPerms.map(p => p.key));
  
  const expectedRoleCodes = ["SUPER_ADMIN", "ADMIN", "MANAGER", "FINANCE", "TEAM_LEAD", "CS", "STAFF"];
  const canonicalRoleSet = new Set(expectedRoleCodes);
  const canonicalPermSet = new Set(canonicalPermKeys);
  
  const missingRoles = expectedRoleCodes.filter(c => !finalRoleCodes.has(c));
  const missingPerms = permissionDefs.filter(p => !finalPermKeys.has(p.key)).map(p => p.key);
  
  // Handle extra roles and permissions (not in canonical set)
  // Production: only warn, do not delete (to protect custom roles)
  // Development: delete for clean state
  let extraRolesDeleted = 0;
  let extraPermsDeleted = 0;
  const isProduction = process.env.NODE_ENV === "production";
  
  for (const role of finalRoles) {
    if (!canonicalRoleSet.has(role.code)) {
      if (isProduction) {
        console.warn(`[RBAC] Extra role found (not deleted in production): ${role.code}`);
      } else {
        await storage.deleteAdminRole(role.id);
        extraRolesDeleted++;
        console.log(`Deleted extra role: ${role.code}`);
      }
    }
  }
  for (const perm of finalPerms) {
    if (!canonicalPermSet.has(perm.key)) {
      if (isProduction) {
        console.warn(`[RBAC] Extra permission found (not deleted in production): ${perm.key}`);
      } else {
        await storage.deleteAdminPermission(perm.id);
        extraPermsDeleted++;
        console.log(`Deleted extra permission: ${perm.key}`);
      }
    }
  }
  
  // Skip exhaustive O(R*P) verification in development for fast startup
  const isDev = process.env.NODE_ENV === "development";
  
  let missingMappings = 0;
  let surplusMappings = 0;
  const canonicalSet = new Set(expectedMappingPairs.map(p => `${p.roleId}:${p.permId}`));
  
  if (!isDev) {
    // Production: full mapping verification
    for (const { roleId, permId } of expectedMappingPairs) {
      const rolePerms = await storage.getRolePermissions(roleId);
      if (!rolePerms.some(p => p.id === permId)) {
        missingMappings++;
      }
    }
    
    // Remove surplus mappings from ALL roles
    const reloadedRoles = await storage.getAllAdminRoles();
    for (const role of reloadedRoles) {
      const rolePerms = await storage.getRolePermissions(role.roleId);
      for (const perm of rolePerms) {
        if (!canonicalSet.has(`${role.id}:${perm.id}`)) {
          try {
            await storage.removePermissionFromRole(role.id, perm.id);
            surplusMappings++;
          } catch (err: any) {
            console.error(`Failed to remove surplus mapping: ${err?.message}`);
          }
        }
      }
    }
  }
  
  const errors: string[] = [];
  if (missingRoles.length > 0) errors.push(`missing roles: [${missingRoles.join(", ")}]`);
  if (missingPerms.length > 0) errors.push(`missing perms: [${missingPerms.slice(0, 5).join(", ")}${missingPerms.length > 5 ? "..." : ""}]`);
  if (mappingErrors > 0) errors.push(`mapping errors: ${mappingErrors}`);
  if (!isDev && missingMappings > 0) errors.push(`missing mappings: ${missingMappings}`);
  
  if (errors.length > 0) {
    throw new Error(`RBAC FATAL: verification failed - ${errors.join(", ")}`);
  }
  
  const healingNotes: string[] = [];
  if (extraRolesDeleted > 0) healingNotes.push(`${extraRolesDeleted} extra roles`);
  if (extraPermsDeleted > 0) healingNotes.push(`${extraPermsDeleted} extra perms`);
  if (surplusMappings > 0) healingNotes.push(`${surplusMappings} surplus mappings`);
  const healingNote = healingNotes.length > 0 ? ` (removed: ${healingNotes.join(", ")})` : "";
  console.log(`RBAC verified: 7 roles, 63 permissions, 203 mappings OK${isDev ? " (dev mode)" : ""}${healingNote}`);
}

// Ensure admin user exists (runs in ALL environments including production)
async function ensureAdminUser() {
  const adminEmail = "jshmir7070@gmail.com";
  const adminPassword = "jsh!!15988";
  let adminUser = await storage.getUserByEmail(adminEmail);
  const hashedAdminPassword = await bcrypt.hash(adminPassword, 10);
  
  if (!adminUser) {
    adminUser = await storage.createUser({
      username: adminEmail,
      email: adminEmail,
      name: "최고관리자",
      password: hashedAdminPassword,
      role: "superadmin",
      isHqStaff: true,
      adminStatus: "active",
      mustChangePassword: false,
    });
    console.log(`Created superadmin user: ${adminEmail}`);
  } else {
    // Update existing admin user password, role, and ensure admin status
    await storage.updateUser(adminUser.id, {
      password: hashedAdminPassword,
      role: "superadmin",
      isHqStaff: true,
      adminStatus: "active",
      mustChangePassword: false,
    });
    console.log(`Updated superadmin user: ${adminEmail}`);
  }
}

// Seed test users and contracts
async function seedTestUsers() {
  const testUsers = [
    { email: "testhelper@test.com", name: "테스트 헬퍼", password: "Password1!", role: "helper", phoneNumber: "010-1234-5678" },
    { email: "testhelper2@test.com", name: "김배송", password: "Password1!", role: "helper", phoneNumber: "010-2345-6789" },
    { email: "testrequester@test.com", name: "테스트 사용자", password: "Password1!", role: "requester", phoneNumber: "010-3456-7890" },
    { email: "testrequester2@test.com", name: "박의뢰", password: "Password1!", role: "requester", phoneNumber: "010-4567-8901" },
  ];

  const createdUsers: Record<string, any> = {};

  for (const user of testUsers) {
    let existing = await storage.getUserByEmail(user.email);
    if (!existing) {
      const hashedPassword = await bcrypt.hash(user.password, 10);
      existing = await storage.createUser({
        username: user.email,
        email: user.email,
        name: user.name,
        password: hashedPassword,
        role: user.role,
        phoneNumber: user.phoneNumber,
      });
      console.log(`Created test user: ${user.email}`);
    }
    createdUsers[user.email] = existing;
  }
  
  // Seed test orders and contracts for settlement testing
  const existingOrders = await storage.getOrders();
  if (existingOrders.length === 0) {
    const helper1 = createdUsers["testhelper@test.com"];
    const helper2 = createdUsers["testhelper2@test.com"];
    const requester1 = createdUsers["testrequester@test.com"];
    const requester2 = createdUsers["testrequester2@test.com"];
    
    if (helper1 && requester1) {
      // Create test orders
      const order1 = await storage.createOrder({
        requesterId: requester1.id,
        companyName: "쿠팡 주간배송",
        pricePerUnit: 1200,
        averageQuantity: "400box",
        deliveryArea: "서울시 강남구",
        scheduledDate: "2024-12-20",
        vehicleType: "1톤 저탑",
        status: "scheduled",
        maxHelpers: 1,
        currentHelpers: 1,
      });
      
      const order2 = await storage.createOrder({
        requesterId: requester1.id,
        companyName: "CJ대한통운",
        pricePerUnit: 1500,
        averageQuantity: "300box",
        deliveryArea: "서울시 서초구",
        scheduledDate: "2024-12-22",
        vehicleType: "1톤 하이탑",
        status: "scheduled",
        maxHelpers: 1,
        currentHelpers: 1,
      });
      
      const order3 = await storage.createOrder({
        requesterId: requester2?.id || requester1.id,
        companyName: "한진택배",
        pricePerUnit: 1100,
        averageQuantity: "500box",
        deliveryArea: "서울시 마포구",
        scheduledDate: "2024-12-25",
        vehicleType: "1톤 정탑",
        status: "scheduled",
        maxHelpers: 1,
        currentHelpers: 1,
      });
      
      // Create test contracts with various payment states
      // Contract 1: Fully paid (for helper1)
      await storage.createContract({
        orderId: order1.id,
        helperId: helper1.id,
        requesterId: requester1.id,
        totalAmount: 480000,
        depositAmount: 96000,
        balanceAmount: 384000,
        depositPaid: true,
          depositPaidAt: new Date(),
          downPaymentStatus: "paid",
        balancePaid: true,
        balanceDueDate: "2024-12-20",
        status: "completed",
      });
      
      // Contract 2: Only deposit paid (for helper1) - balance overdue
      await storage.createContract({
        orderId: order2.id,
        helperId: helper1.id,
        requesterId: requester1.id,
        totalAmount: 450000,
        depositAmount: 90000,
        balanceAmount: 360000,
        depositPaid: true,
          depositPaidAt: new Date(),
          downPaymentStatus: "paid",
        balancePaid: false,
        balanceDueDate: "2024-12-15",
        status: "deposit_paid",
      });
      
      // Contract 3: For helper2
      await storage.createContract({
        orderId: order3.id,
        helperId: helper2?.id || helper1.id,
        requesterId: requester2?.id || requester1.id,
        totalAmount: 550000,
        depositAmount: 110000,
        balanceAmount: 440000,
        depositPaid: true,
          depositPaidAt: new Date(),
          downPaymentStatus: "paid",
        balancePaid: false,
        balanceDueDate: "2024-12-28",
        status: "deposit_paid",
      });
      
      console.log("Created test orders and contracts for settlement testing");
    }
  }
  
  // Seed helper bank accounts for settlement display
  const existingBankAccounts = await storage.getAllHelperBankAccounts();
  if (existingBankAccounts.length === 0) {
    const helper1 = createdUsers["testhelper@test.com"];
    const helper2 = createdUsers["testhelper2@test.com"];
    
    if (helper1) {
      await storage.createHelperBankAccount(helper1.id, {
        accountHolder: "테스트 헬퍼",
        bankName: "국민은행",
        accountNumber: "123-456-789012",
      });
    }
    if (helper2) {
      await storage.createHelperBankAccount(helper2.id, {
        accountHolder: "김배송",
        bankName: "신한은행",
        accountNumber: "987-654-321098",
      });
    }
    console.log("Created test helper bank accounts");
  }
}

// Permission checking middleware factory
// Dangerous permissions that require explicit RBAC check even for HQ staff
const dangerousPermsRequireRbac = ["orders.force_override"];

const requirePermission = (permission: string) => {
  return async (req: any, res: any, next: any) => {
    try {
      const userId = req.adminUser?.id || req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      
      // HQ staff bypass for normal permissions, but dangerous permissions always require RBAC check
      const adminUser = req.adminUser;
      const isDangerousPerm = dangerousPermsRequireRbac.includes(permission);
      
      if (adminUser?.isHqStaff === true && !isDangerousPerm) {
        console.log(`[RBAC] isHqStaff bypass for ${adminUser.email}, permission: ${permission}`);
        return next();
      }
      
      try {
        const userPermissions = await storage.getUserPermissions(userId);
        if (userPermissions.includes(permission)) {
          return next();
        }
      } catch (dbErr) {
        // RBAC tables might not exist - log and deny
        console.error("[RBAC] Permission check failed (tables may not exist):", dbErr);
      }
      
      return res.status(403).json({ message: "권한이 없습니다", required: permission });
    } catch (err) {
      return res.status(500).json({ message: "Permission check failed" });
    }
  };
};

// Helper function to get active refund policy
async function getActiveRefundPolicy(): Promise<{ beforeMatchingRate: number; afterMatchingRate: number }> {
  const today = new Date().toISOString().split('T')[0];
  const [policy] = await db
    .select()
    .from(refundPolicies)
    .where(
      and(
        eq(refundPolicies.isActive, true),
        lte(refundPolicies.effectiveFrom, today),
        or(
          isNull(refundPolicies.effectiveTo),
          gte(refundPolicies.effectiveTo, today)
        )
      )
    )
    .orderBy(desc(refundPolicies.isDefault), desc(refundPolicies.effectiveFrom))
    .limit(1);
  
  return {
    beforeMatchingRate: policy?.beforeMatchingRefundRate ?? 100,
    afterMatchingRate: policy?.afterMatchingRefundRate ?? 70
  };
}

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  // Seed data on startup
  await seedMasterData();
  await seedRbacData();
  
  // Always ensure admin user exists (runs in all environments)
  await ensureAdminUser();
  
  // Test seeding disabled - use manual account creation
  // if (process.env.NODE_ENV !== 'production' && process.env.SKIP_TEST_SEED !== 'true') {
  //   await seedTestUsers();
  // }

  // Register Object Storage routes
  registerObjectStorageRoutes(app);
  const objectStorageService = new ObjectStorageService();

  // ============================================
  // Health Check API - 서버 상태 점검용 (공개)
  // ============================================
  app.get("/api/health", async (_req, res) => {
    const { pool } = await import("./db");
    
    // DB 연결 테스트
    let dbStatus = "unknown";
    try {
      await pool.query("SELECT 1");
      dbStatus = "connected";
    } catch (err) {
      dbStatus = "disconnected";
      console.error("[Health] DB connection failed:", err);
    }
    
    // 공개 응답: 민감 정보 제외
    res.json({
      status: dbStatus === "connected" ? "healthy" : "unhealthy",
      timestamp: new Date().toISOString(),
    });
  });

  // ============================================
  // Client Error Logging - 클라이언트 오류 수집
  // ============================================
  app.post("/api/client-errors", validateBody(clientErrorSchema), async (req, res) => {
    try {
      const { timestamp, severity, message, stack, context, url } = req.body;
      
      // 중요 오류만 저장 (critical, error)
      if (severity === 'critical' || severity === 'error') {
        // 사용자 정보 추출 (있는 경우)
        let userId: string | undefined;
        const token = req.headers.authorization?.split(" ")[1];
        if (token) {
          try {
            const decoded = jwt.verify(token, JWT_SECRET) as { userId: string };
            userId = decoded.userId;
          } catch { /* 토큰 검증 실패 무시 */ }
        }
        
        // DB에 저장
        await storage.createClientError({
          severity,
          message: message?.substring(0, 2000) || "Unknown error",
          stack: stack?.substring(0, 5000),
          context: typeof context === 'object' ? JSON.stringify(context) : context,
          url,
          userId,
          userAgent: req.headers['user-agent'],
          ipAddress: (req.headers['x-forwarded-for'] as string)?.split(',')[0] || req.socket?.remoteAddress,
        });
        
        // 콘솔 로깅 (개발 환경)
        if (process.env.NODE_ENV !== 'production') {
          console.error(`[CLIENT ERROR] [${severity}] ${message?.substring(0, 200)}`);
        }
      }
      
      res.json({ received: true });
    } catch (err) {
      res.status(500).json({ message: "Error logging failed" });
    }
  });

  // ============================================
  // Meta API - 앱/관리자 공용 마스터 데이터
  // ============================================
  app.get("/api/meta/couriers", async (req, res) => {
    try {
      const settings = await storage.getAllCourierSettings();
      // 활성화된 택배사만 반환 (isActive=true)
      const courierList = settings.filter(s => s.isActive);
      
      const result = courierList.map(s => ({
        id: s.id,
        label: s.courierName,
        category: s.category || 'parcel',
        basePricePerBox: s.basePricePerBox || 0,
        etcPricePerBox: s.etcPricePerBox || 0,
        minDeliveryFee: s.minDeliveryFee || 0,
        minTotal: s.minTotal || 0,
        commissionRate: s.commissionRate || 0,
        urgentCommissionRate: s.urgentCommissionRate || 0,
        urgentSurchargeRate: s.urgentSurchargeRate || 0,
        isDefault: s.isDefault || false,
        active: true,
      }));
      res.json(result);
    } catch (err) {
      console.error("Error fetching couriers:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });


  // Get category pricing settings (기타택배, 냉탑전용)
  app.get("/api/meta/category-pricing", async (req, res) => {
    try {
      const settings = await storage.getAllSystemSettings();
      const settingsMap: Record<string, string> = {};
      settings.forEach(s => {
        settingsMap[s.settingKey] = s.settingValue;
      });

      res.json({
        other: {
          destinationPrice: parseInt(settingsMap["other_destination_price"]) || 1800,
          boxPrice: parseInt(settingsMap["other_box_price"]) || 1500,
          minDailyFee: parseInt(settingsMap["other_min_daily_fee"]) || 50000,
        },
        cold: {
          minDailyFee: parseInt(settingsMap["cold_min_daily_fee"]) || 100000,
        }
      });
    } catch (err) {
      console.error("Error fetching category pricing:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin alias for category pricing
  app.get("/api/admin/meta/category-pricing", adminAuth, async (req, res) => {
    try {
      const settings = await storage.getAllSystemSettings();
      const settingsMap: Record<string, string> = {};
      settings.forEach(s => {
        settingsMap[s.settingKey] = s.settingValue;
      });

      res.json({
        other: {
          destinationPrice: parseInt(settingsMap["other_destination_price"]) || 1800,
          boxPrice: parseInt(settingsMap["other_box_price"]) || 1500,
          minDailyFee: parseInt(settingsMap["other_min_daily_fee"]) || 50000,
        },
        cold: {
          minDailyFee: parseInt(settingsMap["cold_min_daily_fee"]) || 100000,
        }
      });
    } catch (err) {
      console.error("Error fetching category pricing:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  // Get carrier rate items by courier name (for helper work confirmation)
  app.get("/api/meta/couriers/:courierName/rate-items", async (req, res) => {
    try {
      const couriers = await storage.getAllCourierSettings();
      const courier = couriers.find(c => c.courierName === decodeURIComponent(req.params.courierName));
      
      if (!courier) {
        // Return default rate items
        return res.json([
          { id: 0, itemName: "배송", itemType: "delivery", unitPrice: 0, includeVat: false, displayOrder: 0 },
          { id: 0, itemName: "반품", itemType: "return", unitPrice: 0, includeVat: false, displayOrder: 1 },
          { id: 0, itemName: "수거", itemType: "pickup", unitPrice: 0, includeVat: false, displayOrder: 2 },
        ]);
      }
      
      const rateItems = await storage.getCarrierRateItemsByCourier(courier.id);
      
      // If no rate items configured, return defaults based on courier
      if (rateItems.length === 0) {
        return res.json([
          { id: 0, itemName: "배송", itemType: "delivery", unitPrice: 0, includeVat: false, displayOrder: 0 },
          { id: 0, itemName: "반품", itemType: "return", unitPrice: 0, includeVat: false, displayOrder: 1 },
          { id: 0, itemName: "수거", itemType: "pickup", unitPrice: 0, includeVat: false, displayOrder: 2 },
        ]);
      }
      
      res.json(rateItems);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get tiered pricing by courier name (for requester order registration)
  app.get("/api/meta/couriers/:courierName/tiered-pricing", async (req, res) => {
    try {
      const couriers = await storage.getAllCourierSettings();
      const courier = couriers.find(c => c.courierName === decodeURIComponent(req.params.courierName));
      
      if (!courier) {
        return res.json([]);
      }
      
      const tieredPricing = await storage.getCourierTieredPricingByCourier(courier.id);
      // Sort by minBoxCount ascending for easier lookup
      const sortedPricing = tieredPricing
        .filter(tp => tp.isActive)
        .sort((a, b) => a.minBoxCount - b.minBoxCount);
      
      res.json(sortedPricing);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/meta/vehicle-types", async (req, res) => {
    try {
      const settings = await storage.getAllVehicleTypeSettings();
      const result = settings
        .filter(s => s.isActive !== false)
        .map(s => ({
          id: s.id,
          label: s.vehicleTypeName,
          isDefault: s.isDefault || false,
          sortOrder: s.sortOrder,
          active: s.isActive !== false,
        }));
      res.json(result);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/meta/order-categories", async (req, res) => {
    try {
      const settings = await storage.getAllOrderCategorySettings();
      const result = settings
        .filter(s => s.isActive !== false)
        .map(s => ({
          id: s.id,
          label: s.categoryName,
          sortOrder: s.sortOrder,
          isAdminOnly: s.isAdminOnly || false,
          allowedCourierNames: s.allowedCourierNames ? JSON.parse(s.allowedCourierNames) : null,
          active: s.isActive !== false,
        }));
      res.json(result);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // Address Search API (Kakao Local API)
  // ============================================
  app.get("/api/address/search", async (req, res) => {
    try {
      const query = req.query.query as string;
      if (!query || query.length < 2) {
        return res.status(400).json({ message: "검색어를 2글자 이상 입력해주세요" });
      }

      const KAKAO_REST_API_KEY = process.env.KAKAO_REST_API_KEY;
      
      if (!KAKAO_REST_API_KEY) {
        // Fallback: 테스트 모드 - 기본 응답 반환
        console.log("KAKAO_REST_API_KEY not set, using fallback mode");
        return res.json({
          results: [
            {
              address: query,
              roadAddress: query,
              jibunAddress: "",
              buildingName: ""
            }
          ]
        });
      }

      // Kakao 주소 검색 API 호출
      console.log("[Address Search] Querying Kakao API for:", query);
      
      const response = await fetch(
        `https://dapi.kakao.com/v2/local/search/address.json?query=${encodeURIComponent(query)}&size=10`,
        {
          headers: {
            Authorization: `KakaoAK ${KAKAO_REST_API_KEY}`,
          },
        }
      );

      if (!response.ok) {
        const errorText = await response.text();
        console.error("[Address Search] Address API failed:", response.status, errorText);
        
        // Fallback: 키워드 검색 시도
        const keywordResponse = await fetch(
          `https://dapi.kakao.com/v2/local/search/keyword.json?query=${encodeURIComponent(query)}&size=10`,
          {
            headers: {
              Authorization: `KakaoAK ${KAKAO_REST_API_KEY}`,
            },
          }
        );
        
        if (!keywordResponse.ok) {
          const keywordErrorText = await keywordResponse.text();
          console.error("[Address Search] Keyword API also failed:", keywordResponse.status, keywordErrorText);
          
          // API 키 오류시 입력값을 결과로 반환 (fallback)
          return res.json({
            results: [
              {
                address: query,
                roadAddress: query,
                jibunAddress: "",
                buildingName: ""
              }
            ]
          });
        }
        
        const keywordData = await keywordResponse.json();
        const results = keywordData.documents?.map((doc: any) => ({
          address: doc.address_name || "",
          roadAddress: doc.road_address_name || doc.address_name || "",
          jibunAddress: doc.address_name || "",
          buildingName: doc.place_name || "",
        })) || [];
        
        return res.json({ results });
      }

      const data = await response.json();
      const results = data.documents?.map((doc: any) => ({
        address: doc.address?.address_name || doc.address_name || "",
        roadAddress: doc.road_address?.address_name || doc.address?.address_name || "",
        jibunAddress: doc.address?.address_name || "",
        buildingName: doc.road_address?.building_name || "",
      })) || [];

      // 결과가 없으면 키워드 검색 시도
      if (results.length === 0) {
        const keywordResponse = await fetch(
          `https://dapi.kakao.com/v2/local/search/keyword.json?query=${encodeURIComponent(query)}&size=10`,
          {
            headers: {
              Authorization: `KakaoAK ${KAKAO_REST_API_KEY}`,
            },
          }
        );
        
        if (keywordResponse.ok) {
          const keywordData = await keywordResponse.json();
          const keywordResults = keywordData.documents?.map((doc: any) => ({
            address: doc.address_name || "",
            roadAddress: doc.road_address_name || doc.address_name || "",
            jibunAddress: doc.address_name || "",
            buildingName: doc.place_name || "",
          })) || [];
          
          return res.json({ results: keywordResults });
        }
      }

      res.json({ results });
    } catch (err) {
      console.error("Address search error:", err);
      res.status(500).json({ message: "주소 검색 중 오류가 발생했습니다" });
    }
  });

  // Auth routes
  app.post(api.auth.signup.path, signupRateLimiter, async (req, res) => {
    try {
      const input = api.auth.signup.input.parse(req.body);
      
      // Check email duplicate
      const existingEmail = await storage.getUserByEmail(input.email);
      if (existingEmail) {
        return res.status(400).json({ message: "이미 사용중인 이메일입니다", field: "email" });
      }
      
      const hashedPassword = await bcrypt.hash(input.password, 10);
      
      // Generate permanent checkInToken for requesters
      const checkInToken = input.role === "requester" 
        ? randomBytes(32).toString("hex") 
        : undefined;
      
      const user = await storage.createUser({
        username: input.email, // Use email as username
        email: input.email,
        password: hashedPassword,
        name: input.name,
        address: input.address ?? undefined,
        birthDate: input.birthDate ?? undefined,
        phoneNumber: input.phoneNumber ?? undefined,
        role: input.role,
        checkInToken,
        identityVerified: input.identityVerified ?? false,
        identityCi: input.identityCi ?? undefined,
        identityDi: input.identityDi ?? undefined,
        identityVerifiedAt: input.identityVerified ? new Date() : undefined,
        kakaoId: input.kakaoId ?? undefined,
        naverId: input.naverId ?? undefined,
      });
      
      // 회원가입 시 개인코드 자동 생성 (요청자/헬퍼 모두)
      try {
        const personalCode = await getOrCreatePersonalCode(user.id);
        user.personalCode = personalCode;
      } catch (err) {
        console.error("Failed to generate personal code on signup:", err);
      }
      
      // Access token (1시간) 및 Refresh token (30일) 발급
      const accessToken = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: "1h" });
      const refreshTokenValue = randomBytes(32).toString("hex");
      const refreshExpiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30일
      const deviceInfo = req.headers["user-agent"] || undefined;
      await storage.createRefreshToken(user.id, refreshTokenValue, refreshExpiresAt, deviceInfo);
      
      res.status(201).json({ 
        user, 
        token: accessToken,
        refreshToken: refreshTokenValue,
        expiresIn: 3600
      });
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({
          message: err.errors[0].message,
          field: err.errors[0].path.join("."),
        });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post(api.auth.login.path, authRateLimiter, async (req, res) => {
    try {
      const input = api.auth.login.input.parse(req.body);
      const user = await storage.getUserByEmail(input.email);
      if (!user) {
        await logAuthEvent(req, "login_failed", "failure", {
          metadata: { reason: "user_not_found", email: input.email }
        });
        return res.status(404).json({ message: "비회원입니다. 회원가입을 진행해주세요." });
      }
      const validPassword = await bcrypt.compare(input.password, user.password);
      if (!validPassword) {
        await logAuthEvent(req, "login_failed", "failure", {
          userId: user.id,
          metadata: { reason: "invalid_password" }
        });
        return res.status(401).json({ message: "비밀번호가 올바르지 않습니다" });
      }
      
      // Access token (1시간) 및 Refresh token (30일) 발급
      const accessToken = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: "1h" });
      const refreshTokenValue = randomBytes(32).toString("hex");
      const refreshExpiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000); // 30일
      
      const deviceInfo = req.headers["user-agent"] || undefined;
      await storage.createRefreshToken(user.id, refreshTokenValue, refreshExpiresAt, deviceInfo);
      
      await logAuthEvent(req, "login", "success", { userId: user.id });
      res.json({ 
        user, 
        token: accessToken,
        refreshToken: refreshTokenValue,
        expiresIn: 3600 // 1시간 (초)
      });
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: "올바른 이메일 형식을 입력해주세요" });
      }
      console.error("Login error:", err);
      res.status(500).json({ message: "로그인 처리 중 오류가 발생했습니다" });
    }
  });

  // 토큰 갱신 API
  app.post("/api/auth/refresh", async (req, res) => {
    try {
      const { refreshToken } = req.body;
      
      if (!refreshToken || typeof refreshToken !== "string") {
        return res.status(400).json({ message: "Refresh token이 필요합니다" });
      }
      
      const storedToken = await storage.getRefreshToken(refreshToken);
      if (!storedToken) {
        return res.status(401).json({ message: "유효하지 않은 refresh token입니다" });
      }
      
      // 만료 확인
      if (new Date() > storedToken.expiresAt) {
        await storage.revokeRefreshToken(refreshToken);
        return res.status(401).json({ message: "Refresh token이 만료되었습니다" });
      }
      
      const user = await storage.getUser(storedToken.userId);
      if (!user) {
        await storage.revokeRefreshToken(refreshToken);
        return res.status(401).json({ message: "사용자를 찾을 수 없습니다" });
      }
      
      // 새 access token 발급
      const newAccessToken = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: "1h" });
      
      // Refresh token rotation (보안 강화)
      await storage.revokeRefreshToken(refreshToken);
      const newRefreshTokenValue = randomBytes(32).toString("hex");
      const newRefreshExpiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
      const deviceInfo = req.headers["user-agent"] || undefined;
      await storage.createRefreshToken(user.id, newRefreshTokenValue, newRefreshExpiresAt, deviceInfo);
      
      res.json({
        token: newAccessToken,
        refreshToken: newRefreshTokenValue,
        expiresIn: 3600
      });
    } catch (err) {
      console.error("Token refresh error:", err);
      res.status(500).json({ message: "토큰 갱신 중 오류가 발생했습니다" });
    }
  });

  // 로그아웃 (refresh token 폐기)
  app.post("/api/auth/logout", async (req, res) => {
    try {
      const { refreshToken } = req.body;
      
      if (refreshToken) {
        await storage.revokeRefreshToken(refreshToken);
      }
      
      res.json({ success: true });
    } catch (err) {
      console.error("Logout error:", err);
      res.status(500).json({ message: "로그아웃 처리 중 오류가 발생했습니다" });
    }
  });

  // 회원탈퇴 API
  app.post("/api/auth/withdraw", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const { password, reason } = req.body;

      // 비밀번호 확인 (소셜 로그인 사용자는 제외)
      if (user.passwordHash && password) {
        const bcrypt = require('bcryptjs');
        const isValid = await bcrypt.compare(password, user.passwordHash);
        if (!isValid) {
          return res.status(400).json({ message: "비밀번호가 일치하지 않습니다" });
        }
      }

      // 진행 중인 오더 확인
      const activeOrders = await storage.getOrdersByRequesterId(user.id);
      const allOrdersRaw = await storage.getOrders();
      const helperOrders = allOrdersRaw.filter(o => o.matchedHelperId === user.id);
      const allOrders = [...activeOrders, ...helperOrders];
      const hasActiveOrder = allOrders.some(o => 
        !['completed', 'closed', 'cancelled'].includes(o.status)
      );
      
      if (hasActiveOrder) {
        return res.status(400).json({ 
          message: "진행 중인 오더가 있어 탈퇴할 수 없습니다. 모든 오더를 완료하거나 취소 후 다시 시도해주세요." 
        });
      }

      // 미정산 확인
      const settlements = await storage.getSettlementsByHelper(user.id);
      const pendingSettlement = settlements.some(s => s.status === 'pending');
      if (pendingSettlement) {
        return res.status(400).json({ 
          message: "미정산 건이 있어 탈퇴할 수 없습니다. 정산 완료 후 다시 시도해주세요." 
        });
      }

      // 감사 로그 기록
      await storage.createAuditLog({
        userId: user.id,
        action: 'USER_WITHDRAW',
        targetType: 'user',
        targetId: user.id,
        details: { reason: reason || '사유 미입력', email: user.email },
        ipAddress: req.ip || 'unknown',
      });

      // 사용자 비활성화 (소프트 삭제)
      await storage.updateUser(user.id, {
        isActive: false,
        deletedAt: new Date(),
        email: `deleted_${Date.now()}_${user.email}`, // 이메일 중복 방지
      });

      // 모든 리프레시 토큰 무효화
      await storage.revokeAllUserTokens(user.id);

      res.json({ success: true, message: "회원탈퇴가 완료되었습니다" });
    } catch (err) {
      console.error("Withdraw error:", err);
      res.status(500).json({ message: "회원탈퇴 처리 중 오류가 발생했습니다" });
    }
  });

  app.get(api.auth.me.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    const user = req.user!;
    
    // 개인코드가 없으면 자동 생성 (요청자/헬퍼 모두)
    if (!user.personalCode) {
      try {
        const personalCode = await getOrCreatePersonalCode(user.id);
        user.personalCode = personalCode;
      } catch (err) {
        console.error("Failed to generate personal code:", err);
      }
    }
    
    res.json({ user });
  });

  // Update user role (after signup)
  const updateRoleSchema = z.object({
    role: z.enum(["helper", "requester"]),
  });
  
  app.post("/api/auth/update-role", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;

      const parseResult = updateRoleSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({ message: "유효하지 않은 역할입니다" });
      }
      
      const { role } = parseResult.data;

      // Generate checkInToken for requesters
      const checkInToken = role === "requester" 
        ? randomBytes(32).toString("hex") 
        : undefined;

      // onboardingStatus 로직:
      // - 요청자로 전환/유지: approved (요청자는 온보딩 불필요)
      // - 헬퍼로 전환 (요청자→헬퍼): pending (헬퍼 온보딩 필요)
      // - 헬퍼 유지 (헬퍼→헬퍼): 기존 상태 유지
      let onboardingStatus: string;
      if (role === "requester") {
        // 요청자는 항상 approved
        onboardingStatus = "approved";
      } else if (user.role === "helper") {
        // 이미 헬퍼인 경우 기존 상태 유지
        onboardingStatus = user.onboardingStatus || "pending";
      } else {
        // 요청자에서 헬퍼로 전환 - 헬퍼 온보딩 필요
        onboardingStatus = "pending";
      }

      // 개인코드가 없으면 자동 생성 (요청자/헬퍼 모두)
      let personalCode: string | undefined;
      if (!user.personalCode) {
        try {
          personalCode = await getOrCreatePersonalCode(user.id);
        } catch (err) {
          console.error("Failed to generate personal code:", err);
        }
      }

      const updatedUser = await storage.updateUser(user.id, { 
        role,
        checkInToken,
        onboardingStatus,
        ...(personalCode && { personalCode }),
      });

      res.json({ user: updatedUser });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Check email availability
  app.post(api.auth.checkEmail.path, async (req, res) => {
    try {
      const input = api.auth.checkEmail.input.parse(req.body);
      const existing = await storage.getUserByEmail(input.email);
      if (existing) {
        res.json({ available: false, message: "이미 사용중인 이메일입니다" });
      } else {
        res.json({ available: true, message: "사용 가능한 이메일입니다" });
      }
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ available: false, message: "올바른 이메일 형식을 입력해주세요" });
      }
      console.error("Email check error:", err);
      res.status(500).json({ available: false, message: "이메일 확인 중 오류가 발생했습니다" });
    }
  });

  // Find email by phone number and name
  app.post("/api/auth/find-email", validateBody(authSchemas.findEmail), async (req, res) => {
    try {
      const { phoneNumber, name } = req.body;
      
      const users = await storage.getAllUsers();
      const user = users.find(u => 
        u.phoneNumber === phoneNumber && 
        u.name === name && 
        !u.isHqStaff
      );
      
      if (!user) {
        return res.status(404).json({ message: "일치하는 계정을 찾을 수 없습니다" });
      }
      
      // Mask email for security (show first 3 chars + ***@domain)
      const email = user.email;
      const [localPart, domain] = email.split("@");
      const maskedLocal = localPart.length > 3 
        ? localPart.substring(0, 3) + "***" 
        : localPart.substring(0, 1) + "***";
      const maskedEmail = `${maskedLocal}@${domain}`;
      
      res.json({ 
        email: maskedEmail,
        createdAt: user.createdAt
      });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Request password reset (sends temporary password)
  app.post("/api/auth/reset-password", passwordResetRateLimiter, validateBody(authSchemas.resetPassword), async (req, res) => {
    try {
      const { email, phoneNumber, name } = req.body;
      
      const user = await storage.getUserByEmail(email);
      if (!user || user.phoneNumber !== phoneNumber || user.name !== name) {
        return res.status(404).json({ message: "일치하는 계정을 찾을 수 없습니다" });
      }
      
      if (user.isHqStaff) {
        return res.status(403).json({ message: "관리자 계정은 별도의 절차가 필요합니다" });
      }
      
      // 개발 환경에서는 고정 테스트 임시 비밀번호 사용
      const isTestMode = process.env.NODE_ENV !== "production";
      const tempPassword = isTestMode ? "Test1234!" : `Temp${Math.random().toString(36).slice(-6)}!`;
      const hashedPassword = await bcrypt.hash(tempPassword, 10);
      
      await storage.updateUser(user.id, { 
        password: hashedPassword,
        mustChangePassword: true
      });
      
      // SMS 발송 (테스트 모드에서는 실제 발송 안함)
      if (!isTestMode) {
        const smsResult = await smsService.sendPasswordReset(user.phoneNumber!, tempPassword);
        if (!smsResult.success) {
          console.error(`[비밀번호 재설정 SMS 실패] ${smsResult.error}`);
        }
      } else {
        console.log(`[테스트 모드] 임시 비밀번호: ${tempPassword} → ${user.phoneNumber}`);
      }
      
      res.json({ 
        success: true, 
        message: isTestMode ? `[테스트] 임시 비밀번호: ${tempPassword}` : "임시 비밀번호가 등록된 전화번호로 발송되었습니다",
        ...(isTestMode && { devPassword: tempPassword })
      });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 회원가입용 휴대폰 인증번호 발송 (토큰 불필요)
  app.post("/api/auth/send-signup-code", signupRateLimiter, async (req, res) => {
    try {
      const { phoneNumber } = req.body;
      
      if (!phoneNumber || typeof phoneNumber !== 'string' || phoneNumber.length < 10) {
        return res.status(400).json({ message: "올바른 전화번호를 입력해주세요" });
      }
      
      // IP 기반 레이트 리밋
      const rawIp = req.ip || req.socket?.remoteAddress || 'unknown';
      const ipAddress = rawIp.replace(/^::ffff:/, '');
      
      // 같은 IP에서 1분에 3회 제한
      const recentByIp = await storage.getRecentPhoneVerificationCodesByIp(ipAddress, 60);
      if (recentByIp.length >= 3) {
        return res.status(429).json({ message: "너무 많은 요청입니다. 1분 후 다시 시도해주세요." });
      }
      
      // 같은 전화번호로 1분에 3회 제한
      const recentByPhone = await storage.getRecentPhoneVerificationCodes(phoneNumber, 60);
      if (recentByPhone.length >= 3) {
        return res.status(429).json({ message: "이 번호로 너무 많은 요청이 있습니다. 1분 후 다시 시도해주세요." });
      }
      
      // 개발 환경에서는 고정 테스트 인증코드 사용
      const isTestMode = process.env.NODE_ENV !== "production";
      const code = isTestMode ? "123456" : Math.floor(100000 + Math.random() * 900000).toString();
      const expiresAt = new Date(Date.now() + 3 * 60 * 1000); // 3분 후 만료
      
      // DB에 인증코드 저장
      await storage.createPhoneVerificationCode({
        phoneNumber,
        code,
        userId: null,
        purpose: "signup_verify",
        expiresAt,
        ipAddress,
        isUsed: false,
        attempts: 0,
      });
      
      // SMS 발송 (테스트 모드에서는 실제 발송 안함)
      if (!isTestMode) {
        const smsResult = await smsService.sendVerificationCode(phoneNumber, code);
        if (!smsResult.success) {
          console.error(`[회원가입 인증코드 SMS 실패] ${smsResult.error}`);
        }
      } else {
        console.log(`[테스트 모드] 인증번호: ${code} → ${phoneNumber}`);
      }
      
      res.json({ 
        success: true, 
        message: isTestMode ? `[테스트] 인증번호: ${code}` : "인증번호가 발송되었습니다",
        expiresIn: 180,
        ...(isTestMode && { devCode: code })
      });
    } catch (err) {
      console.error("회원가입 인증코드 발송 오류:", err);
      res.status(500).json({ message: "인증코드 발송에 실패했습니다" });
    }
  });

  // 회원가입용 휴대폰 인증번호 검증 (토큰 불필요)
  app.post("/api/auth/verify-signup-code", signupRateLimiter, async (req, res) => {
    try {
      const { phoneNumber, code } = req.body;
      
      if (!phoneNumber || !code) {
        return res.status(400).json({ message: "전화번호와 인증번호를 입력해주세요" });
      }
      
      // DB에서 유효한 인증코드 조회
      const verificationCode = await storage.getValidPhoneVerificationCode(phoneNumber, "signup_verify");
      
      if (!verificationCode) {
        return res.status(400).json({ message: "인증번호가 만료되었거나 존재하지 않습니다. 다시 요청해주세요." });
      }
      
      // 시도 횟수 체크 (최대 5회)
      const attempts = verificationCode.attempts ?? 0;
      if (attempts >= 5) {
        await storage.markPhoneVerificationCodeUsed(verificationCode.id);
        return res.status(400).json({ message: "인증 시도 횟수를 초과했습니다. 새로운 인증번호를 요청해주세요." });
      }
      
      // 시도 횟수 증가
      await storage.incrementPhoneVerificationAttempts(verificationCode.id);
      
      // 인증코드 검증
      if (verificationCode.code !== code) {
        const remaining = 5 - (attempts + 1);
        return res.status(400).json({ 
          message: `인증번호가 올바르지 않습니다. (남은 시도: ${remaining}회)` 
        });
      }
      
      // 인증 성공: 코드 사용 처리
      await storage.markPhoneVerificationCodeUsed(verificationCode.id);
      
      res.json({ success: true, message: "인증이 완료되었습니다" });
    } catch (err) {
      console.error("회원가입 인증번호 검증 오류:", err);
      res.status(500).json({ message: "인증번호 검증에 실패했습니다" });
    }
  });

  // 휴대폰 인증번호 발송
  app.post("/api/auth/send-phone-code", strictRateLimiter, requireAuth, validateBody(authSchemas.sendPhoneCode), async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const { phoneNumber } = req.body;
      
      // IP 및 전화번호 기반 레이트 리밋 (모든 요청에 적용)
      // 정규화된 IP 주소 추출 (스푸핑 방지: req.ip 우선 사용)
      const rawIp = req.ip || req.socket?.remoteAddress || 'unknown';
      // IPv6 mapped IPv4 정규화 (::ffff:127.0.0.1 -> 127.0.0.1)
      const ipAddress = rawIp.replace(/^::ffff:/, '');
      
      // 같은 IP에서 1분에 3회 제한 (모든 IP에 적용)
      const recentByIp = await storage.getRecentPhoneVerificationCodesByIp(ipAddress, 60);
      if (recentByIp.length >= 3) {
        return res.status(429).json({ message: "너무 많은 요청입니다. 1분 후 다시 시도해주세요." });
      }
      
      // 같은 전화번호로 1분에 3회 제한
      const recentByPhone = await storage.getRecentPhoneVerificationCodes(phoneNumber, 60);
      if (recentByPhone.length >= 3) {
        return res.status(429).json({ message: "이 번호로 너무 많은 요청이 있습니다. 1분 후 다시 시도해주세요." });
      }
      
      // 개발 환경에서는 고정 테스트 인증코드 사용
      const isTestMode = process.env.NODE_ENV !== "production";
      const code = isTestMode ? "123456" : Math.floor(100000 + Math.random() * 900000).toString();
      const expiresAt = new Date(Date.now() + 3 * 60 * 1000); // 3분 후 만료
      
      // DB에 인증코드 저장
      await storage.createPhoneVerificationCode({
        phoneNumber,
        code,
        userId,
        purpose: "phone_verify",
        expiresAt,
        ipAddress,
        isUsed: false,
        attempts: 0,
      });
      
      // SMS 발송 (테스트 모드에서는 실제 발송 안함)
      if (!isTestMode) {
        const smsResult = await smsService.sendVerificationCode(phoneNumber, code);
        if (!smsResult.success) {
          console.error(`[인증코드 SMS 실패] ${smsResult.error}`);
        }
      } else {
        console.log(`[테스트 모드] 인증번호: ${code} → ${phoneNumber}`);
      }
      
      res.json({ 
        success: true, 
        message: isTestMode ? `[테스트] 인증번호: ${code}` : "인증번호가 발송되었습니다",
        expiresIn: 180,
        ...(isTestMode && { devCode: code })
      });
    } catch (err) {
      console.error("인증코드 발송 오류:", err);
      res.status(500).json({ message: "인증코드 발송에 실패했습니다" });
    }
  });

  // 휴대폰 인증번호 검증
  app.post("/api/auth/verify-phone", requireAuth, validateBody(authSchemas.verifyPhone), async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const { phoneNumber, code } = req.body;
      
      // DB에서 유효한 인증코드 조회
      const verificationCode = await storage.getValidPhoneVerificationCode(phoneNumber, "phone_verify");
      
      if (!verificationCode) {
        return res.status(400).json({ message: "인증번호가 만료되었거나 존재하지 않습니다. 다시 요청해주세요." });
      }
      
      // 시도 횟수 체크 (최대 5회)
      const attempts = verificationCode.attempts ?? 0;
      if (attempts >= 5) {
        await storage.markPhoneVerificationCodeUsed(verificationCode.id);
        return res.status(400).json({ message: "인증 시도 횟수를 초과했습니다. 새로운 인증번호를 요청해주세요." });
      }
      
      // 시도 횟수 증가
      await storage.incrementPhoneVerificationAttempts(verificationCode.id);
      
      // 인증코드 검증
      if (verificationCode.code !== code) {
        const remaining = 5 - (attempts + 1);
        return res.status(400).json({ 
          message: `인증번호가 올바르지 않습니다. (남은 시도: ${remaining}회)` 
        });
      }
      
      // 인증 성공: 코드 사용 처리
      await storage.markPhoneVerificationCodeUsed(verificationCode.id);
      
      // 사용자 전화번호 업데이트
      await storage.updateUser(userId, { phoneNumber });
      
      res.json({ success: true, message: "인증이 완료되었습니다" });
    } catch (err) {
      console.error("인증번호 검증 오류:", err);
      res.status(500).json({ message: "인증번호 검증에 실패했습니다" });
    }
  });

  // PortOne 본인인증 ID 생성 (SDK 호출 전에 먼저 호출해야 함)
  app.post("/api/auth/create-identity-verification", async (req, res) => {
    try {
      const PORTONE_API_SECRET = process.env.PORTONE_API_SECRET;
      const identityVerificationId = `identity-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      
      // 운영 환경에서 API 시크릿 미설정 시 에러 반환
      if (!PORTONE_API_SECRET) {
        if (isProduction) {
          console.error("[PortOne] PORTONE_API_SECRET not configured in production");
          return res.status(503).json({ message: "본인인증 서비스를 이용할 수 없습니다. 관리자에게 문의하세요." });
        }
        console.log("[PortOne 테스트 모드] 생성된 ID:", identityVerificationId);
        return res.json({ identityVerificationId, testMode: true });
      }

      // PortOne V2 API로 본인인증 ID 사전 생성
      const createResponse = await fetch(
        "https://api.portone.io/identity-verifications",
        {
          method: "POST",
          headers: {
            "Authorization": `PortOne ${PORTONE_API_SECRET}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            identityVerificationId,
          }),
        }
      );

      if (!createResponse.ok) {
        const error = await createResponse.json();
        console.error("PortOne ID 생성 실패:", error);
        // PortOne API가 ID 사전 생성을 요구하지 않는 경우도 있으므로 ID 반환
        return res.json({ identityVerificationId, preCreated: false });
      }

      console.log("[PortOne] 본인인증 ID 생성 완료:", identityVerificationId);
      res.json({ identityVerificationId, preCreated: true });
    } catch (err) {
      console.error("본인인증 ID 생성 오류:", err);
      res.status(500).json({ message: "본인인증 ID 생성 실패" });
    }
  });

  // PortOne 본인인증 검증 (회원가입 전)
  app.post("/api/auth/verify-identity", async (req, res) => {
    try {
      const { identityVerificationId } = req.body;
      
      if (!identityVerificationId) {
        await logAuthEvent(req, "identity_verification_failed", "failure", {
          provider: "portone",
          metadata: { reason: "missing_verification_id" }
        });
        return res.status(400).json({ message: "인증 정보가 필요합니다" });
      }

      // 요청 ID 형식 검증 (위변조 방지)
      if (typeof identityVerificationId !== "string" || 
          !identityVerificationId.startsWith("identity-") ||
          identityVerificationId.length > 100) {
        await logAuthEvent(req, "identity_verification_failed", "failure", {
          provider: "portone",
          metadata: { reason: "invalid_verification_id_format" }
        });
        return res.status(400).json({ message: "유효하지 않은 인증 정보입니다" });
      }

      const PORTONE_API_SECRET = process.env.PORTONE_API_SECRET;
      
      // 운영 환경에서 API 시크릿 미설정 시 에러 반환
      if (!PORTONE_API_SECRET) {
        if (isProduction) {
          console.error("[PortOne] PORTONE_API_SECRET not configured in production");
          return res.status(503).json({ message: "본인인증 서비스를 이용할 수 없습니다. 관리자에게 문의하세요." });
        }
        console.log("[PortOne 테스트 모드] identityVerificationId:", identityVerificationId);
        
        // 테스트용 고정 DI 생성 (동일 세션에서 중복 확인 가능)
        const testDi = `test_di_${identityVerificationId}`;
        
        // 중복 가입 확인 (테스트 모드에서도 DI 확인)
        const existingUser = await storage.getUserByDi(testDi);
        if (existingUser) {
          await logAuthEvent(req, "identity_verification_failed", "failure", {
            provider: "portone",
            metadata: { reason: "duplicate_di", testMode: true }
          });
          return res.status(409).json({ message: "이미 가입된 계정이 있습니다" });
        }
        
        await logAuthEvent(req, "identity_verification", "success", {
          provider: "portone",
          metadata: { testMode: true, di: testDi }
        });
        
        // 테스트용 mock 데이터 반환
        return res.json({
          success: true,
          verified: true,
          customer: {
            name: "테스트사용자",
            phoneNumber: "01012345678",
            birthDate: "1990-01-01",
            gender: "MALE",
            ci: `test_ci_${identityVerificationId}`,
            di: testDi,
          },
          message: "테스트 모드: 본인인증이 완료되었습니다"
        });
      }

      // 실제 PortOne API 호출
      const verificationResponse = await fetch(
        `https://api.portone.io/identity-verifications/${encodeURIComponent(identityVerificationId)}`,
        {
          headers: {
            Authorization: `PortOne ${PORTONE_API_SECRET}`,
          },
        }
      );

      if (!verificationResponse.ok) {
        const error = await verificationResponse.json();
        console.error("PortOne verification error:", error);
        await logAuthEvent(req, "identity_verification_failed", "failure", {
          provider: "portone",
          metadata: { reason: "api_error", statusCode: verificationResponse.status }
        });
        return res.status(400).json({ message: "본인인증 정보 조회에 실패했습니다" });
      }

      const identityVerification = await verificationResponse.json();

      // 응답 검증 강화: 필수 필드 확인
      if (!identityVerification || typeof identityVerification !== "object") {
        await logAuthEvent(req, "identity_verification_failed", "failure", {
          provider: "portone",
          metadata: { reason: "invalid_response_format" }
        });
        return res.status(400).json({ message: "본인인증 응답이 올바르지 않습니다" });
      }

      if (identityVerification.status !== "VERIFIED") {
        await logAuthEvent(req, "identity_verification_failed", "failure", {
          provider: "portone",
          metadata: { reason: "not_verified", status: identityVerification.status }
        });
        return res.status(400).json({ message: "본인인증이 완료되지 않았습니다" });
      }

      // verifiedCustomer 필수 필드 검증
      const verifiedCustomer = identityVerification.verifiedCustomer;
      if (!verifiedCustomer || !verifiedCustomer.di || !verifiedCustomer.name) {
        await logAuthEvent(req, "identity_verification_failed", "failure", {
          provider: "portone",
          metadata: { reason: "missing_customer_data" }
        });
        return res.status(400).json({ message: "본인인증 정보가 불완전합니다" });
      }

      const { ci, di, name, gender, birthDate, phoneNumber } = verifiedCustomer;

      // 중복 가입 확인 (DI 기준)
      if (di) {
        const existingUser = await storage.getUserByDi(di);
        if (existingUser) {
          await logAuthEvent(req, "identity_verification_failed", "failure", {
            provider: "portone",
            metadata: { reason: "duplicate_di" }
          });
          return res.status(409).json({ message: "이미 가입된 계정이 있습니다" });
        }
      }

      // 성공 로그 (민감정보 제외)
      await logAuthEvent(req, "identity_verification", "success", {
        provider: "portone",
        metadata: { 
          hasCI: !!ci,
          hasDI: !!di,
          hasPhone: !!phoneNumber,
        }
      });

      res.json({
        success: true,
        verified: true,
        customer: {
          name,
          phoneNumber,
          birthDate,
          gender,
          ci,
          di,
        },
        message: "본인인증이 완료되었습니다"
      });
    } catch (err) {
      console.error("Identity verification error:", err);
      await logAuthEvent(req, "identity_verification_failed", "failure", {
        provider: "portone",
        metadata: { error: (err as Error).message }
      });
      res.status(500).json({ message: "본인인증 처리 중 오류가 발생했습니다" });
    }
  });

  // ============================================
  // 결제 인텐트 API (네이티브 앱용 보안 결제)
  // ============================================

  // 결제 인텐트 생성 (토큰을 WebView에 노출하지 않음)
  app.post("/api/payments/intent", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { orderId, contractId, amount, paymentType, orderTitle } = req.body;
      const userId = req.user?.id;

      if (!userId) {
        return res.status(401).json({ message: "로그인이 필요합니다" });
      }

      if (!amount || amount <= 0) {
        return res.status(400).json({ message: "유효한 결제 금액이 필요합니다" });
      }

      // 결제 ID 생성 (유니크)
      const paymentId = `pay_${paymentType || 'payment'}_${orderId || contractId || 'direct'}_${Date.now()}_${randomBytes(4).toString('hex')}`;

      const PORTONE_API_SECRET = process.env.PORTONE_API_SECRET;
      const PORTONE_STORE_ID = process.env.PORTONE_STORE_ID;
      const baseUrl = process.env.OAUTH_BASE_URL || `https://${process.env.REPL_SLUG}.${process.env.REPL_OWNER}.repl.co`;

      // 운영 환경에서는 PortOne API 필수
      if (isProduction && !PORTONE_API_SECRET) {
        console.error("[Payment Intent] PORTONE_API_SECRET not configured in production");
        return res.status(503).json({ message: "결제 서비스를 이용할 수 없습니다. 관리자에게 문의하세요." });
      }

      // PortOne V2 결제 URL 생성
      if (PORTONE_API_SECRET && PORTONE_STORE_ID) {
        try {
          // PortOne checkout URL 형식으로 반환
          // 실제로는 PortOne SDK를 통해 결제 페이지를 로드해야 함
          const checkoutParams = new URLSearchParams({
            storeId: PORTONE_STORE_ID,
            paymentId: paymentId,
            orderName: orderTitle || `헬프미 ${paymentType === 'deposit' ? '계약금' : '잔금'} 결제`,
            totalAmount: String(amount),
            currency: 'KRW',
            payMethod: 'CARD',
            redirectUrl: `${baseUrl}/payment/callback?status=success`,
            failUrl: `${baseUrl}/payment/callback?status=fail`,
          });

          // 결제 정보를 DB에 저장 (필수)
          await storage.createPayment({
            payerId: userId,
            provider: 'portone',
            providerPaymentId: paymentId,
            amount,
            currency: 'KRW',
            paymentType: paymentType || 'deposit',
            status: 'initiated',
            orderId: orderId ? parseInt(orderId) : undefined,
            contractId: contractId ? parseInt(contractId) : undefined,
          });
          console.log(`[Payment Intent] Payment record created: ${paymentId}`);

          // 서버 측 결제 페이지 URL 반환
          const paymentUrl = `${baseUrl}/payment/checkout?${checkoutParams.toString()}`;

          return res.json({
            success: true,
            paymentId,
            paymentUrl,
            expiresAt: new Date(Date.now() + 30 * 60 * 1000).toISOString(),
          });
        } catch (err) {
          console.error("[Payment Intent] PortOne error:", err);
          return res.status(500).json({ message: "결제 URL 생성에 실패했습니다" });
        }
      }

      // 개발 환경 테스트 모드
      const testPaymentUrl = `${baseUrl}/payment/test-checkout?paymentId=${paymentId}&amount=${amount}&orderTitle=${encodeURIComponent(orderTitle || '테스트 결제')}`;

      res.json({
        success: true,
        paymentId,
        paymentUrl: testPaymentUrl,
        expiresAt: new Date(Date.now() + 30 * 60 * 1000).toISOString(),
        isTestMode: true,
      });
    } catch (err) {
      console.error("[Payment Intent] Error:", err);
      res.status(500).json({ message: "결제 초기화에 실패했습니다" });
    }
  });

  // 결제 상태 확인
  app.get("/api/payments/:paymentId/status", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { paymentId } = req.params;
      
      // DB에서 결제 상태 조회
      const payment = await storage.getPaymentByProviderPaymentId(paymentId);
      
      if (!payment) {
        return res.status(404).json({ 
          paymentId,
          status: 'not_found',
          message: '결제 정보를 찾을 수 없습니다'
        });
      }
      
      res.json({
        paymentId,
        status: payment.status || 'initiated',
        amount: payment.amount,
        paymentType: payment.paymentType,
        paidAt: payment.paidAt,
        provider: payment.provider,
      });
    } catch (err) {
      console.error("[Payment Status] Error:", err);
      res.status(500).json({ message: "결제 상태 조회에 실패했습니다" });
    }
  });

  // 결제 완료 확정 (WebView 성공 후 서버 검증)
  app.post("/api/payments/:paymentId/verify", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { paymentId } = req.params;
      const userId = req.user?.id;
      
      if (!userId) {
        return res.status(401).json({ verified: false, message: "로그인이 필요합니다" });
      }
      
      const payment = await storage.getPaymentByProviderPaymentId(paymentId);
      
      if (!payment) {
        return res.status(404).json({ verified: false, message: '결제 정보를 찾을 수 없습니다' });
      }

      if (payment.payerId !== userId) {
        return res.status(403).json({ verified: false, message: '권한이 없습니다' });
      }

      if (payment.status === 'captured' || payment.status === 'completed') {
        return res.json({
          verified: true,
          status: payment.status,
          amount: payment.amount,
          paymentType: payment.paymentType,
          paidAt: payment.paidAt,
        });
      }

      const PORTONE_API_SECRET = process.env.PORTONE_API_SECRET;
      if (PORTONE_API_SECRET && payment.provider === 'portone') {
        try {
          const portoneResponse = await fetch(
            `https://api.portone.io/payments/${paymentId}`,
            { headers: { 'Authorization': `PortOne ${PORTONE_API_SECRET}` } }
          );
          
          if (portoneResponse.ok) {
            const portoneData = await portoneResponse.json();
            
            if (portoneData.status === 'PAID') {
              await storage.updatePaymentStatus(payment.id, 'captured', {
                paidAt: new Date(),
                providerPaymentId: portoneData.paymentId,
              });
              
              if (payment.contractId) {
                const contract = await storage.getContract(payment.contractId);
                if (contract && payment.paymentType === 'deposit') {
                  await storage.updateContract(payment.contractId, {
                    status: 'active',
                    depositPaidAt: new Date(),
                    contactSharedAt: new Date()
                  });
                  if (contract.orderId) {
                    await storage.updateOrder(contract.orderId, { status: 'scheduled' });
                  }

                  // 알림톡 연락처 전송
                  try {
                    const requester = await storage.getUser(contract.requesterId);
                    const helper = await storage.getUser(contract.helperId);
                    const order = await storage.getOrder(contract.orderId);

                    if (requester && helper && order) {
                      // 헬퍼에게 연락처 전송
                      if (helper.phoneNumber) {
                        await smsService.sendCustomMessage(
                          helper.phoneNumber,
                          `[헬프미] ${order.companyName} 계약금 입금 확인\n` +
                          `요청자: ${requester.name}\n` +
                          `연락처: ${requester.phoneNumber || '미등록'}\n` +
                          `작업일: ${order.scheduledDate || '미정'}`
                        );
                      }

                      // 요청자에게 연락처 전송
                      if (requester.phoneNumber) {
                        await smsService.sendCustomMessage(
                          requester.phoneNumber,
                          `[헬프미] 계약금 입금 확인\n` +
                          `배정 헬퍼: ${helper.name}\n` +
                          `연락처: ${helper.phoneNumber || '미등록'}\n` +
                          `작업일: ${order.scheduledDate || '미정'}`
                        );
                      }
                    }
                  } catch (smsError) {
                    console.error('[Payment] Failed to send contact SMS:', smsError);
                  }
                } else if (contract && payment.paymentType === 'balance') {
                  await storage.updateContract(payment.contractId, { balancePaidAt: new Date() });
                }
              }
              
              console.log(`[Payment Verify] Payment ${paymentId} verified as PAID via PortOne`);
              return res.json({ verified: true, status: 'captured', amount: payment.amount, paymentType: payment.paymentType, paidAt: new Date() });
            } else if (portoneData.status === 'FAILED' || portoneData.status === 'CANCELLED') {
              await storage.updatePaymentStatus(payment.id, 'failed');
              return res.json({ verified: false, status: 'failed', message: '결제가 실패하거나 취소되었습니다' });
            } else {
              return res.json({ verified: false, status: payment.status, message: '결제가 아직 처리 중입니다' });
            }
          }
        } catch (portoneError) {
          console.error("[Payment Verify] PortOne API error:", portoneError);
        }
      }

      if (!isProduction && payment.status === 'initiated') {
        await storage.updatePaymentStatus(payment.id, 'captured', { paidAt: new Date() });

        if (payment.contractId) {
          const contract = await storage.getContract(payment.contractId);
          if (contract && payment.paymentType === 'deposit') {
            await storage.updateContract(payment.contractId, {
              status: 'active',
              depositPaidAt: new Date(),
              contactSharedAt: new Date()
            });
            if (contract.orderId) {
              await storage.updateOrder(contract.orderId, { status: 'scheduled' });
            }

            // 알림톡 연락처 전송 (테스트 모드)
            try {
              const requester = await storage.getUser(contract.requesterId);
              const helper = await storage.getUser(contract.helperId);
              const order = await storage.getOrder(contract.orderId);

              if (requester && helper && order) {
                // 헬퍼에게 연락처 전송
                if (helper.phoneNumber) {
                  await smsService.sendCustomMessage(
                    helper.phoneNumber,
                    `[헬프미] ${order.companyName} 계약금 입금 확인\n` +
                    `요청자: ${requester.name}\n` +
                    `연락처: ${requester.phoneNumber || '미등록'}\n` +
                    `작업일: ${order.scheduledDate || '미정'}`
                  );
                }

                // 요청자에게 연락처 전송
                if (requester.phoneNumber) {
                  await smsService.sendCustomMessage(
                    requester.phoneNumber,
                    `[헬프미] 계약금 입금 확인\n` +
                    `배정 헬퍼: ${helper.name}\n` +
                    `연락처: ${helper.phoneNumber || '미등록'}\n` +
                    `작업일: ${order.scheduledDate || '미정'}`
                  );
                }
              }
            } catch (smsError) {
              console.error('[Payment] Failed to send contact SMS (test mode):', smsError);
            }
          }
        }

        console.log(`[Payment Verify] Test mode - Payment ${paymentId} marked as captured`);
        return res.json({ verified: true, status: 'captured', amount: payment.amount, paymentType: payment.paymentType, paidAt: new Date(), isTestMode: true });
      }
      
      res.json({
        verified: payment.status === 'captured' || payment.status === 'completed',
        status: payment.status,
        amount: payment.amount,
        paymentType: payment.paymentType,
        paidAt: payment.paidAt,
      });
    } catch (err) {
      console.error("[Payment Verify] Error:", err);
      res.status(500).json({ verified: false, message: "결제 검증에 실패했습니다" });
    }
  });

  // ============================================
  // 가상계좌 결제 API
  // ============================================

  // 가상계좌 발급 요청 (계약금)
  app.post("/api/payment/virtual-account/request", async (req, res) => {
    try {
      const { orderId, amount } = req.body;
      
      if (!orderId || !amount) {
        return res.status(400).json({ message: "주문 ID와 금액이 필요합니다" });
      }

      const userId = (req as any).user?.id;
      if (!userId) {
        return res.status(401).json({ message: "로그인이 필요합니다" });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "주문을 찾을 수 없습니다" });
      }

      // 기존 가상계좌가 있는지 확인
      const existingAccount = await storage.getVirtualAccountByOrder(orderId);
      if (existingAccount && existingAccount.status === "pending") {
        return res.json({
          success: true,
          virtualAccount: existingAccount,
          message: "기존 가상계좌를 사용해주세요"
        });
      }

      const PORTONE_API_SECRET = process.env.PORTONE_API_SECRET;
      const paymentId = `payment_${orderId}_${Date.now()}`;
      
      // PortOne API 사용 가능한 경우
      if (PORTONE_API_SECRET) {
        // PortOne V2 가상계좌 결제 요청
        const paymentResponse = await fetch("https://api.portone.io/payments/" + paymentId + "/virtual-account", {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `PortOne ${PORTONE_API_SECRET}`,
          },
          body: JSON.stringify({
            storeId: process.env.PORTONE_STORE_ID,
            channelKey: process.env.PORTONE_CHANNEL_KEY,
            orderName: `오더 #${orderId} 계약금`,
            totalAmount: amount,
            currency: "KRW",
            customer: {
              name: order.companyName || "의뢰인",
            },
            virtualAccount: {
              bank: "SHINHAN", // 기본 은행 (설정 가능)
              accountExpiry: {
                dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(), // 24시간 후 만료
              },
            },
          }),
        });

        const paymentData = await paymentResponse.json() as any;
        
        if (paymentData.virtualAccount) {
          const virtualAccount = await storage.createVirtualAccount({
            orderId,
            userId,
            paymentId,
            bankCode: paymentData.virtualAccount.bank,
            bankName: getBankName(paymentData.virtualAccount.bank),
            accountNumber: paymentData.virtualAccount.accountNumber,
            accountHolder: paymentData.virtualAccount.accountHolder || "헬프미",
            amount,
            dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000),
            status: "pending",
          });

          return res.json({
            success: true,
            virtualAccount,
            message: "가상계좌가 발급되었습니다"
          });
        }
      }
      
      // 운영 환경에서는 PortOne API 필수
      if (isProduction) {
        console.error("[Virtual Account] PORTONE_API_SECRET not configured in production");
        return res.status(503).json({ message: "결제 서비스를 이용할 수 없습니다. 관리자에게 문의하세요." });
      }
      
      // 개발 환경 테스트 모드
      const testVirtualAccount = await storage.createVirtualAccount({
        orderId,
        userId,
        paymentId,
        bankCode: "088",
        bankName: "신한은행",
        accountNumber: `110${String(orderId).padStart(3, "0")}${Date.now().toString().slice(-6)}`,
        accountHolder: "헬프미(주)",
        amount,
        dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000),
        status: "pending",
      });

      res.json({
        success: true,
        virtualAccount: testVirtualAccount,
        isTestMode: true,
        message: "테스트 가상계좌가 발급되었습니다"
      });
    } catch (err) {
      console.error("Virtual account request error:", err);
      res.status(500).json({ message: "가상계좌 발급 중 오류가 발생했습니다" });
    }
  });

  // 가상계좌 정보 조회
  app.get("/api/payment/virtual-account/:orderId", async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const virtualAccount = await storage.getVirtualAccountByOrder(orderId);
      
      if (!virtualAccount) {
        return res.status(404).json({ message: "가상계좌를 찾을 수 없습니다" });
      }

      res.json({ virtualAccount });
    } catch (err) {
      console.error("Virtual account fetch error:", err);
      res.status(500).json({ message: "가상계좌 조회 중 오류가 발생했습니다" });
    }
  });

  // PortOne 입금 확인 웹훅 (PG사에서 호출)
  app.post("/api/webhook/portone/payment", async (req, res) => {
    try {
      // A-1: 웹훅 시크릿 검증 (운영 보안)
      const webhookSecret = req.headers["x-webhook-secret"] || req.headers["webhook-secret"];
      const expectedSecret = process.env.PORTONE_WEBHOOK_SECRET;
      
      if (expectedSecret && webhookSecret !== expectedSecret) {
        console.warn("[PortOne Webhook] Invalid webhook secret");
        return res.status(401).json({ success: false, message: "Invalid webhook secret" });
      }

      const { paymentId, status, paidAmount, paidAt } = req.body;
      
      console.log("[PortOne Webhook] Received:", { paymentId, status, paidAmount });

      if (status === "PAID" || status === "VIRTUAL_ACCOUNT_ISSUED") {
        // paymentId로 가상계좌 조회
        const virtualAccount = await storage.getVirtualAccountByPaymentId(paymentId);
        
        if (!virtualAccount) {
          console.warn(`[PortOne Webhook] Virtual account not found for paymentId: ${paymentId}`);
          return res.json({ success: true, message: "Virtual account not found" });
        }
        
        // A-2: 멱등 처리 (이미 처리된 경우 스킵)
        if (virtualAccount.status === "paid") {
          console.log(`[PortOne Webhook] Already processed: paymentId=${paymentId}`);
          return res.json({ success: true, message: "Already processed" });
        }
        
        if (status === "PAID") {
          // 가상계좌 상태 업데이트
          await storage.updateVirtualAccount(virtualAccount.id, {
            status: "paid",
            paidAmount,
            paidAt: paidAt ? new Date(paidAt) : new Date(),
            webhookReceivedAt: new Date(),
          });

          // B: 오더 상태 자동 변경 (awaiting_deposit → open) + approvalStatus 포함
          const order = await storage.getOrder(virtualAccount.orderId);
          if (order && order.status === ORDER_STATUS.AWAITING_DEPOSIT) {
            const updatedOrder = await storage.updateOrder(virtualAccount.orderId, {
              status: ORDER_STATUS.OPEN,
              paymentStatus: "deposit_confirmed",
              approvalStatus: "approved",
            });
            
            // 업데이트 성공 확인 후에만 브로드캐스트
            if (updatedOrder) {
              console.log(`[Auto Approve] Order ${virtualAccount.orderId} approved after deposit confirmation`);
              
              // D: 관리자 WS 브로드캐스트 (실시간 UI 갱신) - 업데이트 성공 후에만 실행
              try {
                await broadcastToAllAdmins("order", "payment_auto_approved", virtualAccount.orderId, {
                  orderId: virtualAccount.orderId,
                  paymentId,
                  status: ORDER_STATUS.OPEN,
                  paymentStatus: "deposit_confirmed",
                  approvalStatus: "approved",
                  paidAmount,
                });
              } catch (wsErr) {
                console.error("Admin broadcast error:", wsErr);
              }
            }
            
            // 푸시 알림 발송
            try {
              if (order.requesterId) {
                const user = await storage.getUser(order.requesterId);
                if (user) {
                  await storage.createNotification({
                    userId: user.id,
                    type: "order_approved",
                    title: "오더 승인 완료",
                    message: `오더 #${virtualAccount.orderId}의 계약금 입금이 확인되어 승인되었습니다.`,
                    relatedId: virtualAccount.orderId,
                  });
                }
              }
            } catch (notifyErr) {
              console.error("Notification error:", notifyErr);
            }
          }
        }
      }

      res.json({ success: true });
    } catch (err) {
      console.error("Webhook processing error:", err);
      res.status(500).json({ message: "웹훅 처리 오류" });
    }
  });

  // C: 테스트용 입금 확인 API (개발 환경에서만 - 운영에서는 비활성화)
  if (process.env.NODE_ENV !== "production") {
    app.post("/api/payment/virtual-account/:orderId/confirm-test", async (req, res) => {
      try {
        const orderId = parseInt(req.params.orderId);
        const virtualAccount = await storage.getVirtualAccountByOrder(orderId);
        
        if (!virtualAccount) {
          return res.status(404).json({ message: "가상계좌를 찾을 수 없습니다" });
        }

        // 가상계좌 상태 업데이트
        await storage.updateVirtualAccount(virtualAccount.id, {
          status: "paid",
          paidAmount: virtualAccount.amount,
          paidAt: new Date(),
          webhookReceivedAt: new Date(),
        });

        // 오더 상태 자동 변경 + approvalStatus 포함
        const order = await storage.getOrder(orderId);
        if (order && order.status === ORDER_STATUS.AWAITING_DEPOSIT) {
          await storage.updateOrder(orderId, {
            status: ORDER_STATUS.OPEN,
            paymentStatus: "deposit_confirmed",
            approvalStatus: "approved",
          });
          
          // 관리자 WS 브로드캐스트
          await broadcastToAllAdmins("order", "payment_test_approved", orderId, {
            orderId,
            status: ORDER_STATUS.OPEN,
            paymentStatus: "deposit_confirmed",
            approvalStatus: "approved",
          });
        }

        res.json({ 
          success: true, 
          message: "테스트 입금이 확인되었습니다",
          orderStatus: ORDER_STATUS.OPEN
        });
      } catch (err) {
        console.error("Test confirm error:", err);
        res.status(500).json({ message: "테스트 입금 확인 오류" });
      }
    });
  }

  // 은행 코드 → 은행명 변환
  function getBankName(bankCode: string): string {
    const banks: Record<string, string> = {
      "SHINHAN": "신한은행",
      "KB": "국민은행",
      "WOORI": "우리은행",
      "HANA": "하나은행",
      "NH": "농협은행",
      "IBK": "기업은행",
      "SC": "SC제일은행",
      "CITI": "씨티은행",
      "KAKAO": "카카오뱅크",
      "TOSS": "토스뱅크",
      "KBANK": "케이뱅크",
    };
    return banks[bankCode] || bankCode;
  }

  // 카카오 로그인 시작 (기존 - 호환성 유지)
  app.get("/api/auth/kakao", (req, res) => {
    const KAKAO_REST_API_KEY = process.env.KAKAO_REST_API_KEY;
    const protocol = req.get("x-forwarded-proto") || req.protocol;
    const baseUrl = OAUTH_BASE_URL || `${protocol}://${req.get("host")}`;
    const REDIRECT_URI = `${baseUrl}/api/auth/kakao/callback`;
    const role = req.query.role || "helper";
    
    console.log("[Kakao] Redirect URI:", REDIRECT_URI);
    const kakaoAuthUrl = `https://kauth.kakao.com/oauth/authorize?client_id=${KAKAO_REST_API_KEY}&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&response_type=code&state=${role}`;
    res.redirect(kakaoAuthUrl);
  });

  // 카카오 로그인 - 헬퍼 전용
  app.get("/api/auth/kakao/helper", (req, res) => {
    const KAKAO_REST_API_KEY = process.env.KAKAO_HELPER_REST_API_KEY || process.env.KAKAO_REST_API_KEY;
    const protocol = req.get("x-forwarded-proto") || req.protocol;
    const baseUrl = OAUTH_BASE_URL || `${protocol}://${req.get("host")}`;
    const REDIRECT_URI = `${baseUrl}/api/auth/kakao/helper/callback`;
    
    console.log("[Kakao Helper] Redirect URI:", REDIRECT_URI);
    const kakaoAuthUrl = `https://kauth.kakao.com/oauth/authorize?client_id=${KAKAO_REST_API_KEY}&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&response_type=code&state=helper`;
    res.redirect(kakaoAuthUrl);
  });

  // 카카오 로그인 - 의뢰인 전용
  app.get("/api/auth/kakao/requester", (req, res) => {
    const KAKAO_REST_API_KEY = process.env.KAKAO_REQUESTER_REST_API_KEY || process.env.KAKAO_REST_API_KEY;
    const protocol = req.get("x-forwarded-proto") || req.protocol;
    const baseUrl = OAUTH_BASE_URL || `${protocol}://${req.get("host")}`;
    const REDIRECT_URI = `${baseUrl}/api/auth/kakao/requester/callback`;
    
    console.log("[Kakao Requester] Redirect URI:", REDIRECT_URI);
    const kakaoAuthUrl = `https://kauth.kakao.com/oauth/authorize?client_id=${KAKAO_REST_API_KEY}&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&response_type=code&state=requester`;
    res.redirect(kakaoAuthUrl);
  });

  // 카카오 로그인 콜백 - 헬퍼 전용
  app.get("/api/auth/kakao/helper/callback", async (req, res) => {
    try {
      const { code } = req.query;
      const KAKAO_REST_API_KEY = process.env.KAKAO_HELPER_REST_API_KEY || process.env.KAKAO_REST_API_KEY;
      const protocol = req.get("x-forwarded-proto") || req.protocol;
      const baseUrl = OAUTH_BASE_URL || `${protocol}://${req.get("host")}`;
      const REDIRECT_URI = `${baseUrl}/api/auth/kakao/helper/callback`;
      console.log("[Kakao Helper Callback] Redirect URI:", REDIRECT_URI);

      const tokenResponse = await fetch("https://kauth.kakao.com/oauth/token", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
          grant_type: "authorization_code",
          client_id: KAKAO_REST_API_KEY!,
          redirect_uri: REDIRECT_URI,
          code: code as string,
        }),
      });

      const tokenData = await tokenResponse.json() as any;
      if (!tokenData.access_token) {
        await logAuthEvent(req, "social_login_failed", "failure", {
          provider: "kakao",
          metadata: { reason: "token_failed", role: "helper" }
        });
        return res.redirect("/signup?error=kakao_token_failed&role=helper");
      }

      const userResponse = await fetch("https://kapi.kakao.com/v2/user/me", {
        headers: { Authorization: `Bearer ${tokenData.access_token}` },
      });

      const userData = await userResponse.json() as any;
      const kakaoId = userData.id?.toString();
      const kakaoAccount = userData.kakao_account || {};
      const profile = kakaoAccount.profile || {};
      const email = kakaoAccount.email;
      const name = profile.nickname || `카카오사용자${kakaoId?.slice(-4)}`;

      let user = await storage.getUserByKakaoId(kakaoId);
      if (!user && email) {
        user = await storage.getUserByEmail(email);
        if (user) {
          await storage.updateUser(user.id, { kakaoId });
        }
      }

      if (user) {
        const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: "7d" });
        await logAuthEvent(req, "social_login", "success", {
          userId: user.id,
          provider: "kakao",
          metadata: { kakaoId, role: "helper" }
        });
        const userPayload = encodeURIComponent(JSON.stringify({
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
          isHqStaff: user.isHqStaff,
        }));
        return res.redirect(`/auth-callback?token=${token}&user=${userPayload}`);
      }

      await logAuthEvent(req, "social_signup", "pending", {
        provider: "kakao",
        metadata: { kakaoId, email, role: "helper" }
      });
      const signupData = encodeURIComponent(JSON.stringify({
        provider: "kakao",
        kakaoId,
        email: email || "",
        name,
        role: "helper",
      }));
      res.redirect(`/signup?social=${signupData}`);
    } catch (err) {
      console.error("Kakao helper login error:", err);
      await logAuthEvent(req, "social_login_failed", "failure", {
        provider: "kakao",
        metadata: { error: (err as Error).message, role: "helper" }
      });
      res.redirect("/signup?error=kakao_failed&role=helper");
    }
  });

  // 카카오 로그인 콜백 - 의뢰인 전용
  app.get("/api/auth/kakao/requester/callback", async (req, res) => {
    try {
      const { code } = req.query;
      const KAKAO_REST_API_KEY = process.env.KAKAO_REQUESTER_REST_API_KEY || process.env.KAKAO_REST_API_KEY;
      const protocol = req.get("x-forwarded-proto") || req.protocol;
      const baseUrl = OAUTH_BASE_URL || `${protocol}://${req.get("host")}`;
      const REDIRECT_URI = `${baseUrl}/api/auth/kakao/requester/callback`;
      console.log("[Kakao Requester Callback] Redirect URI:", REDIRECT_URI);

      const tokenResponse = await fetch("https://kauth.kakao.com/oauth/token", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
          grant_type: "authorization_code",
          client_id: KAKAO_REST_API_KEY!,
          redirect_uri: REDIRECT_URI,
          code: code as string,
        }),
      });

      const tokenData = await tokenResponse.json() as any;
      if (!tokenData.access_token) {
        await logAuthEvent(req, "social_login_failed", "failure", {
          provider: "kakao",
          metadata: { reason: "token_failed", role: "requester" }
        });
        return res.redirect("/signup?error=kakao_token_failed&role=requester");
      }

      const userResponse = await fetch("https://kapi.kakao.com/v2/user/me", {
        headers: { Authorization: `Bearer ${tokenData.access_token}` },
      });

      const userData = await userResponse.json() as any;
      const kakaoId = userData.id?.toString();
      const kakaoAccount = userData.kakao_account || {};
      const profile = kakaoAccount.profile || {};
      const email = kakaoAccount.email;
      const name = profile.nickname || `카카오사용자${kakaoId?.slice(-4)}`;

      let user = await storage.getUserByKakaoId(kakaoId);
      if (!user && email) {
        user = await storage.getUserByEmail(email);
        if (user) {
          await storage.updateUser(user.id, { kakaoId });
        }
      }

      if (user) {
        const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: "7d" });
        await logAuthEvent(req, "social_login", "success", {
          userId: user.id,
          provider: "kakao",
          metadata: { kakaoId, role: "requester" }
        });
        const userPayload = encodeURIComponent(JSON.stringify({
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
          isHqStaff: user.isHqStaff,
        }));
        return res.redirect(`/auth-callback?token=${token}&user=${userPayload}`);
      }

      await logAuthEvent(req, "social_signup", "pending", {
        provider: "kakao",
        metadata: { kakaoId, email, role: "requester" }
      });
      const signupData = encodeURIComponent(JSON.stringify({
        provider: "kakao",
        kakaoId,
        email: email || "",
        name,
        role: "requester",
      }));
      res.redirect(`/signup?social=${signupData}`);
    } catch (err) {
      console.error("Kakao requester login error:", err);
      await logAuthEvent(req, "social_login_failed", "failure", {
        provider: "kakao",
        metadata: { error: (err as Error).message, role: "requester" }
      });
      res.redirect("/signup?error=kakao_failed&role=requester");
    }
  });

  // 카카오 로그인 콜백 (기존 - 호환성 유지)
  app.get("/api/auth/kakao/callback", async (req, res) => {
    try {
      const { code, state: role } = req.query;
      const KAKAO_REST_API_KEY = process.env.KAKAO_REST_API_KEY;
      const protocol = req.get("x-forwarded-proto") || req.protocol;
      const baseUrl = OAUTH_BASE_URL || `${protocol}://${req.get("host")}`;
      const REDIRECT_URI = `${baseUrl}/api/auth/kakao/callback`;
      console.log("[Kakao Callback] Redirect URI:", REDIRECT_URI);

      // 액세스 토큰 요청
      const tokenResponse = await fetch("https://kauth.kakao.com/oauth/token", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
          grant_type: "authorization_code",
          client_id: KAKAO_REST_API_KEY!,
          redirect_uri: REDIRECT_URI,
          code: code as string,
        }),
      });

      const tokenData = await tokenResponse.json() as any;
      if (!tokenData.access_token) {
        await logAuthEvent(req, "social_login_failed", "failure", {
          provider: "kakao",
          metadata: { reason: "token_failed" }
        });
        return res.redirect("/signup?error=kakao_token_failed");
      }

      // 사용자 정보 요청
      const userResponse = await fetch("https://kapi.kakao.com/v2/user/me", {
        headers: { Authorization: `Bearer ${tokenData.access_token}` },
      });

      const userData = await userResponse.json() as any;
      const kakaoId = userData.id?.toString();
      const kakaoAccount = userData.kakao_account || {};
      const profile = kakaoAccount.profile || {};

      const email = kakaoAccount.email;
      const name = profile.nickname || `카카오사용자${kakaoId?.slice(-4)}`;

      // 기존 사용자 확인 (카카오 ID 또는 이메일로)
      let user = await storage.getUserByKakaoId(kakaoId);
      
      if (!user && email) {
        user = await storage.getUserByEmail(email);
        if (user) {
          // 이메일로 찾은 경우 카카오 ID 연결
          await storage.updateUser(user.id, { kakaoId });
        }
      }

      if (user) {
        // 기존 사용자 로그인
        const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: "7d" });
        await logAuthEvent(req, "social_login", "success", {
          userId: user.id,
          provider: "kakao",
          metadata: { kakaoId }
        });
        const userPayload = encodeURIComponent(JSON.stringify({
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
          isHqStaff: user.isHqStaff,
        }));
        return res.redirect(`/auth-callback?token=${token}&user=${userPayload}`);
      }

      // 신규 사용자: 회원가입 페이지로 이동
      await logAuthEvent(req, "social_signup", "pending", {
        provider: "kakao",
        metadata: { kakaoId, email }
      });
      const signupData = encodeURIComponent(JSON.stringify({
        provider: "kakao",
        kakaoId,
        email: email || "",
        name,
        role: role || "helper",
      }));
      res.redirect(`/signup?social=${signupData}`);
    } catch (err) {
      console.error("Kakao login error:", err);
      await logAuthEvent(req, "social_login_failed", "failure", {
        provider: "kakao",
        metadata: { error: (err as Error).message }
      });
      res.redirect("/signup?error=kakao_failed");
    }
  });

  // 네이버 로그인 시작
  app.get("/api/auth/naver", (req, res) => {
    const NAVER_CLIENT_ID = process.env.NAVER_CLIENT_ID;
    const protocol = req.get("x-forwarded-proto") || req.protocol;
    const baseUrl = OAUTH_BASE_URL || `${protocol}://${req.get("host")}`;
    const REDIRECT_URI = `${baseUrl}/api/auth/naver/callback`;
    const role = req.query.role || "helper";
    const state = Buffer.from(JSON.stringify({ role })).toString("base64");
    
    console.log("[Naver] Redirect URI:", REDIRECT_URI);
    const naverAuthUrl = `https://nid.naver.com/oauth2.0/authorize?client_id=${NAVER_CLIENT_ID}&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&response_type=code&state=${state}`;
    res.redirect(naverAuthUrl);
  });

  // 네이버 로그인 콜백
  app.get("/api/auth/naver/callback", async (req, res) => {
    try {
      const { code, state } = req.query;
      const NAVER_CLIENT_ID = process.env.NAVER_CLIENT_ID;
      const NAVER_CLIENT_SECRET = process.env.NAVER_CLIENT_SECRET;
      const protocol = req.get("x-forwarded-proto") || req.protocol;
      const baseUrl = OAUTH_BASE_URL || `${protocol}://${req.get("host")}`;
      const REDIRECT_URI = `${baseUrl}/api/auth/naver/callback`;
      console.log("[Naver Callback] Redirect URI:", REDIRECT_URI);

      let role = "helper";
      try {
        const stateData = JSON.parse(Buffer.from(state as string, "base64").toString());
        role = stateData.role || "helper";
      } catch {}

      // 액세스 토큰 요청
      const tokenResponse = await fetch("https://nid.naver.com/oauth2.0/token", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
          grant_type: "authorization_code",
          client_id: NAVER_CLIENT_ID!,
          client_secret: NAVER_CLIENT_SECRET!,
          redirect_uri: REDIRECT_URI,
          code: code as string,
          state: state as string,
        }),
      });

      const tokenData = await tokenResponse.json() as any;
      if (!tokenData.access_token) {
        await logAuthEvent(req, "social_login_failed", "failure", {
          provider: "naver",
          metadata: { reason: "token_failed" }
        });
        return res.redirect("/signup?error=naver_token_failed");
      }

      // 사용자 정보 요청
      const userResponse = await fetch("https://openapi.naver.com/v1/nid/me", {
        headers: { Authorization: `Bearer ${tokenData.access_token}` },
      });

      const userData = await userResponse.json() as any;
      const naverUser = userData.response || {};
      const naverId = naverUser.id;
      const email = naverUser.email;
      const name = naverUser.name || naverUser.nickname || `네이버사용자${naverId?.slice(-4)}`;
      const phoneNumber = naverUser.mobile?.replace(/-/g, "");

      // 기존 사용자 확인 (네이버 ID 또는 이메일로)
      let user = await storage.getUserByNaverId(naverId);
      
      if (!user && email) {
        user = await storage.getUserByEmail(email);
        if (user) {
          // 이메일로 찾은 경우 네이버 ID 연결
          await storage.updateUser(user.id, { naverId });
        }
      }

      if (user) {
        // 기존 사용자 로그인
        const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: "7d" });
        await logAuthEvent(req, "social_login", "success", {
          userId: user.id,
          provider: "naver",
          metadata: { naverId }
        });
        const userPayload = encodeURIComponent(JSON.stringify({
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
          isHqStaff: user.isHqStaff,
        }));
        return res.redirect(`/auth-callback?token=${token}&user=${userPayload}`);
      }

      // 신규 사용자: 회원가입 페이지로 이동
      await logAuthEvent(req, "social_signup", "pending", {
        provider: "naver",
        metadata: { naverId, email }
      });
      const signupData = encodeURIComponent(JSON.stringify({
        provider: "naver",
        naverId,
        email: email || "",
        name,
        phoneNumber: phoneNumber || "",
        role,
      }));
      res.redirect(`/signup?social=${signupData}`);
    } catch (err) {
      console.error("Naver login error:", err);
      await logAuthEvent(req, "social_login_failed", "failure", {
        provider: "naver",
        metadata: { error: (err as Error).message }
      });
      res.redirect("/signup?error=naver_failed");
    }
  });

  // Helper credential routes
  const credentialsUploadsDir = path.join(process.cwd(), "uploads", "credentials");
  await fs.promises.mkdir(credentialsUploadsDir, { recursive: true });

  const uploadCredentialImage = multer({
    storage: multer.diskStorage({
      destination: (_req, _file, cb) => cb(null, credentialsUploadsDir),
      filename: (_req, file, cb) => {
        const ext = path.extname(file.originalname);
        cb(null, `${Date.now()}-${Math.random().toString(36).substr(2, 9)}${ext}`);
      },
    }),
    limits: { fileSize: 10 * 1024 * 1024 },
    fileFilter: (_req, file, cb) => {
      if (file.mimetype.startsWith("image/")) {
        cb(null, true);
      } else {
        cb(new Error("이미지 파일만 업로드 가능합니다"));
      }
    },
  });

  app.post("/api/helpers/credential/upload", requireAuth, uploadCredentialImage.single("file"), async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      if (!req.file) {
        return res.status(400).json({ message: "파일을 선택해주세요" });
      }
      
      const docType = req.body.type || "document";
      const imageUrl = `/uploads/credentials/${req.file.filename}`;
      res.json({ success: true, url: imageUrl, type: docType });
    } catch (err) {
      console.error("Credential upload error:", err);
      res.status(500).json({ message: "업로드에 실패했습니다" });
    }
  });

  app.post(api.helpers.createCredential.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      const input = api.helpers.createCredential.input.parse(req.body);
      const credential = await storage.createHelperCredential(userId, input);
      res.status(201).json(credential);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({
          message: err.errors[0].message,
          field: err.errors[0].path.join("."),
        });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get(api.helpers.getCredential.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      const credential = await storage.getHelperCredential(userId);
      if (!credential) {
        return res.status(404).json({ message: "Credential not found" });
      }
      res.json(credential);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper license (운전면허증/화물자격증) endpoints
  app.get("/api/helpers/me/license", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      const license = await storage.getHelperLicense(user.id);
      if (!license) {
        return res.status(404).json({ message: "면허증 정보가 없습니다" });
      }
      res.json(license);
    } catch (err) {
      console.error("Get helper license error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/helpers/me/license", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      const existing = await storage.getHelperLicense(user.id);
      if (existing) {
        const updated = await storage.updateHelperLicense(user.id, {
          driverLicenseImageUrl: req.body.driverLicenseImageUrl || existing.driverLicenseImageUrl,
          cargoLicenseImageUrl: req.body.cargoLicenseImageUrl || existing.cargoLicenseImageUrl,
        });
        return res.json(updated);
      }
      const license = await storage.createHelperLicense(user.id, {
        driverLicenseImageUrl: req.body.driverLicenseImageUrl,
        cargoLicenseImageUrl: req.body.cargoLicenseImageUrl,
      });
      res.status(201).json(license);
    } catch (err) {
      console.error("Create helper license error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper vehicle (차량정보) endpoints
  app.get("/api/helpers/me/vehicle", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      const vehicle = await storage.getHelperVehicle(user.id);
      if (!vehicle) {
        return res.status(404).json({ message: "차량 정보가 없습니다" });
      }
      res.json(vehicle);
    } catch (err) {
      console.error("Get helper vehicle error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/helpers/me/vehicle", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      const { vehicleType, plateNumber, vehicleImageUrl } = req.body;
      if (!vehicleType || !plateNumber) {
        return res.status(400).json({ message: "차종과 차량번호는 필수입니다" });
      }
      const existing = await storage.getHelperVehicle(user.id);
      if (existing) {
        const updated = await storage.updateHelperVehicle(user.id, {
          vehicleType,
          plateNumber,
          vehicleImageUrl: vehicleImageUrl || existing.vehicleImageUrl,
        });
        return res.json(updated);
      }
      const vehicle = await storage.createHelperVehicle(user.id, {
        vehicleType,
        plateNumber,
        vehicleImageUrl,
      });
      res.status(201).json(vehicle);
    } catch (err) {
      console.error("Create helper vehicle error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper business (사업자등록) endpoints
  app.get("/api/helpers/me/business", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      const business = await storage.getHelperBusiness(user.id);
      if (!business) {
        return res.status(404).json({ message: "사업자 정보가 없습니다" });
      }
      res.json(business);
    } catch (err) {
      console.error("Get helper business error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/helpers/me/business", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      const { businessNumber, businessName, representativeName, address, businessType, businessCategory, email, businessImageUrl } = req.body;
      if (!businessNumber || !businessName || !representativeName || !address || !businessType || !businessCategory) {
        return res.status(400).json({ message: "필수 정보를 모두 입력해주세요" });
      }
      const existing = await storage.getHelperBusiness(user.id);
      if (existing) {
        const updated = await storage.updateHelperBusiness(user.id, {
          businessNumber,
          businessName,
          representativeName,
          address,
          businessType,
          businessCategory,
          email,
          businessImageUrl,
        });
        return res.json(updated);
      }
      const business = await storage.createHelperBusiness(user.id, {
        businessNumber,
        businessName,
        representativeName,
        address,
        businessType,
        businessCategory,
        email,
        businessImageUrl,
      });
      res.status(201).json(business);
    } catch (err) {
      console.error("Create helper business error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper bank account (정산계좌) endpoints
  app.get("/api/helpers/me/bank-account", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      const account = await storage.getHelperBankAccount(user.id);
      if (!account) {
        return res.status(404).json({ message: "계좌 정보가 없습니다" });
      }
      res.json(account);
    } catch (err) {
      console.error("Get helper bank account error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/helpers/me/bank-account", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      const { accountHolder, bankName, accountNumber, bankbookImageUrl } = req.body;
      if (!accountHolder || !bankName || !accountNumber) {
        return res.status(400).json({ message: "예금주, 은행명, 계좌번호는 필수입니다" });
      }
      const existing = await storage.getHelperBankAccount(user.id);
      if (existing) {
        return res.status(400).json({ message: "이미 등록된 계좌 정보가 있습니다" });
      }
      const account = await storage.createHelperBankAccount(user.id, {
        accountHolder,
        bankName,
        accountNumber,
        bankbookImageUrl,
      });
      res.status(201).json(account);
    } catch (err) {
      console.error("Create helper bank account error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Platform contract endpoint
  app.get("/api/helpers/me/contract", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      // Get contract data from database (implement storage method if needed)
      // For now, return 404 if not found
      return res.status(404).json({ message: "계약 정보가 없습니다" });
    } catch (err) {
      console.error("Get helper contract error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/helpers/me/contract", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      const { agreedClauses, signatureData, signedAt } = req.body;
      if (!agreedClauses || !signatureData || !signedAt) {
        return res.status(400).json({ message: "약관 동의, 서명, 서명 날짜는 필수입니다" });
      }
      // TODO: Save contract to database
      // For now, just return success
      res.status(201).json({
        success: true,
        message: "계약서가 저장되었습니다",
        agreedClauses,
        signedAt,
      });
    } catch (err) {
      console.error("Create helper contract error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Help posts routes
  app.get(api.helpPosts.list.path, async (req, res) => {
    try {
      const posts = await storage.getAllHelpPosts();
      res.json(posts);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post(api.helpPosts.create.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const input = api.helpPosts.create.input.parse(req.body);
      const post = await storage.createHelpPost(userId, input);
      res.status(201).json(post);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({
          message: err.errors[0].message,
          field: err.errors[0].path.join("."),
        });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get(api.helpPosts.get.path, async (req, res) => {
    try {
      const post = await storage.getHelpPost(Number(req.params.id));
      if (!post) {
        return res.status(404).json({ message: "Post not found" });
      }
      res.json(post);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch(api.helpPosts.update.path, async (req, res) => {
    try {
      const input = api.helpPosts.update.input.parse(req.body);
      const post = await storage.updateHelpPost(Number(req.params.id), input);
      res.json(post);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper vehicle routes
  app.post(api.helpers.createVehicle.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      const input = api.helpers.createVehicle.input.parse(req.body);
      const vehicle = await storage.createHelperVehicle(userId, input);
      res.status(201).json(vehicle);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({
          message: err.errors[0].message,
          field: err.errors[0].path.join("."),
        });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get(api.helpers.getVehicle.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      const vehicle = await storage.getHelperVehicle(userId);
      if (!vehicle) {
        return res.status(404).json({ message: "Vehicle not found" });
      }
      res.json(vehicle);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post(api.helpers.uploadVehicleImage.path, uploadVehicleImage.single("image"), requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      if (!req.file) {
        return res.status(400).json({ message: "이미지를 선택해주세요" });
      }
      const imageUrl = `/uploads/vehicles/${req.file.filename}`;
      res.json({ imageUrl });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper business routes
  const businessUploadsDir = path.join(process.cwd(), "uploads", "businesses");
  await fs.promises.mkdir(businessUploadsDir, { recursive: true });

  const uploadBusinessImage = multer({
    storage: multer.diskStorage({
      destination: (_req, _file, cb) => cb(null, businessUploadsDir),
      filename: (_req, file, cb) => {
        const ext = path.extname(file.originalname);
        cb(null, `${Date.now()}-${Math.random().toString(36).substr(2, 9)}${ext}`);
      },
    }),
    limits: { fileSize: 10 * 1024 * 1024 },
    fileFilter: (_req, file, cb) => {
      if (file.mimetype.startsWith("image/")) {
        cb(null, true);
      } else {
        cb(new Error("이미지 파일만 업로드 가능합니다"));
      }
    },
  });

  app.post(api.helpers.createBusiness.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      const input = api.helpers.createBusiness.input.parse(req.body);
      
      const existing = await storage.getHelperBusiness(userId);
      let business;
      if (existing) {
        business = await storage.updateHelperBusiness(userId, input);
      } else {
        business = await storage.createHelperBusiness(userId, input);
      }
      res.status(201).json(business);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({
          message: err.errors[0].message,
          field: err.errors[0].path.join("."),
        });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get(api.helpers.getBusiness.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      const business = await storage.getHelperBusiness(userId);
      if (!business) {
        return res.status(404).json({ message: "Business not found" });
      }
      res.json(business);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post(api.helpers.uploadBusinessImage.path, uploadBusinessImage.single("image"), requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      if (!req.file) {
        return res.status(400).json({ message: "이미지를 선택해주세요" });
      }
      const imageUrl = `/uploads/businesses/${req.file.filename}`;
      res.json({ imageUrl });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Requester business routes (의뢰인 사업자 등록)
  app.post("/api/requesters/business", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 의뢰인만 접근 가능
      if (user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 접근 가능합니다" });
      }
      
      const { businessNumber, businessName, representativeName, address, businessType, businessCategory, businessImageUrl } = req.body;
      
      if (!businessNumber || !businessName || !representativeName || !address || !businessType || !businessCategory) {
        return res.status(400).json({ message: "필수 항목을 모두 입력해주세요" });
      }
      
      const existing = await storage.getRequesterBusiness(userId);
      let business;
      if (existing) {
        business = await storage.updateRequesterBusiness(userId, {
          businessNumber, businessName, representativeName, address, businessType, businessCategory, businessImageUrl
        });
      } else {
        business = await storage.createRequesterBusiness(userId, {
          businessNumber, businessName, representativeName, address, businessType, businessCategory, businessImageUrl
        });
      }
      
      // 세금계산서 발행 활성화
      await storage.updateUserPreferences(userId, { taxInvoiceEnabled: true });
      
      res.status(201).json(business);
    } catch (err) {
      console.error("Requester business error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/requesters/business", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 의뢰인만 접근 가능
      if (user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 접근 가능합니다" });
      }
      
      const business = await storage.getRequesterBusiness(userId);
      if (!business) {
        return res.status(404).json({ message: "Business not found" });
      }
      res.json(business);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/requesters/business/image", uploadBusinessImage.single("image"), requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      
      // 역할 검증: 의뢰인만 접근 가능
      if (user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 접근 가능합니다" });
      }
      
      if (!req.file) {
        return res.status(400).json({ message: "이미지를 선택해주세요" });
      }
      const imageUrl = `/uploads/businesses/${req.file.filename}`;
      res.json({ imageUrl });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Requester refund account routes
  app.get("/api/requesters/refund-account", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      if (user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 접근 가능합니다" });
      }
      
      const [account] = await db.select().from(requesterRefundAccounts).where(eq(requesterRefundAccounts.userId, userId));
      res.json({ account: account || null });
    } catch (err) {
      console.error("[Refund Account GET] Error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/requesters/refund-account", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      if (user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 접근 가능합니다" });
      }
      
      const parseResult = insertRequesterRefundAccountSchema.safeParse(req.body);
      if (!parseResult.success) {
        const firstError = parseResult.error.errors[0];
        return res.status(400).json({ message: firstError?.message || "입력 데이터가 올바르지 않습니다" });
      }
      
      const { bankName, accountNumber, accountHolder } = parseResult.data;
      
      const [existing] = await db.select().from(requesterRefundAccounts).where(eq(requesterRefundAccounts.userId, userId));
      
      let account;
      if (existing) {
        [account] = await db.update(requesterRefundAccounts)
          .set({ 
            bankName, 
            accountNumber, 
            accountHolder, 
            updatedAt: new Date() 
          })
          .where(eq(requesterRefundAccounts.userId, userId))
          .returning();
      } else {
        [account] = await db.insert(requesterRefundAccounts)
          .values({ 
            userId, 
            bankName, 
            accountNumber, 
            accountHolder 
          })
          .returning();
      }
      
      res.json({ account });
    } catch (err) {
      console.error("[Refund Account POST] Error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper bank account routes
  const bankbookUploadsDir = path.join(process.cwd(), "uploads", "bankbooks");
  await fs.promises.mkdir(bankbookUploadsDir, { recursive: true });

  const uploadBankbookImage = multer({
    storage: multer.diskStorage({
      destination: (_req, _file, cb) => cb(null, bankbookUploadsDir),
      filename: (_req, file, cb) => {
        const ext = path.extname(file.originalname);
        cb(null, `${Date.now()}-${Math.random().toString(36).substr(2, 9)}${ext}`);
      },
    }),
    limits: { fileSize: 10 * 1024 * 1024 },
    fileFilter: (_req, file, cb) => {
      if (file.mimetype.startsWith("image/")) {
        cb(null, true);
      } else {
        cb(new Error("이미지 파일만 업로드 가능합니다"));
      }
    },
  });

  app.post(api.helpers.createBankAccount.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      const input = api.helpers.createBankAccount.input.parse(req.body);
      
      const existing = await storage.getHelperBankAccount(userId);
      let account;
      if (existing) {
        account = await storage.updateHelperBankAccount(userId, input);
      } else {
        account = await storage.createHelperBankAccount(userId, input);
      }
      res.status(201).json(account);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({
          message: err.errors[0].message,
          field: err.errors[0].path.join("."),
        });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get(api.helpers.getBankAccount.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      const account = await storage.getHelperBankAccount(userId);
      if (!account) {
        return res.status(404).json({ message: "Bank account not found" });
      }
      res.json(account);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post(api.helpers.uploadBankbookImage.path, uploadBankbookImage.single("image"), requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      if (!req.file) {
        return res.status(400).json({ message: "이미지를 선택해주세요" });
      }
      const imageUrl = `/uploads/bankbooks/${req.file.filename}`;
      res.json({ imageUrl });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper onboarding status API
  app.get("/api/helpers/onboarding-status", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      const [vehicle, business, license, bankAccount, termsAgreement] = await Promise.all([
        storage.getHelperVehicle(userId),
        storage.getHelperBusiness(userId),
        storage.getHelperLicense(userId),
        storage.getHelperBankAccount(userId),
        storage.getHelperTermsAgreement(userId),
      ]);
      
      const hasVehicle = !!vehicle;
      const hasBusiness = !!business;
      const hasLicense = !!license && !!(license.driverLicenseImageUrl || license.cargoLicenseImageUrl);
      const hasBankAccount = !!bankAccount;
      const hasTermsAgreement = !!termsAgreement;
      const isComplete = hasVehicle && hasBusiness && hasLicense && hasBankAccount && hasTermsAgreement;
      
      res.json({
        hasVehicle,
        hasBusiness,
        hasLicense,
        hasBankAccount,
        hasTermsAgreement,
        isComplete,
        onboardingStatus: user.onboardingStatus,
      });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper submit onboarding for review
  app.post("/api/helpers/onboarding/submit", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      // Check if all documents are submitted
      const [vehicle, business, license] = await Promise.all([
        storage.getHelperVehicle(userId),
        storage.getHelperBusiness(userId),
        storage.getHelperLicense(userId),
      ]);
      
      if (!vehicle || !business || !license) {
        return res.status(400).json({ message: "모든 서류를 먼저 등록해주세요" });
      }
      
      // Update onboarding status to submitted
      await storage.updateUser(userId, {
        onboardingStatus: "submitted",
      });
      
      // Create notification for admin
      await storage.createNotification({
        userId,
        type: "onboarding_submitted",
        title: "심사 요청 완료",
        message: "서류 심사가 요청되었습니다. 승인까지 영업일 기준 1-2일 소요됩니다.",
        relatedId: null,
      });
      
      res.json({ 
        success: true, 
        message: "심사 요청이 완료되었습니다. 승인까지 영업일 기준 1-2일 소요됩니다." 
      });
    } catch (err) {
      console.error("Submit onboarding error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper license routes
  const licensesUploadsDir = path.join(process.cwd(), "uploads", "licenses");
  await fs.promises.mkdir(licensesUploadsDir, { recursive: true });

  const uploadLicenseImage = multer({
    storage: multer.diskStorage({
      destination: (_req, _file, cb) => cb(null, licensesUploadsDir),
      filename: (_req, file, cb) => {
        const ext = path.extname(file.originalname);
        cb(null, `${Date.now()}-${Math.random().toString(36).substr(2, 9)}${ext}`);
      },
    }),
    limits: { fileSize: 10 * 1024 * 1024 },
    fileFilter: (_req, file, cb) => {
      if (file.mimetype.startsWith("image/")) {
        cb(null, true);
      } else {
        cb(new Error("이미지 파일만 업로드 가능합니다"));
      }
    },
  });

  app.post(api.helpers.createLicense.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      const input = api.helpers.createLicense.input.parse(req.body);
      
      const existing = await storage.getHelperLicense(userId);
      let license;
      if (existing) {
        license = await storage.updateHelperLicense(userId, input);
      } else {
        license = await storage.createHelperLicense(userId, input);
      }
      res.status(201).json(license);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({
          message: err.errors[0].message,
          field: err.errors[0].path.join("."),
        });
      }
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get(api.helpers.getLicense.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      const license = await storage.getHelperLicense(userId);
      if (!license) {
        return res.status(404).json({ message: "License not found" });
      }
      res.json(license);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post(api.helpers.uploadDriverLicenseImage.path, uploadLicenseImage.single("image"), requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      if (!req.file) {
        return res.status(400).json({ message: "이미지를 선택해주세요" });
      }
      const imageUrl = `/uploads/licenses/${req.file.filename}`;
      res.json({ imageUrl });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post(api.helpers.uploadCargoLicenseImage.path, uploadLicenseImage.single("image"), requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      if (!req.file) {
        return res.status(400).json({ message: "이미지를 선택해주세요" });
      }
      const imageUrl = `/uploads/licenses/${req.file.filename}`;
      res.json({ imageUrl });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Work proof image uploads
  const workproofUploadsDir = path.join(process.cwd(), "uploads", "workproof");
  if (!fs.existsSync(workproofUploadsDir)) {
    fs.mkdirSync(workproofUploadsDir, { recursive: true });
  }
  const uploadWorkproofImage = multer({
    storage: multer.diskStorage({
      destination: (_req, _file, cb) => cb(null, workproofUploadsDir),
      filename: (_req, file, cb) => {
        const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
        cb(null, uniqueSuffix + path.extname(file.originalname));
      },
    }),
    limits: { fileSize: 10 * 1024 * 1024 },
    fileFilter: (_req, file, cb) => {
      const allowedTypes = /jpeg|jpg|png|webp/;
      const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
      const mimetype = allowedTypes.test(file.mimetype);
      if (extname && mimetype) cb(null, true);
      else cb(new Error("이미지 파일만 업로드 가능합니다 (jpg, png, webp)"));
    },
  });

  app.post("/api/work-proof/upload", uploadWorkproofImage.single("image"), requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      if (!req.file) {
        return res.status(400).json({ message: "이미지를 선택해주세요" });
      }
      
      const fileBuffer = fs.readFileSync(req.file.path);
      if (!isValidImageBuffer(fileBuffer)) {
        fs.unlinkSync(req.file.path);
        return res.status(400).json({ message: "유효하지 않은 이미지 파일입니다" });
      }
      
      const imageUrl = `/uploads/workproof/${req.file.filename}`;
      res.json({ imageUrl });
    } catch (err) {
      res.status(500).json({ message: "업로드 중 오류가 발생했습니다" });
    }
  });

  // Order reference image uploads
  const orderImagesDir = path.join(process.cwd(), "uploads", "orders");
  if (!fs.existsSync(orderImagesDir)) {
    fs.mkdirSync(orderImagesDir, { recursive: true });
  }
  const uploadOrderImage = multer({
    storage: multer.diskStorage({
      destination: (_req, _file, cb) => cb(null, orderImagesDir),
      filename: (_req, file, cb) => {
        const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
        cb(null, uniqueSuffix + path.extname(file.originalname));
      },
    }),
    limits: { fileSize: 10 * 1024 * 1024 },
    fileFilter: (_req, file, cb) => {
      const allowedTypes = /jpeg|jpg|png|webp/;
      const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
      const mimetype = allowedTypes.test(file.mimetype);
      if (extname && mimetype) cb(null, true);
      else cb(new Error("이미지 파일만 업로드 가능합니다 (jpg, png, webp)"));
    },
  });

  app.post("/api/orders/image/upload", uploadOrderImage.single("image"), requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      
      if (user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 접근 가능합니다" });
      }
      
      if (!req.file) {
        return res.status(400).json({ message: "이미지를 선택해주세요" });
      }
      
      const fileBuffer = fs.readFileSync(req.file.path);
      if (!isValidImageBuffer(fileBuffer)) {
        fs.unlinkSync(req.file.path);
        return res.status(400).json({ message: "유효하지 않은 이미지 파일입니다" });
      }
      
      const imageUrl = `/uploads/orders/${req.file.filename}`;
      res.json({ imageUrl });
    } catch (err) {
      res.status(500).json({ message: "업로드 중 오류가 발생했습니다" });
    }
  });

  // Protected file access API - 민감 파일 접근 통제
  // PII 파일(licenses, bankbooks, businesses)은 관리자 또는 본인만 접근 가능
  // 소유권 검증: DB에서 해당 URL을 가진 사용자 확인
  
  app.get("/uploads/licenses/:filename", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      const isAdmin = user.isHqStaff === true;
      const requestedUrl = `/uploads/licenses/${req.params.filename}`;
      
      // 소유권 검증: 본인 파일인지 확인 (운전면허증 또는 화물자격증)
      const license = await storage.getHelperLicense(userId);
      const isOwner = license?.driverLicenseImageUrl === requestedUrl || 
                      license?.cargoLicenseImageUrl === requestedUrl;
      
      if (!isAdmin && !isOwner) {
        return res.status(403).json({ message: "접근 권한이 없습니다" });
      }
      
      const filePath = path.join(process.cwd(), "uploads", "licenses", req.params.filename);
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ message: "파일을 찾을 수 없습니다" });
      }
      
      res.sendFile(filePath);
    } catch (err) {
      res.status(401).json({ message: "Unauthorized" });
    }
  });
  
  app.get("/uploads/bankbooks/:filename", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      const isAdmin = user.isHqStaff === true;
      const requestedUrl = `/uploads/bankbooks/${req.params.filename}`;
      
      // 소유권 검증: 본인 통장사본인지 확인
      const bankAccount = await storage.getHelperBankAccount(userId);
      const isOwner = bankAccount?.bankbookImageUrl === requestedUrl;
      
      if (!isAdmin && !isOwner) {
        return res.status(403).json({ message: "접근 권한이 없습니다" });
      }
      
      const filePath = path.join(process.cwd(), "uploads", "bankbooks", req.params.filename);
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ message: "파일을 찾을 수 없습니다" });
      }
      
      res.sendFile(filePath);
    } catch (err) {
      res.status(401).json({ message: "Unauthorized" });
    }
  });
  
  app.get("/uploads/businesses/:filename", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      const isAdmin = user.isHqStaff === true;
      const requestedUrl = `/uploads/businesses/${req.params.filename}`;
      
      // 소유권 검증: 본인 사업자등록증인지 확인
      const business = await storage.getHelperBusiness(userId);
      const isOwner = business?.businessImageUrl === requestedUrl;
      
      if (!isAdmin && !isOwner) {
        return res.status(403).json({ message: "접근 권한이 없습니다" });
      }
      
      const filePath = path.join(process.cwd(), "uploads", "businesses", req.params.filename);
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ message: "파일을 찾을 수 없습니다" });
      }
      
      res.sendFile(filePath);
    } catch (err) {
      res.status(401).json({ message: "Unauthorized" });
    }
  });
  
  // vehicles는 관리자 또는 본인만 접근 가능
  app.get("/uploads/vehicles/:filename", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      const isAdmin = user.isHqStaff === true;
      const requestedUrl = `/uploads/vehicles/${req.params.filename}`;
      
      // 소유권 검증: 본인 차량 이미지인지 확인
      const vehicle = await storage.getHelperVehicle(userId);
      const isOwner = vehicle?.vehicleImageUrl === requestedUrl;
      
      if (!isAdmin && !isOwner) {
        return res.status(403).json({ message: "접근 권한이 없습니다" });
      }
      
      const filePath = path.join(process.cwd(), "uploads", "vehicles", req.params.filename);
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ message: "파일을 찾을 수 없습니다" });
      }
      
      res.sendFile(filePath);
    } catch (err) {
      res.status(401).json({ message: "Unauthorized" });
    }
  });
  
  // credentials는 관리자 또는 본인만 접근 가능
  app.get("/uploads/credentials/:filename", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      const isAdmin = user.isHqStaff === true;
      const requestedUrl = `/uploads/credentials/${req.params.filename}`;
      
      // 소유권 검증: 본인 credential인지 확인
      if (!isAdmin) {
        const credential = await storage.getHelperCredential(userId);
        const isOwner = 
          credential?.businessImageUrl === requestedUrl ||
          credential?.driverLicenseImageUrl === requestedUrl ||
          credential?.cargoLicenseImageUrl === requestedUrl ||
          credential?.vehicleImageUrl === requestedUrl ||
          credential?.bankbookImageUrl === requestedUrl ||
          credential?.transportContractImageUrl === requestedUrl;
        
        if (!isOwner) {
          return res.status(403).json({ message: "접근 권한이 없습니다" });
        }
      }
      
      const filePath = path.join(process.cwd(), "uploads", "credentials", req.params.filename);
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ message: "파일을 찾을 수 없습니다" });
      }
      
      res.sendFile(filePath);
    } catch (err) {
      res.status(401).json({ message: "Unauthorized" });
    }
  });

  // workproof는 관리자, 업로드한 헬퍼만 접근 가능 (DB에서 소유권 검증)
  // 마감 이미지 서빙 (closing reports)
  // closing 이미지는 디스크에 저장되므로 fs로 직접 서빙 (PII 아님, 공개 서빙)
  app.get("/uploads/closing/:filename", async (req, res) => {
    try {
      const filename = req.params.filename;
      if (!filename || filename.includes("..") || filename.includes("/")) {
        return res.status(400).json({ message: "잘못된 파일명입니다" });
      }
      const filePath = path.join(process.cwd(), "uploads", "closing", filename);
      
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ message: "파일을 찾을 수 없습니다" });
      }
      
      res.sendFile(filePath);
    } catch (error) {
      console.error("Error serving closing image:", error);
      res.status(500).send("Error loading image");
    }
  });

    app.get("/uploads/workproof/:filename", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      const isAdmin = user.isHqStaff === true;
      const requestedUrl = `/uploads/workproof/${req.params.filename}`;
      
      if (!isAdmin) {
        // DB에서 해당 URL의 작업증빙 조회하여 소유권 확인
        const { pool } = await import("./db");
        const result = await pool.query(
          `SELECT helper_id FROM work_proof_events WHERE photo_url = $1 LIMIT 1`,
          [requestedUrl]
        );
        
        if (result.rows.length === 0) {
          // work_confirmations 테이블도 확인
          const confirmResult = await pool.query(
            `SELECT helper_id FROM work_confirmations WHERE proof_image_url = $1 LIMIT 1`,
            [requestedUrl]
          );
          
          if (confirmResult.rows.length === 0) {
            return res.status(404).json({ message: "파일을 찾을 수 없습니다" });
          }
          
          if (confirmResult.rows[0].helper_id !== userId) {
            return res.status(403).json({ message: "접근 권한이 없습니다" });
          }
        } else if (result.rows[0].helper_id !== userId) {
          return res.status(403).json({ message: "접근 권한이 없습니다" });
        }
      }
      
      const filePath = path.join(process.cwd(), "uploads", "workproof", req.params.filename);
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ message: "파일을 찾을 수 없습니다" });
      }
      
      res.sendFile(filePath);
    } catch (err) {
      res.status(401).json({ message: "Unauthorized" });
    }
  });
  
  // orders 이미지는 관리자 또는 해당 오더의 의뢰인만 접근 가능 (DB에서 소유권 검증)
  app.get("/uploads/orders/:filename", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      const isAdmin = user.isHqStaff === true;
      const requestedUrl = `/uploads/orders/${req.params.filename}`;
      
      if (!isAdmin) {
        // DB에서 해당 URL을 가진 오더 조회하여 소유권 확인
        const { pool } = await import("./db");
        const result = await pool.query(
          `SELECT requester_id FROM orders WHERE image_url = $1 LIMIT 1`,
          [requestedUrl]
        );
        
        if (result.rows.length === 0) {
          return res.status(404).json({ message: "파일을 찾을 수 없습니다" });
        }
        
        if (result.rows[0].requester_id !== userId) {
          return res.status(403).json({ message: "접근 권한이 없습니다" });
        }
      }
      
      const filePath = path.join(process.cwd(), "uploads", "orders", req.params.filename);
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ message: "파일을 찾을 수 없습니다" });
      }
      
      res.sendFile(filePath);
    } catch (err) {
      res.status(401).json({ message: "Unauthorized" });
    }
  });

  // Helper terms agreement
  app.post("/api/helper/terms-agreement", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      const { agreements, signatureData, userAgent, consentLog, contractContent } = req.body;
      
      if (!agreements || !signatureData) {
        return res.status(400).json({ message: "모든 약관에 동의하고 서명해주세요" });
      }
      
      const requiredTerms = ["service", "vehicle", "liability", "settlement", "location", "privacy"];
      const allAgreed = requiredTerms.every(term => agreements[term] === true);
      if (!allAgreed) {
        return res.status(400).json({ message: "모든 필수 약관에 동의해주세요" });
      }
      
      if (!signatureData || signatureData.length < 1000) {
        return res.status(400).json({ message: "유효한 전자서명을 입력해주세요" });
      }
      
      const existingAgreement = await storage.getHelperTermsAgreement(userId);
      if (existingAgreement) {
        return res.status(400).json({ message: "이미 약관에 동의하셨습니다" });
      }
      
      // 클라이언트 IP 주소 추출
      const ipAddress = (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() || req.socket.remoteAddress || 'unknown';
      
      const agreement = await storage.createHelperTermsAgreement({
        userId,
        serviceAgreed: true,
        vehicleAgreed: true,
        liabilityAgreed: true,
        settlementAgreed: true,
        locationAgreed: true,
        privacyAgreed: true,
        signatureData,
        ipAddress,
        userAgent: userAgent ?? null,
        consentLog: consentLog ?? null,
        contractContent: contractContent ?? null,
        agreedAt: new Date(),
      });
      
      res.json({ message: "약관 동의가 완료되었습니다", agreement });
    } catch (err) {
      console.error("Terms agreement error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/helper/terms-agreement", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      const agreement = await storage.getHelperTermsAgreement(userId);
      res.json(agreement || null);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // Helper Onboarding APIs (헬퍼 서류 제출/조회)
  // ============================================

  // Helper Credential (기본 정보)
  app.get(api.helpers.getCredential.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const credential = await storage.getHelperCredential(userId);
      if (!credential) {
        return res.status(404).json({ message: "자격증 정보가 없습니다" });
      }
      res.json(credential);
    } catch (err) {
      console.error("Get helper credential error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post(api.helpers.createCredential.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }

      const existing = await storage.getHelperCredential(userId);
      if (existing) {
        return res.status(400).json({ message: "이미 자격증 정보가 등록되어 있습니다" });
      }

      const input = api.helpers.createCredential.input.parse(req.body);
      const credential = await storage.createHelperCredential(userId, input);
      res.status(201).json(credential);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message, field: err.errors[0].path.join(".") });
      }
      console.error("Create helper credential error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch(api.helpers.updateCredential.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const input = api.helpers.updateCredential.input.parse(req.body);
      const credential = await storage.updateHelperCredential(userId, input);
      res.json(credential);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message, field: err.errors[0].path.join(".") });
      }
      console.error("Update helper credential error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper Vehicle (차량 정보)
  app.get(api.helpers.getVehicle.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const vehicle = await storage.getHelperVehicle(userId);
      if (!vehicle) {
        return res.status(404).json({ message: "차량 정보가 없습니다" });
      }
      res.json(vehicle);
    } catch (err) {
      console.error("Get helper vehicle error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post(api.helpers.createVehicle.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }

      const existing = await storage.getHelperVehicle(userId);
      if (existing) {
        // Update existing
        const input = api.helpers.createVehicle.input.parse(req.body);
        const vehicle = await storage.updateHelperVehicle(userId, input);
        return res.json(vehicle);
      }

      const input = api.helpers.createVehicle.input.parse(req.body);
      const vehicle = await storage.createHelperVehicle(userId, input);
      res.status(201).json(vehicle);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message, field: err.errors[0].path.join(".") });
      }
      console.error("Create helper vehicle error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper Business (사업자 정보)
  app.get(api.helpers.getBusiness.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const business = await storage.getHelperBusiness(userId);
      if (!business) {
        return res.status(404).json({ message: "사업자 정보가 없습니다" });
      }
      res.json(business);
    } catch (err) {
      console.error("Get helper business error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post(api.helpers.createBusiness.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }

      const existing = await storage.getHelperBusiness(userId);
      if (existing) {
        const input = api.helpers.createBusiness.input.parse(req.body);
        const business = await storage.updateHelperBusiness(userId, input);
        return res.json(business);
      }

      const input = api.helpers.createBusiness.input.parse(req.body);
      const business = await storage.createHelperBusiness(userId, input);
      res.status(201).json(business);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message, field: err.errors[0].path.join(".") });
      }
      console.error("Create helper business error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper Bank Account (정산 계좌)
  app.get(api.helpers.getBankAccount.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const account = await storage.getHelperBankAccount(userId);
      if (!account) {
        return res.status(404).json({ message: "계좌 정보가 없습니다" });
      }
      res.json(account);
    } catch (err) {
      console.error("Get helper bank account error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post(api.helpers.createBankAccount.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }

      const existing = await storage.getHelperBankAccount(userId);
      if (existing) {
        const input = api.helpers.createBankAccount.input.parse(req.body);
        const account = await storage.updateHelperBankAccount(userId, input);
        return res.json(account);
      }

      const input = api.helpers.createBankAccount.input.parse(req.body);
      const account = await storage.createHelperBankAccount(userId, input);
      res.status(201).json(account);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message, field: err.errors[0].path.join(".") });
      }
      console.error("Create helper bank account error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper License (면허 정보)
  app.get(api.helpers.getLicense.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const license = await storage.getHelperLicense(userId);
      if (!license) {
        return res.status(404).json({ message: "면허 정보가 없습니다" });
      }
      res.json(license);
    } catch (err) {
      console.error("Get helper license error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post(api.helpers.createLicense.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }

      const existing = await storage.getHelperLicense(userId);
      if (existing) {
        const input = api.helpers.createLicense.input.parse(req.body);
        const license = await storage.updateHelperLicense(userId, input);
        return res.json(license);
      }

      const input = api.helpers.createLicense.input.parse(req.body);
      const license = await storage.createHelperLicense(userId, input);
      res.status(201).json(license);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message, field: err.errors[0].path.join(".") });
      }
      console.error("Create helper license error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // Orders List & Application APIs (오더 목록/지원)
  // ============================================

  // GET /api/helper/orders/open - 헬퍼용 공개 오더 목록 (T-04 스펙)
  app.get("/api/helper/orders/open", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ code: "FORBIDDEN", message: "헬퍼만 접근 가능합니다" });
      }

      const { page = "1", limit = "20", region2 } = req.query;
      const pageNum = parseInt(page as string) || 1;
      const limitNum = Math.min(parseInt(limit as string) || 20, 100);
      const offset = (pageNum - 1) * limitNum;

      // OPEN 상태 오더만 조회 (표준 상태 사용)
      let orders = await storage.getAllOrders();
      orders = orders.filter(o => (o.status ?? "").toLowerCase() === "open");

      // 지역 필터
      if (region2) {
        orders = orders.filter(o => o.deliveryArea?.includes(region2 as string));
      }

      // 후보 수 조회 및 헬퍼 지원 상태 조회
      const orderIds = orders.map(o => o.id);
      const candidateCounts = await storage.getOrderCandidateCounts(orderIds);
      const helperStatuses = await storage.getHelperCandidateStatuses(user.id, orderIds);

      // 3명 이상 후보가 찬 오더 필터링 (이미 지원한 오더는 표시)
      const filteredOrders = orders.filter(o => {
        const candidateCount = candidateCounts.get(o.id) || 0;
        const myStatus = helperStatuses.get(o.id);
        if (myStatus) return true;
        if (candidateCount >= 3) return false;
        return true;
      });

      const totalCount = filteredOrders.length;
      const paginatedOrders = filteredOrders.slice(offset, offset + limitNum);

      const items = paginatedOrders.map(o => ({
        id: `o_${o.id}`,
        status: (o.status ?? "").toUpperCase(),
        boxCount: parseInt(o.averageQuantity ?? "0") || 0,
        unitPrice: o.pricePerUnit ?? 0,
        totalAmount: (parseInt(o.averageQuantity ?? "0") || 0) * (o.pricePerUnit ?? 0),
        region2: o.deliveryArea ?? "",
        schedule: {
          startAt: o.scheduledDate || o.createdAt,
          endAt: o.scheduledDateEnd || o.scheduledDate || o.createdAt,
        },
        activeCandidates: candidateCounts.get(o.id) || 0,
        myCandidateStatus: helperStatuses.get(o.id) || null,
      }));

      res.json({ items, page: pageNum, limit: limitNum, totalCount });
    } catch (err) {
      console.error("Get helper open orders error:", err);
      res.status(500).json({ code: "SERVER_ERROR", message: "Internal server error" });
    }
  });

  // GET /api/orders - 헬퍼용 오더 목록 (등록됨/매칭중/예정중 상태만)
  app.get("/api/orders", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { status, category } = req.query;
      const user = req.user!;
      
      // 헬퍼만 접근 가능
      if (user.role !== "helper" && !user.isHqStaff) {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }

      let orders = await storage.getAllOrders(status as string | undefined);
      
      // 헬퍼에게 보여줄 상태만 필터링 (open, scheduled - 표준 상태)
      if (!user.isHqStaff) {
        orders = orders.filter(o => ["open", "scheduled"].includes(o.status ?? ""));
      }

      // 카테고리 필터 (courierCompany 기반)
      if (category && category !== "전체") {
        orders = orders.filter(o => o.courierCompany === category);
      }

      // 후보 수 조회 및 헬퍼 지원 상태 조회 (효율적인 배치 쿼리)
      const orderIds = orders.map(o => o.id);
      const candidateCounts = await storage.getOrderCandidateCounts(orderIds);
      const helperStatuses = await storage.getHelperCandidateStatuses(user.id, orderIds);

      // 3명 이상 후보가 찬 오더 필터링 (이미 지원한 오더는 제외하지 않음)
      // 이미 선택된 오더(scheduled 상태)도 보여주되, 새로운 지원은 제한
      const filteredOrders = orders.filter(o => {
        const candidateCount = candidateCounts.get(o.id) || 0;
        const myStatus = helperStatuses.get(o.id);
        
        // 이미 지원한 오더는 표시
        if (myStatus) return true;
        
        // 3명 이상이면 숨김 (OPEN 상태일 때만)
        if (o.status === "open" && candidateCount >= 3) return false;
        
        return true;
      });

      // 각 오더에 후보 수와 내 지원 상태 추가
      const ordersWithCandidateInfo = filteredOrders.map(o => ({
        ...o,
        activeCandidates: candidateCounts.get(o.id) || 0,
        myCandidateStatus: helperStatuses.get(o.id) || null,
      }));

      res.json(ordersWithCandidateInfo);
    } catch (err) {
      console.error("Get orders error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // POST /api/orders/:id/applications - 헬퍼 오더 지원
  app.post("/api/orders/:id/applications", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = Number(req.params.id);
      const userId = req.user!.id;
      const user = req.user!;

      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 지원할 수 있습니다" });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 지원 가능 상태 확인 (open만 허용 - 표준)
      const applyOrderStatus = normalizeOrderStatus(order.status);
      if (!isOneOfStatus(applyOrderStatus, CAN_APPLY_STATUSES)) {
        return res.status(400).json({ message: "지원할 수 없는 상태입니다" });
      }

      // 중복 지원 확인
      const existingApplications = await storage.getOrderApplications(orderId);
      const alreadyApplied = existingApplications.some(a => a.helperId === userId);
      if (alreadyApplied) {
        return res.status(400).json({ message: "이미 지원한 오더입니다" });
      }

      // A안: 3명 제한 체크 (활성 지원자만 카운트)
      const MAX_APPLICANTS = 3;
      const activeApplications = existingApplications.filter(a => 
        a.status === "applied" || a.status === "selected"
      );
      if (activeApplications.length >= MAX_APPLICANTS) {
        return res.status(409).json({ 
          code: "MAX_APPLICANTS_REACHED",
          message: "지원자 모집이 완료되었습니다 (최대 3명)",
          applicantCount: activeApplications.length
        });
      }

      const { message: applyMessage, expectedArrival } = req.body;
      const application = await storage.createOrderApplication({
        orderId,
        helperId: userId,
        status: "applied",
        message: applyMessage || null,
        expectedArrival: expectedArrival || null,
      });

      // 지원 시 상태 변경 없음 (open 유지) - 지원자 수는 candidates 테이블로 관리

      // 요청자에게 알림 + 푸시 전송
      if (order.requesterId) {
        const currentCount = activeApplications.length + 1;
        await storage.createNotification({
          userId: order.requesterId,
          type: "helper_applied",
          title: "새로운 지원자",
          message: `${user.name || "헬퍼"}님이 오더에 지원했습니다. (${currentCount}/3)`,
          relatedId: orderId,
        });
        
        // 푸시 알림 발송
        sendPushToUser(order.requesterId, {
          title: "새로운 지원자",
          body: `${user.name || "헬퍼"}님이 ${order.companyName || ''} 오더에 지원했습니다. (${currentCount}/3)`,
          url: `/orders/${orderId}/applicants`,
          tag: `application-${orderId}`,
        });
      }

      res.status(201).json(application);
    } catch (err) {
      console.error("Apply to order error:", err);
      res.status(500).json({ message: "지원에 실패했습니다" });
    }
  });

  // GET /api/orders/my-applications - 헬퍼 본인 지원 내역 (오더 정보 포함)
  app.get("/api/orders/my-applications", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const applications = await storage.getHelperApplications(userId);
      
      // 각 지원에 오더 상세 정보 포함
      const applicationsWithOrders = await Promise.all(
        applications.map(async (app) => {
          const order = await storage.getOrder(app.orderId);
          return {
            ...app,
            order: order || null,
          };
        })
      );
      
      res.json(applicationsWithOrders);
    } catch (err) {
      console.error("Get my applications error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // GET /api/orders/:id/closing-report - 마감자료 조회
  app.get("/api/orders/:id/closing-report", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = Number(req.params.id);
      const user = req.user!;

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 권한 확인: 요청자, 헬퍼, 관리자만 조회 가능
      const isOwner = order.requesterId === user.id || order.matchedHelperId === user.id;
      const isAdmin = user.isHqStaff;
      if (!isOwner && !isAdmin) {
        return res.status(403).json({ message: "조회 권한이 없습니다" });
      }

      const [report] = await db.select()
        .from(closingReports)
        .where(eq(closingReports.orderId, orderId))
        .limit(1);

      if (!report) {
        return res.json(null);
      }

      res.json(report);
    } catch (err) {
      console.error("Get closing report error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // POST /api/orders/:id/closing-report - 헬퍼 마감자료 제출 (E2E-07 핵심)
  // GET /api/closing-fields - 마감 필드 설정 조회 (모바일 앱용)
  app.get("/api/closing-fields", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const role = user.role;
      
      const allFields = await db.select().from(closingFieldSettings)
        .where(eq(closingFieldSettings.isActive, true))
        .orderBy(closingFieldSettings.sortOrder);
      
      // Filter by target role
      const fields = allFields.filter(f => 
        f.targetRole === 'both' || f.targetRole === role
      );
      
      res.json(fields);
    } catch (err) {
      console.error("Get closing fields error:", err);
      res.status(500).json({ message: "마감 필드를 불러오는데 실패했습니다" });
    }
  });

  // POST /api/orders/:id/close - 헬퍼 마감 제출 (집배송 이력 이미지 필수)
  app.post("/api/orders/:orderId/close", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = Number(req.params.orderId);
      const user = req.user!;

      // Idempotency check
      const idempotencyKey = getIdempotencyKeyFromRequest(req);
      if (idempotencyKey) {
        const { isDuplicate, cachedResponse } = await checkIdempotency(
          user.id,
          `POST:/api/orders/${orderId}/close`,
          idempotencyKey
        );
        if (isDuplicate && cachedResponse) {
          console.log(`[Idempotency] Returning cached close for order ${orderId}, key: ${idempotencyKey}`);
          return res.status(cachedResponse.status).json(cachedResponse.body);
        }
      }

      if (user.role !== "helper") {
        return res.status(403).json({ code: "FORBIDDEN", message: "헬퍼만 마감을 제출할 수 있습니다" });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ code: "NOT_FOUND", message: "오더를 찾을 수 없습니다" });
      }

      if (order.matchedHelperId !== user.id) {
        return res.status(403).json({ code: "NOT_ASSIGNED", message: "배정된 헬퍼만 마감을 제출할 수 있습니다" });
      }

      // 업무중 상태에서만 마감 제출 가능 (in_progress만 허용 - 표준)
      const orderStatusForClose = normalizeOrderStatus(order.status);
      if (!isOneOfStatus(orderStatusForClose, CAN_SUBMIT_CLOSING_STATUSES)) {
        return res.status(400).json({ 
          code: "INVALID_STATUS", 
          message: `현재 상태(${order.status})에서는 마감을 제출할 수 없습니다. 업무중 상태에서만 가능합니다.` 
        });
      }

      const { text, deliveryHistoryImages, etcImages, deliveredCount, returnedCount, etcCount, extraCosts, memo, dynamicFields } = req.body;

      // 배송 수량은 필수
      if (deliveredCount === undefined || deliveredCount === null || parseInt(deliveredCount) < 0) {
        return res.status(400).json({ code: "INVALID_INPUT", message: "배송 수량을 입력해주세요" });
      }

      // 텍스트는 선택사항
      if (text && text.length > 2000) {
        return res.status(400).json({ code: "INVALID_INPUT", message: "마감 내용은 2000자 이하로 입력해주세요" });
      }

      if (!deliveryHistoryImages || !Array.isArray(deliveryHistoryImages) || deliveryHistoryImages.length === 0) {
        return res.status(400).json({ 
          code: "DELIVERY_HISTORY_REQUIRED", 
          message: "집배송 이력 화면 캡쳐 또는 사진이 반드시 필요합니다.\n분쟁 방지를 위한 필수 자료입니다." 
        });
      }

      const contracts = await storage.getOrderContracts(orderId);
      const contract = contracts.find(c => c.helperId === user.id);

      // 통합 계산 모듈 사용 (Single Source of Truth)
      const parsedDeliveredCount = parseInt(deliveredCount) || 0;
      const parsedReturnedCount = parseInt(returnedCount) || 0;
      const parsedEtcCount = parseInt(etcCount) || 0;
      
      // 기타 단가: 주문에 연결된 택배사 설정에서 가져오기
      let etcPricePerUnitValue = 0;
      if (parsedEtcCount > 0) {
        const orderCourierSettings = await storage.getAllCourierSettings();
        const orderCourier = orderCourierSettings.find(c => c.courierName === order.companyName);
        etcPricePerUnitValue = orderCourier?.etcPricePerBox || 0;
      }
      
      // 통합 계산 함수 사용
      const closingData = {
        deliveredCount: parsedDeliveredCount,
        returnedCount: parsedReturnedCount,
        etcCount: parsedEtcCount,
        unitPrice: order.pricePerUnit ?? 0,
        etcPricePerUnit: etcPricePerUnitValue,
        extraCosts: extraCosts || [],
      };
      const settlement = calculateSettlement(closingData);
      const calculatedAmount = settlement.totalAmount;

      // 플랫폼 수수료율 가져오기 (운임설정에서 운송사명으로 조회)
      const allCourierSettings = await storage.getAllCourierSettings();
      const courierSetting = allCourierSettings.find(c => c.courierName === order.companyName || c.courierName === order.courierCompany);
      // 운임설정에 없으면 수수료 0 (설정된 수수료만 적용)
      const snapshotFeeRate = courierSetting?.commissionRate ? courierSetting.commissionRate * 100 : 0; // bps로 변환 (% * 100)
      const snapshotPlatformFee = Math.floor(settlement.supplyAmount * snapshotFeeRate / 10000);
      const snapshotNetAmount = settlement.supplyAmount - snapshotPlatformFee;
      
      // 정책 스냅샷 저장
      const pricingSnapshot = {
        unitPrice: order.pricePerUnit,
        etcPricePerUnit: etcPricePerUnitValue,
        platformFeeRate: snapshotFeeRate,
        courierCategory: order.courierCategory || "standard",
        capturedAt: new Date().toISOString(),
      };

      const closingReport = await db.insert(closingReports).values({
        orderId,
        helperId: user.id,
        contractId: contract?.id || null,
        deliveredCount: parsedDeliveredCount,
        etcCount: parsedEtcCount,
        etcPricePerUnit: etcPricePerUnitValue,
        returnedCount: parsedReturnedCount,
        extraCostsJson: extraCosts ? JSON.stringify(extraCosts) : null,
        memo: memo || text?.trim() || null,
        status: "submitted",
        calculatedAmount,
        // 정산 스냅샷 필드 (SSOT)
        supplyAmount: settlement.supplyAmount,
        vatAmount: settlement.vatAmount,
        totalAmount: settlement.totalAmount,
        platformFeeRate: snapshotFeeRate,
        platformFee: snapshotPlatformFee,
        netAmount: snapshotNetAmount,
        pricingSnapshotJson: JSON.stringify(pricingSnapshot),
        deliveryHistoryImagesJson: JSON.stringify(deliveryHistoryImages),
        etcImagesJson: etcImages ? JSON.stringify(etcImages) : null,
        dynamicFieldsJson: dynamicFields ? JSON.stringify(dynamicFields) : null,
      }).returning();

      await storage.updateOrder(orderId, { status: "closing_submitted" });

      // T-07: 계약이 있으면 최종금액/잔금 업데이트 (closing-report와 동일한 로직)
      if (contract) {
        const downPaymentAmount = contract.depositAmount || contract.downPaymentAmount || 0;
        const balanceAmount = Math.max(0, calculatedAmount - downPaymentAmount);
        
        await storage.updateContract(contract.id, {
          finalAmount: calculatedAmount,
          balanceAmount,
          calculatedBalanceAmount: balanceAmount,
          closingReportId: closingReport[0].id,
        });
      }

      if (order.requesterId) {
        await storage.createNotification({
          userId: order.requesterId,
          type: "matching_success",
          title: "마감 제출",
          message: `${user.name || "헬퍼"}님이 마감을 제출했습니다. 확인해주세요.`,
          relatedId: orderId,
        });
        
        // 푸시 알림 발송
        sendPushToUser(order.requesterId, {
          title: "마감 제출",
          body: `${user.name || "헬퍼"}님이 마감을 제출했습니다. 확인해주세요.`,
          url: `/closing/${orderId}`,
          tag: `closing-submitted-${orderId}`,
        });
      }

      // 예상 정산금 계산 (snapshotCommissionRate 사용)
      const application = await db.select().from(orderApplications)
        .where(and(
          eq(orderApplications.orderId, orderId),
          eq(orderApplications.helperId, user.id)
        ))
        .limit(1);
      const platformFeeRate = application[0]?.snapshotCommissionRate ?? order.snapshotCommissionRate ?? 3;
      const estimatedPlatformFee = Math.round(calculatedAmount * (platformFeeRate / 100));
      const estimatedPayout = calculatedAmount - estimatedPlatformFee;
      
      const depositAmount = contract?.depositAmount || contract?.downPaymentAmount || 0;
      const balanceAmount = Math.max(0, calculatedAmount - depositAmount);

      const closeResponse = {
        success: true,
        closingReportId: closingReport[0].id,
        calculatedAmount,
        depositAmount,
        balanceAmount,
        platformFeeRate,
        estimatedPlatformFee,
        estimatedPayout,
      };

      // Store idempotency response
      if (idempotencyKey) {
        await storeIdempotencyResponse(user.id, `POST:/api/orders/${orderId}/close`, idempotencyKey, 201, closeResponse);
      }

      res.status(201).json(closeResponse);
    } catch (err) {
      console.error("Submit closing error:", err);
      res.status(500).json({ code: "SERVER_ERROR", message: "마감 제출에 실패했습니다" });
    }
  });
  // POST /api/upload/closing-image - 마감 이미지 업로드
  const closingImagesDir = path.join(process.cwd(), "uploads", "closing");

  if (!fs.existsSync(closingImagesDir)) {
    fs.mkdirSync(closingImagesDir, { recursive: true });
  }
  const uploadClosingImage = multer({
    storage: multer.diskStorage({
      destination: (_req, _file, cb) => cb(null, closingImagesDir),
      filename: (_req, file, cb) => {
        const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
        const ext = path.extname(file.originalname) || '.jpg';
        cb(null, uniqueSuffix + ext);
      },
    }),
    limits: { fileSize: 10 * 1024 * 1024 },
    fileFilter: (_req, file, cb) => {
      const allowedMimeTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'application/octet-stream'];
      const allowedExtensions = /\.(jpeg|jpg|png|webp)$/i;
      const hasValidMime = allowedMimeTypes.includes(file.mimetype);
      const hasValidExt = allowedExtensions.test(file.originalname);
      if (hasValidMime || hasValidExt) cb(null, true);
      else cb(new Error("이미지 파일만 업로드 가능합니다 (jpg, png, webp)"));
    },
  });

  app.post("/api/upload/closing-image", requireAuth, uploadClosingImage.single('file'), async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const file = req.file;
      const imageType = req.body.imageType || 'ETC';

      if (!file) {
        return res.status(400).json({ message: "파일이 필요합니다" });
      }

      const imageUrl = `/uploads/closing/${file.filename}`;
      
      res.json({
        success: true,
        fileKey: imageUrl,
        imageType,
        fileName: file.originalname,
        fileSize: file.size,
      });
    } catch (err) {
      console.error("Upload closing image error:", err);
      res.status(500).json({ message: "이미지 업로드에 실패했습니다" });
    }
  });

  // 범용 증빙 이미지 업로드 API
  app.post("/api/upload/evidence", requireAuth, uploadClosingImage.single('file'), async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "로그인이 필요합니다" });
      }

      if (!req.file) {
        return res.status(400).json({ message: "파일이 필요합니다" });
      }

      const { category, referenceId, referenceType } = req.body;
      
      const validCategories = ['incident', 'dispute', 'closing', 'work_proof', 'contract', 'general'];
      if (category && !validCategories.includes(category)) {
        return res.status(400).json({ message: "유효하지 않은 카테고리입니다" });
      }

      const validReferenceTypes = ['order', 'contract', 'settlement', 'incident', 'dispute', 'closing_report'];
      if (referenceType && !validReferenceTypes.includes(referenceType)) {
        return res.status(400).json({ message: "유효하지 않은 참조 유형입니다" });
      }

      const file = req.file as Express.Multer.File & { key?: string; location?: string };
      const path = file.key || file.path || file.filename;
      const url = file.location || `/uploads/${path}`;

      console.log(`[Evidence Upload] User ${userId} uploaded ${category || 'general'} image: ${path}`);

      res.json({
        success: true,
        url,
        path,
        category: category || 'general',
        referenceId: referenceId || null,
        referenceType: referenceType || null,
        uploadedAt: new Date().toISOString(),
      });
    } catch (err) {
      console.error("[Evidence Upload] Error:", err);
      res.status(500).json({ message: "파일 업로드에 실패했습니다" });
    }
  });




  // Profile image upload directory
  const profileImagesDir = path.join(process.cwd(), "uploads", "profiles");
  if (!fs.existsSync(profileImagesDir)) {
    fs.mkdirSync(profileImagesDir, { recursive: true });
  }

  const uploadProfileImage = multer({
    storage: multer.diskStorage({
      destination: (_req, _file, cb) => cb(null, profileImagesDir),
      filename: (_req, file, cb) => {
        const uniqueSuffix = Date.now() + "-" + Math.round(Math.random() * 1e9);
        const ext = path.extname(file.originalname) || '.jpg';
        cb(null, uniqueSuffix + ext);
      },
    }),
    limits: { fileSize: 5 * 1024 * 1024 },
    fileFilter: (_req, file, cb) => {
      const allowedMimeTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/webp', 'application/octet-stream'];
      const allowedExtensions = /\.(jpeg|jpg|png|webp)$/i;
      const hasValidMime = allowedMimeTypes.includes(file.mimetype);
      const hasValidExt = allowedExtensions.test(file.originalname);
      if (hasValidMime || hasValidExt) cb(null, true);
      else cb(new Error("이미지 파일만 업로드 가능합니다 (jpg, png, webp)"));
    },
  });

  // Profile image upload API
  app.post("/api/upload/profile-image", requireAuth, uploadProfileImage.single('file'), async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "로그인이 필요합니다" });
      }

      if (!req.file) {
        return res.status(400).json({ message: "파일이 필요합니다" });
      }

      const file = req.file as Express.Multer.File & { key?: string; location?: string };
      const filePath = file.key || file.filename;
      const url = `/uploads/profiles/${filePath}`;

      // Update user's profile image URL
      await db.update(users).set({
        profileImageUrl: url,
      }).where(eq(users.id, userId));

      console.log(`[Profile Image Upload] User ${userId} uploaded profile image: ${url}`);

      res.json({
        success: true,
        url,
        uploadedAt: new Date().toISOString(),
      });
    } catch (err) {
      console.error("[Profile Image Upload] Error:", err);
      res.status(500).json({ message: "파일 업로드에 실패했습니다" });
    }
  });

  // Get user profile with image
  app.get("/api/user/profile-image", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user?.id;
      if (!userId) {
        return res.status(401).json({ message: "로그인이 필요합니다" });
      }

      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "사용자를 찾을 수 없습니다" });
      }

      res.json({
        profileImageUrl: (user as any).profileImageUrl || null,
      });
    } catch (err) {
      console.error("[Get Profile Image] Error:", err);
      res.status(500).json({ message: "프로필 이미지 조회에 실패했습니다" });
    }
  });



  // GET /api/orders/:orderId/closing-summary - 요청자용 마감 요약 조회 (잔금 포함)
  app.get("/api/orders/:orderId/closing-summary", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = Number(req.params.orderId);
      const user = req.user!;

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      const isOwner = order.requesterId === user.id || order.matchedHelperId === user.id;
      if (!isOwner && !user.isHqStaff) {
        return res.status(403).json({ message: "조회 권한이 없습니다" });
      }

      const [report] = await db.select()
        .from(closingReports)
        .where(eq(closingReports.orderId, orderId))
        .limit(1);

      const contracts = await storage.getOrderContracts(orderId);
      const contract = contracts[0];

      const deliveryHistoryImages = report?.deliveryHistoryImagesJson 
        ? JSON.parse(report.deliveryHistoryImagesJson) 
        : [];
      const etcImages = report?.etcImagesJson 
        ? JSON.parse(report.etcImagesJson) 
        : [];

      const paymentProvider = process.env.PAYMENT_PROVIDER || "mock";
      const isManualPayment = paymentProvider === "mock";
      
      // SSOT: 스냅샷 값 우선 사용, 없으면 재계산
      let deliveredCount: number, returnedCount: number, etcCount: number;
      let etcPricePerUnit: number, etcAmount: number;
      let supplyAmount: number, vatAmount: number, totalAmount: number;
      
      if (report?.supplyAmount && report?.totalAmount) {
        // 스냅샷 값 사용
        deliveredCount = report.deliveredCount || 0;
        returnedCount = report.returnedCount || 0;
        etcCount = report.etcCount || 0;
        etcPricePerUnit = report.etcPricePerUnit || 1800;
        etcAmount = etcCount * etcPricePerUnit;
        supplyAmount = report.supplyAmount;
        vatAmount = report.vatAmount || 0;
        totalAmount = report.totalAmount;
      } else {
        // 레거시: 재계산
        const pricePerUnit = order.pricePerUnit || 0;
        const closingData = report ? parseClosingReport(report, order) : {
          deliveredCount: 0,
          returnedCount: 0,
          etcCount: 0,
          unitPrice: pricePerUnit,
          etcPricePerUnit: 1800,
          extraCosts: [],
        };
        const settlement = calculateSettlement(closingData);
        
        deliveredCount = settlement.deliveredCount;
        returnedCount = settlement.returnedCount;
        etcCount = settlement.etcCount;
        etcPricePerUnit = closingData.etcPricePerUnit;
        etcAmount = settlement.etcAmount;
        supplyAmount = settlement.supplyAmount;
        vatAmount = settlement.vatAmount;
        totalAmount = settlement.totalAmount;
      }
      
      // 계약금은 SSOT 함수 사용, 잔금은 최종금액에서 계약금 차감
      const depositInfo = await getOrderDepositInfo(orderId);
      const depositAmount = depositInfo.depositAmount;
      const depositStatus = depositInfo.paymentStatus;
      const balanceAmount = Math.max(0, totalAmount - depositAmount);
      const balanceStatus = contract?.balancePaymentStatus || "UNPAID";
      
      const response: any = {
        orderId: order.orderNumber || `O-${orderId}`,
        // 프론트엔드 호환 필드명
        helperClosingText: report?.memo || null,
        closingText: report?.memo || null,
        closingStatus: report?.status || null,
        submittedAt: report?.createdAt || null,
        // 배송/반품/기타 수량
        deliveredCount: deliveredCount,
        returnedCount: returnedCount,
        etcCount: etcCount,
        etcPricePerUnit: etcPricePerUnit,
        etcAmount: etcAmount,
        // 이미지 (프론트엔드 호환)
        deliveryHistoryImages: deliveryHistoryImages,
        etcImages: etcImages,
        deliveryHistoryAttachments: deliveryHistoryImages.map((url: string) => ({
          fileKey: url,
          url: url,
        })),
        etcAttachments: etcImages.map((url: string) => ({
          fileKey: url,
          url: url,
        })),
        // 금액 정보 (배송+반품+기타 포함, 부가세 포함)
        pricePerUnit: order.pricePerUnit || 0,
        supplyAmount: supplyAmount,
        vatAmount: vatAmount,
        totalAmount: totalAmount,
        depositAmount: depositAmount,
        balanceAmount: balanceAmount,
        balanceStatus: balanceStatus,
        finalAmount: contract?.finalAmount || totalAmount,
        paymentMode: isManualPayment ? "MANUAL_TRANSFER" : "AUTO_PAYMENT",
      };
      
      if (isManualPayment && balanceStatus !== "PAID") {
        response.bankInfo = {
          bankName: process.env.COMPANY_BANK_NAME || "우리은행",
          account: process.env.COMPANY_BANK_ACCOUNT || "1002-xxx-xxxxxx",
          holder: process.env.COMPANY_BANK_HOLDER || "더리슨",
        };
        response.payerNameRule = `입금자명에 ${order.orderNumber || `O-${orderId}`} 포함`;
      }

      res.json(response);
    } catch (err) {
      console.error("Get closing summary error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // POST /api/orders/:orderId/balance/notify - 입금 완료 알림 (요청자가 입금 완료했음을 관리자에게 알림)
  app.post("/api/orders/:orderId/balance/notify", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = Number(req.params.orderId);
      const user = req.user!;
      const { message } = req.body;

      if (user.role !== "requester") {
        return res.status(403).json({ error: { code: "FORBIDDEN", message: "요청자만 입금 완료 알림을 보낼 수 있습니다" } });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ error: { code: "NOT_FOUND", message: "오더를 찾을 수 없습니다" } });
      }

      if (order.requesterId !== user.id) {
        return res.status(403).json({ error: { code: "FORBIDDEN", message: "본인 오더에만 입금 알림을 보낼 수 있습니다" } });
      }

      const admins = await db
        .select()
        .from(users)
        .where(inArray(users.role, ["admin", "superadmin"]))
        .limit(10);

      for (const admin of admins) {
        await storage.createNotification({
          userId: admin.id,
          type: "system" as any,
          title: "입금 완료 알림",
          message: `요청자(${user.name || user.email})가 오더 ${order.orderNumber || orderId}에 대해 입금 완료를 알렸습니다. ${message || ""}`,
          relatedId: orderId,
        });
      }

      console.log(`[Balance Notify] Requester ${user.id} notified payment for order ${orderId}`);

      res.json({
        ok: true,
        orderId: order.orderNumber || `O-${orderId}`,
        message: "입금 알림이 관리자에게 전송되었습니다",
      });
    } catch (err) {
      console.error("Balance notify error:", err);
      res.status(500).json({ error: { code: "INTERNAL_ERROR", message: "서버 오류가 발생했습니다" } });
    }
  });

  // T-09: POST /api/orders/:orderId/closing/confirm - 요청자 마감 확인

  // POST /api/orders/:orderId/send-account-sms - 계좌번호 문자 전송
  app.post("/api/orders/:orderId/send-account-sms", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = Number(req.params.orderId);
      const user = req.user!;

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ error: { code: "NOT_FOUND", message: "오더를 찾을 수 없습니다" } });
      }

      // 요청자 본인만 가능
      if (order.requesterId !== user.id) {
        return res.status(403).json({ error: { code: "FORBIDDEN", message: "본인 오더만 요청 가능합니다" } });
      }

      // 요청자 전화번호 조회
      const requester = await storage.getUser(user.id);
      if (!requester?.phoneNumber) {
        return res.status(400).json({ error: { code: "NO_PHONE", message: "등록된 전화번호가 없습니다" } });
      }

      // 계약 정보 조회 (잔금 금액)
      const contracts = await storage.getOrderContracts(orderId);
      const contract = contracts[0];
      const balanceAmount = contract?.calculatedBalanceAmount || contract?.balanceAmount || 0;

      // 계좌번호 문자 전송
      const accountInfo = "신한은행 110-123-456789 (주)헬프미";
      const message = `[헬프미] 잔금 ${balanceAmount.toLocaleString()}원 입금 안내\n\n${accountInfo}\n\n입금 후 앱에서 입금완료 버튼을 눌러주세요.`;
      
      const smsResult = await smsService.sendCustomMessage(requester.phoneNumber, message);
      
      if (smsResult.success) {
        res.json({ 
          ok: true, 
          message: "계좌번호가 문자로 전송되었습니다",
          accountInfo,
        });
      } else {
        res.status(500).json({ error: { code: "SMS_FAILED", message: "문자 전송에 실패했습니다" } });
      }
    } catch (err) {
      console.error("Send account SMS error:", err);
      res.status(500).json({ error: { code: "INTERNAL_ERROR", message: "서버 오류가 발생했습니다" } });
    }
  });
  app.post("/api/orders/:orderId/closing/confirm", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = Number(req.params.orderId);
      const user = req.user!;

      // 요청자 또는 관리자만 확인 가능
      if (user.role !== "requester" && !user.isHqStaff) {
        return res.status(403).json({ error: { code: "FORBIDDEN", message: "요청자만 마감을 확인할 수 있습니다" } });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ error: { code: "NOT_FOUND", message: "오더를 찾을 수 없습니다" } });
      }

      // 요청자 본인 확인
      if (user.role === "requester" && order.requesterId !== user.id) {
        return res.status(403).json({ error: { code: "FORBIDDEN", message: "본인 오더만 확인할 수 있습니다" } });
      }

      // closing_submitted 상태에서만 확인 가능 (표준)
      const closingOrderStatus = normalizeOrderStatus(order.status);
      if (!isOneOfStatus(closingOrderStatus, CAN_APPROVE_CLOSING_STATUSES)) {
        return res.status(400).json({ 
          error: { 
            code: "INVALID_STATUS", 
            message: `현재 상태(${order.status})에서는 마감 확인을 할 수 없습니다. 마감 제출 상태에서만 가능합니다.` 
          } 
        });
      }

      // 오더 상태 변경: closing_submitted → final_amount_confirmed
      await storage.updateOrder(orderId, { status: ORDER_STATUS.FINAL_AMOUNT_CONFIRMED });

      // 오더 상태 이벤트 기록
      await storage.createOrderStatusEvent({
        orderId,
        previousStatus: ORDER_STATUS.CLOSING_SUBMITTED,
        newStatus: ORDER_STATUS.FINAL_AMOUNT_CONFIRMED,
        reason: "요청자 마감 확인",
        triggerType: "closing_confirmed",
        triggeredBy: user.id,
      });

      // 헬퍼에게 알림
      if (order.matchedHelperId) {
        await storage.createNotification({
          userId: order.matchedHelperId,
          type: "matching_success",
          title: "마감 확인 완료",
          message: `${order.companyName} 오더의 마감이 확인되었습니다. 잔금 입금 후 정산이 진행됩니다.`,
          relatedId: orderId,
        });
      }

      res.json({
        ok: true,
        orderId: order.orderNumber || `O-${orderId}`,
        status: "final_amount_confirmed",
        message: "마감이 확인되었습니다",
      });
    } catch (err) {
      console.error("Closing confirm error:", err);
      res.status(500).json({ error: { code: "INTERNAL_ERROR", message: "서버 오류가 발생했습니다" } });
    }
  });

  // T-10: POST /api/orders/:orderId/balance/confirm - 잔금 확인 (수동 결제용)
  app.post("/api/orders/:orderId/balance/confirm", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = Number(req.params.orderId);
      const user = req.user!;

      // 요청자 또는 관리자만 확인 가능
      if (user.role !== "requester" && !user.isHqStaff) {
        return res.status(403).json({ error: { code: "FORBIDDEN", message: "잔금 확인 권한이 없습니다" } });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ error: { code: "NOT_FOUND", message: "오더를 찾을 수 없습니다" } });
      }

      // 요청자 본인 확인 (관리자는 예외)
      if (user.role === "requester" && order.requesterId !== user.id) {
        return res.status(403).json({ error: { code: "FORBIDDEN", message: "본인 오더만 확인할 수 있습니다" } });
      }

      // final_amount_confirmed 상태에서만 잔금 확인 가능 (표준 상태)
      const balanceOrderStatus = normalizeOrderStatus(order.status);
      if (!isOneOfStatus(balanceOrderStatus, CAN_CONFIRM_BALANCE_STATUSES)) {
        return res.status(400).json({ 
          error: { 
            code: "INVALID_STATUS", 
            message: `현재 상태(${order.status})에서는 잔금 확인을 할 수 없습니다. 마감 승인 후 잔금 확인이 가능합니다.` 
          } 
        });
      }

      // 오더 상태 변경: → balance_paid
      await storage.updateOrder(orderId, { status: ORDER_STATUS.BALANCE_PAID });

      // 계약 잔금 상태 업데이트
      const contracts = await storage.getOrderContracts(orderId);
      const contract = contracts[0];
      if (contract) {
        await storage.updateContract(contract.id, {
          balancePaid: true,
          balancePaidAt: new Date(),
          balancePaymentStatus: "PAID",
        });
      }

      // 오더 상태 이벤트 기록
      await storage.createOrderStatusEvent({
        orderId,
        previousStatus: order.status ?? "final_amount_confirmed",
        newStatus: "balance_paid",
        reason: user.isHqStaff ? "관리자 잔금 확인" : "요청자 잔금 확인",
        triggerType: "balance_confirmed",
        triggeredBy: user.id,
      });

      // 헬퍼에게 알림
      if (order.matchedHelperId) {
        await storage.createNotification({
          userId: order.matchedHelperId,
          type: "matching_success",
          title: "잔금 입금 확인",
          message: `${order.companyName} 오더의 잔금이 확인되었습니다. 곧 정산이 진행됩니다.`,
          relatedId: orderId,
        });
      }

      res.json({
        ok: true,
        orderId: order.orderNumber || `O-${orderId}`,
        status: "balance_paid",
        message: "잔금이 확인되었습니다",
      });
    } catch (err) {
      console.error("Balance confirm error:", err);
      res.status(500).json({ error: { code: "INTERNAL_ERROR", message: "서버 오류가 발생했습니다" } });
    }
  });

  // POST /api/orders/:orderId/incident - 화물사고 접수 (요청자 전용)
  app.post("/api/orders/:orderId/incident", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = Number(req.params.orderId);
      const user = req.user!;

      if (user.role !== "requester") {
        return res.status(403).json({ code: "FORBIDDEN", message: "요청자만 화물사고를 접수할 수 있습니다" });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ code: "NOT_FOUND", message: "오더를 찾을 수 없습니다" });
      }

      if (order.requesterId !== user.id) {
        return res.status(403).json({ code: "FORBIDDEN", message: "본인 오더에만 사고를 접수할 수 있습니다" });
      }

      const { type, description, additionalInfo, trackingNumber, deliveryAddress, customerName, customerPhone, attachedImages } = req.body;

      const validTypes = ['damage', 'loss', 'misdelivery', 'delay', 'other'];
      if (!type || !validTypes.includes(type)) {
        return res.status(400).json({ code: "INVALID_INPUT", message: "유효한 사고 유형을 선택해주세요" });
      }

      if (!description || description.trim().length < 10) {
        return res.status(400).json({ code: "INVALID_INPUT", message: "사고 내용은 10자 이상 입력해주세요" });
      }

      if (!trackingNumber || trackingNumber.trim().length === 0) {
        return res.status(400).json({ code: "INVALID_INPUT", message: "송장번호를 입력해주세요" });
      }

      if (!deliveryAddress || deliveryAddress.trim().length === 0) {
        return res.status(400).json({ code: "INVALID_INPUT", message: "배송지 주소를 입력해주세요" });
      }

      if (!customerName || customerName.trim().length === 0) {
        return res.status(400).json({ code: "INVALID_INPUT", message: "수하인 이름을 입력해주세요" });
      }

      if (!customerPhone || customerPhone.trim().length === 0) {
        return res.status(400).json({ code: "INVALID_INPUT", message: "수하인 연락처를 입력해주세요" });
      }

      const incident = await storage.createIncidentReport({
        orderId,
        reporterId: user.id,
        reporterType: 'requester',
        requesterId: user.id,
        helperId: order.matchedHelperId || null,
        incidentDate: new Date().toISOString().split("T")[0],
        incidentType: type,
        description: description.trim(),
        trackingNumber: trackingNumber.trim(),
        deliveryAddress: deliveryAddress.trim(),
        customerName: customerName.trim(),
        customerPhone: customerPhone.trim(),
        status: "requested",
      });
      // 마감 시 첨부된 집배송 이력 이미지를 사고 증빙으로 저장
      if (Array.isArray(attachedImages) && attachedImages.length > 0) {
        for (const imageUrl of attachedImages) {
          await db.insert(incidentEvidence).values({
            incidentId: incident.id,
            evidenceType: 'delivery_history',
            fileUrl: imageUrl,
            description: '마감 시 제출된 집배송 이력 이미지 (자동 첨부)',
            uploadedBy: user.id,
          });
        }
      }

      // 헬퍼에게 알림 + 푸시 (matchedHelperId만 사용 - 표준)
      if (order.matchedHelperId) {
        await storage.createNotification({
          userId: order.matchedHelperId,
          type: "order_update" as any,
          title: "화물사고 접수",
          message: `${user.name || "요청자"}님이 화물사고를 접수했습니다. 확인해주세요.`,
          relatedId: orderId,
        });
        
        sendPushToUser(order.matchedHelperId, {
          title: "화물사고 접수",
          body: `${order.companyName} 오더에 화물사고가 접수되었습니다.`,
          url: `/orders/${orderId}/incident`,
          tag: `incident-${incident.id}`,
        });
      }

      res.status(201).json({
        success: true,
        incidentId: incident.id,
        status: "submitted",
        attachedImagesCount: Array.isArray(attachedImages) ? attachedImages.length : 0,
      });
    } catch (err) {
      console.error("Submit incident error:", err);
      res.status(500).json({ code: "SERVER_ERROR", message: "사고 접수에 실패했습니다" });
    }
  });

  // GET /api/incidents - 화물사고 목록 조회
  app.get("/api/incidents", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const incidents = await storage.getIncidentReportsByUser(user.id);
      res.json(incidents);
    } catch (err) {
      console.error("Get incidents error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // GET /api/incidents/:id - 요청자 사고 상세 조회
  app.get("/api/incidents/:id", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const incidentId = Number(req.params.id);
      
      const [incident] = await db.select()
        .from(incidentReports)
        .where(eq(incidentReports.id, incidentId));
      
      if (!incident) {
        return res.status(404).json({ message: "사고를 찾을 수 없습니다" });
      }
      
      // 권한 검증: 본인이 신고한 사고만 조회 가능
      if (incident.requesterId !== user.id && incident.reporterId !== user.id) {
        return res.status(403).json({ message: "접근 권한이 없습니다" });
      }
      
      // 오더 정보 조회
      let order = null;
      if (incident.orderId) {
        const [orderData] = await db.select({
          id: orders.id,
          campAddress: orders.campAddress,
          deliveryArea: orders.deliveryArea,
          scheduledDate: orders.scheduledDate,
          courierCompany: orders.courierCompany,
          averageQuantity: orders.averageQuantity,
          pricePerUnit: orders.pricePerUnit,
        }).from(orders).where(eq(orders.id, incident.orderId));
        order = orderData;
      }
      
      // 헬퍼 정보 조회
      let helper = null;
      if (incident.helperId) {
        const [helperData] = await db.select({
          id: users.id,
          name: users.name,
          nickname: users.nickname,
          phone: users.phone,
        }).from(users).where(eq(users.id, incident.helperId));
        helper = helperData;
      }
      
      // 증빙 사진 조회
      const evidenceRows = await db.select()
        .from(incidentEvidence)
        .where(eq(incidentEvidence.incidentId, incidentId));
      
      // 응답 포맷
      res.json({
        id: incident.id,
        orderId: incident.orderId,
        incidentType: incident.incidentType,
        incidentDate: incident.incidentDate,
        description: incident.description,
        status: incident.status,
        trackingNumber: incident.trackingNumber,
        deliveryAddress: incident.deliveryAddress,
        customerName: incident.customerName,
        customerPhone: incident.customerPhone,
        damageAmount: incident.damageAmount,
        helperStatus: incident.helperStatus,
        helperActionAt: incident.helperActionAt?.toISOString() || null,
        helperNote: incident.helperNote,
        adminMemo: incident.adminMemo,
        deductionAmount: incident.deductionAmount,
        resolvedAt: incident.resolvedAt?.toISOString() || null,
        createdAt: incident.createdAt?.toISOString() || null,
        order: order ? {
          id: order.id,
          campAddress: order.campAddress,
          deliveryArea: order.deliveryArea,
          scheduledDate: order.scheduledDate,
          courierCompany: order.courierCompany,
          averageQuantity: order.averageQuantity,
          pricePerUnit: order.pricePerUnit,
        } : null,
        helper: helper ? {
          id: helper.id,
          name: helper.name,
          nickname: helper.nickname,
          phone: helper.phone,
        } : null,
        evidence: evidenceRows.map(e => ({
          id: e.id,
          fileUrl: e.fileUrl,
          fileType: e.fileType,
          description: e.description,
        })),
      });
    } catch (err) {
      console.error("Get incident detail error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // Requester Reviews API
  // ============================================
  app.get("/api/requester/reviews", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      if (user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 접근 가능합니다" });
      }

      const reviews = await storage.getReviewsByReviewer(userId);
      res.json(reviews);
    } catch (err) {
      console.error("Get requester reviews error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/requester/reviews", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      if (user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 접근 가능합니다" });
      }

      const { orderId, helperId, contractId, rating, comment } = req.body;
      
      if (!orderId || !helperId || !rating) {
        return res.status(400).json({ message: "필수 정보가 누락되었습니다" });
      }

      // 리뷰 작성 조건 검증: 잔금 결제 이후(BALANCE_PAID, SETTLEMENT_PAID)만 가능
      const order = await storage.getOrder(Number(orderId));
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }
      
      // 표준 상태: final_amount_confirmed 이후에만 리뷰 가능
      const reviewOrderStatus = normalizeOrderStatus(order.status);
      if (!isOneOfStatus(reviewOrderStatus, CAN_REVIEW_STATUSES)) {
        return res.status(400).json({ 
          message: "마감 승인 후에만 리뷰를 작성할 수 있습니다",
          currentStatus: order.status,
        });
      }
      
      // 본인 오더인지 검증
      if (order.requesterId !== userId) {
        return res.status(403).json({ message: "본인이 생성한 오더에만 리뷰를 작성할 수 있습니다" });
      }
      
      // 중복 리뷰 방지
      const existingReviews = await storage.getReviewsByReviewer(userId);
      const alreadyReviewed = existingReviews.some(r => r.orderId === Number(orderId));
      if (alreadyReviewed) {
        return res.status(400).json({ message: "이미 리뷰를 작성했습니다" });
      }

      const review = await storage.createReview({
        orderId,
        requesterId: userId,
        contractId,
        rating,
        comment: comment || null,
      });

      res.status(201).json(review);
    } catch (err) {
      console.error("Create requester review error:", err);
      res.status(500).json({ message: "리뷰 등록에 실패했습니다" });
    }
  });

  // Requester service agreement
  app.post("/api/requester/service-agreement", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 의뢰인만 접근 가능
      if (user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 접근 가능합니다" });
      }
      
      const { contractAgreed, signatureData, depositAmount, balanceAmount, balanceDueDate, phoneNumber, phoneVerified, userAgent, consentLog, contractContent, orderData } = req.body;
      
      if (!contractAgreed || !signatureData) {
        return res.status(400).json({ message: "계약에 동의하고 서명해주세요" });
      }
      
      if (!orderData) {
        return res.status(400).json({ message: "오더 정보가 없습니다" });
      }
      
      if (contractAgreed !== true) {
        return res.status(400).json({ message: "계약 내용에 동의해주세요" });
      }
      
      if (!signatureData || signatureData.length < 1000) {
        return res.status(400).json({ message: "유효한 전자서명을 입력해주세요" });
      }
      
      if (!phoneVerified) {
        return res.status(400).json({ message: "휴대폰 인증을 완료해주세요" });
      }
      
      // Check if user already has a service agreement
      let agreement = await storage.getRequesterServiceAgreement(userId);
      
      // 클라이언트 IP 주소 추출
      const ipAddress = (req.headers['x-forwarded-for'] as string)?.split(',')[0]?.trim() || req.socket.remoteAddress || 'unknown';
      
      // Create service agreement only if doesn't exist
      if (!agreement) {
        agreement = await storage.createRequesterServiceAgreement({
          userId,
          contractAgreed: true,
          depositAmount: depositAmount ?? null,
          balanceAmount: balanceAmount ?? null,
          balanceDueDate: balanceDueDate ?? null,
          phoneNumber: phoneNumber ?? null,
          phoneVerified: phoneVerified ?? false,
          signatureData,
          ipAddress,
          userAgent: userAgent ?? null,
          consentLog: consentLog ?? null,
          contractContent: contractContent ?? null,
          agreedAt: new Date(),
        });
      }
      
      // Create order from orderData
      const order = await storage.createOrder({
        requesterId: userId,
        helperId: null,
        trackingNumber: null,
        companyName: orderData.company || "미지정",
        pricePerUnit: orderData.unitPrice || 1200,
        averageQuantity: orderData.type === "cold_truck" ? "1건" : `${orderData.quantity || 100}box`,
        deliveryArea: orderData.deliveryArea || orderData.loadingPoint || "배송지 미입력",
        scheduledDate: orderData.requestDate || "일정 미선택",
        scheduledDateEnd: orderData.requestDateEnd || null,
        vehicleType: orderData.vehicleType || "차종 미선택",
        isUrgent: orderData.type === "cold_truck" || orderData.type === "etc_courier",
        status: "awaiting_deposit",
        approvalStatus: "pending", // 승인중
        maxHelpers: 1,
        currentHelpers: 0,
        requesterPhone: user.phoneNumber || phoneNumber,
      });
      
      // 가상계좌 생성 (계약금 20%)
      const unitPrice = orderData.unitPrice || 1200;
      // 냉잡전용(cold_truck)는 수량 1건으로 고정
      const quantity = orderData.type === "cold_truck" ? 1 : (orderData.quantity || 100);
      const subtotal = unitPrice * quantity;
      const vatAmount = Math.round(subtotal * 0.1);
      const totalAmount = subtotal + vatAmount;
      const depositAmt = Math.round(totalAmount * 0.2);
      
      // 가상계좌 만료일 (3일 후)
      const dueDate = new Date();
      dueDate.setDate(dueDate.getDate() + 3);
      
      // 테스트 모드에서 가상계좌 번호 생성
      const testBankCode = "088"; // 신한은행
      const testAccountNumber = `9${Date.now().toString().slice(-11)}`;
      
      const virtualAccount = await storage.createVirtualAccount({
        orderId: order.id,
        userId,
        paymentId: `payment_${order.id}_${Date.now()}`,
        bankCode: testBankCode,
        bankName: "신한은행",
        accountNumber: testAccountNumber,
        accountHolder: "헬프미",
        amount: depositAmt,
        status: "pending",
        dueDate,
      });
      
      res.json({ 
        message: "계약 동의가 완료되었습니다", 
        agreement, 
        order: order ? { ...order, helperName } : null,
        virtualAccount: {
          bankName: virtualAccount.bankName,
          accountNumber: virtualAccount.accountNumber,
          accountHolder: virtualAccount.accountHolder,
          amount: virtualAccount.amount,
          expiresAt: virtualAccount.dueDate,
        }
      });
    } catch (err) {
      console.error("Requester service agreement error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/requester/service-agreement", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 의뢰인만 접근 가능
      if (user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 접근 가능합니다" });
      }
      
      const agreement = await storage.getRequesterServiceAgreement(userId);
      res.json(agreement || null);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // POST /api/requester/orders - 요청자 오더 생성 (T-03 스펙)
  app.post("/api/requester/orders", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "requester") {
        return res.status(403).json({ code: "FORBIDDEN", message: "의뢰인만 오더를 생성할 수 있습니다" });
      }

      const { pickup, deliveryArea, schedule, price, requirements } = req.body;

      // 필수 필드 검증
      if (!deliveryArea || !schedule || !price) {
        return res.status(400).json({ code: "INVALID_INPUT", message: "필수 정보가 누락되었습니다" });
      }

      // 금액 계산 (부가세 포함)
      const boxCount = price.boxCount || 0;
      const unitPrice = price.unitPrice || 0;
      const supplyAmount = boxCount * unitPrice;
      const totalWithVat = Math.round(supplyAmount * 1.1); // 부가세 10% 포함
      const depositRequired = supplyAmount > 0;
      const depositAmount = Math.floor(totalWithVat * 0.2); // 부가세 포함 금액의 20%

      const order = await storage.createOrder({
        requesterId: user.id,
        status: ORDER_STATUS.AWAITING_DEPOSIT, // 초기 상태: 입금 대기
        companyName: deliveryArea?.region1 || "미지정",
        deliveryArea: pickup?.address || (deliveryArea?.region1 + " " + deliveryArea?.region2),
        scheduledDate: schedule?.startAt ? new Date(schedule.startAt).toISOString().split("T")[0] : new Date().toISOString().split("T")[0],
        scheduledDateEnd: schedule?.endAt ? new Date(schedule.endAt).toISOString().split("T")[0] : null,
        averageQuantity: String(boxCount),
        pricePerUnit: unitPrice,
        vehicleType: requirements?.vehicle || "any",
        campAddress: pickup?.address || null,
        deliveryLat: pickup?.lat?.toString() || null,
        deliveryLng: pickup?.lng?.toString() || null,
      });

      res.status(201).json({
        order: {
          id: `o_${order.id}`,
          status: depositRequired ? "PENDING_DEPOSIT" : "OPEN",
          deposit: {
            required: depositRequired,
            amount: depositAmount,
            approved: false,
          },
          createdAt: order.createdAt,
        },
      });

      // 관리자에게 새 오더 알림 (실시간 업데이트)
      await broadcastToAllAdmins("order", "created", order.id, {
        orderId: order.id,
        requesterId: user.id,
        status: ORDER_STATUS.AWAITING_DEPOSIT,
      });

      // 헬퍼들에게 새 오더 알림 (실시간 업데이트)
      await broadcastNewOrderToHelpers({
        orderId: order.id,
        courierCompany: undefined,
        deliveryArea: pickup?.address || deliveryArea?.region1,
        scheduledDate: order.scheduledDate,
      });
    } catch (err) {
      console.error("Create requester order error:", err);
      res.status(500).json({ code: "SERVER_ERROR", message: "오더 생성에 실패했습니다" });
    }
  });

  // Requester's own orders

  // GET /api/requester/orders/:orderId - 요청자 특정 오더 조회
  app.get("/api/requester/orders/:orderId", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const userId = user.id;
      const orderId = parseInt(req.params.orderId);
      
      if (isNaN(orderId)) {
        return res.status(400).json({ message: "Invalid order ID" });
      }
      
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      if (order.requesterId !== userId) {
        return res.status(403).json({ message: "이 오더에 접근 권한이 없습니다" });
      }
      
      const contracts = await storage.getOrderContracts(orderId);
      const firstContract = contracts[0];
      
      let helperName = "미배정";
      let selectedHelperId = null;
      let helperProfileImageUrl: string | null = null;
      if (order.matchedHelperId) {
        selectedHelperId = order.matchedHelperId;
        const helper = await storage.getUser(order.matchedHelperId);
        helperName = helper?.name || "미배정";
        helperProfileImageUrl = (helper as any)?.profileImageUrl || null;
      } else if (firstContract?.helperId) {
        selectedHelperId = firstContract.helperId;
        const helper = await storage.getUser(firstContract.helperId);
        helperName = helper?.name || "미배정";
        helperProfileImageUrl = (helper as any)?.profileImageUrl || null;
      }
      
      const depositInfo = await getOrderDepositInfo(orderId);
      const depositPaid = depositInfo.paymentStatus === "paid";
      const balancePaid = firstContract?.balancePaid || false;
      const balancePaidAt = firstContract?.balancePaidAt || null;
      
      const [closingReport] = await db.select()
        .from(closingReports)
        .where(eq(closingReports.orderId, orderId))
        .limit(1);
      
      let totalAmount = Number(firstContract?.totalAmount || 0);
      let deliveryCount = 0;
      let returnCount = 0;
      let otherCount = 0;
      
      if (closingReport) {
        const closingData = parseClosingReport(closingReport, order);
        const settlement = calculateSettlement(closingData);
        totalAmount = settlement.totalAmount;
        deliveryCount = settlement.deliveredCount;
        returnCount = settlement.returnedCount;
        otherCount = settlement.etcCount;
      }
      
      const depositAmount = depositInfo.depositAmount || Number(firstContract?.depositAmount || 0);
      const balanceAmount = Math.max(0, totalAmount - depositAmount);
      const paidAmount = (depositPaid ? depositAmount : 0) + (balancePaid ? balanceAmount : 0);
      const unpaidAmount = Math.max(0, totalAmount - paidAmount);
      
      let hasReview = false;
      if (firstContract) {
        const existingReview = await storage.getReviewByContract(firstContract.id);
        hasReview = !!existingReview;
      }
      
      res.json({
        ...order,
        helperName,
        selectedHelperId,
        helperProfileImageUrl,
        contractId: firstContract?.id || null,
        totalAmount,
        depositAmount,
        balanceAmount,
        depositPaid,
        balancePaid,
        balancePaidAt,
        paidAmount,
        unpaidAmount,
        deliveryCount,
        returnCount,
        otherCount,
        hasReview,
        workDate: order.scheduledDate || order.expectedDate || null,
        vehicleType: order.vehicleType || null,
      });
    } catch (error) {
      console.error("Error fetching requester order:", error);
      res.status(500).json({ message: "오더 조회에 실패했습니다" });
    }
  });

  app.get("/api/requester/orders", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 의뢰인만 접근 가능
      if (user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 접근 가능합니다" });
      }
      
      const statusFilter = req.query.status as string | undefined;
      let myOrders = await storage.getOrdersByRequesterId(userId);
      
      // 홈 화면(기본): 마감일 지난 오더 + hiddenAt 설정된 오더 숨김
      // 사용이력(status=completed): 모든 완료 오더 표시
      const showHidden = statusFilter === 'completed';
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      if (!showHidden) {
        myOrders = myOrders.filter(order => {
          // hiddenAt 설정된 오더 숨김
          if (order.hiddenAt) return false;
          // 마감일이 지난 완료 오더 숨김 (하루 지나면 자동 숨김)
          const completedStatuses = ['closing_submitted', 'final_amount_confirmed', 'balance_paid', 'settlement_paid', 'closed'];
          if (completedStatuses.includes(order.status?.toLowerCase() || '')) {
            const scheduledDate = order.scheduledDate ? new Date(order.scheduledDate) : null;
            if (scheduledDate && scheduledDate < today) return false;
          }
          return true;
        });
      }
      
      // 상태 필터링 (표준 상태 기준)
      if (statusFilter === 'completed') {
        // 마감 이후 오더: closing_submitted, final_amount_confirmed, balance_paid, settlement_paid, closed
        const completedStatuses = [
          'closing_submitted', 'final_amount_confirmed', 'balance_paid', 
          'settlement_paid', 'closed'
        ];
        myOrders = myOrders.filter(order => completedStatuses.includes(order.status?.toLowerCase() || ''));
      } else if (statusFilter === 'in_progress') {
        // 진행중인 오더: scheduled, in_progress
        const inProgressStatuses = ['scheduled', 'in_progress'];
        myOrders = myOrders.filter(order => inProgressStatuses.includes(order.status?.toLowerCase() || ''));
      } else if (statusFilter === 'open') {
        // 매칭중인 오더: open (표준)
        myOrders = myOrders.filter(order => order.status?.toLowerCase() === 'open');
      }
      
      const allSettlements = await storage.getAllSettlementStatements();
      
      // 각 오더에 결제 정보 및 정산 데이터 추가
      const ordersWithPayment = await Promise.all(myOrders.map(async (order) => {
        try {
          const contracts = await storage.getOrderContracts(order.id);
          const orderSettlements = allSettlements.filter(s => s.orderId === order.id);
          
          let totalAmount = 0;
          let paidAmount = 0;
          let unpaidAmount = 0;
          let deliveryCount = 0;
          let returnCount = 0;
          let otherCount = 0;
          
          for (const contract of contracts) {
            const contractTotal = Number(contract.totalAmount) || 0;
            const depositAmt = Number(contract.depositAmount) || 0;
            const balanceAmt = Number(contract.balanceAmount) || 0;
            
            totalAmount += contractTotal;
            if (contract.depositPaid) paidAmount += depositAmt;
            if (contract.balancePaid) paidAmount += balanceAmt;
          }
          
          // 정산 데이터에서 수량 합계
          for (const settlement of orderSettlements) {
            deliveryCount += settlement.deliveryCount || 0;
            returnCount += settlement.returnCount || 0;
            otherCount += settlement.otherCount || 0;
            // 정산 totalAmount이 있으면 사용 (업무마감 기반 실제 금액)
            if (settlement.totalAmount && settlement.totalAmount > 0) {
              totalAmount = Math.max(totalAmount, settlement.totalAmount);
            }
          }
          
          unpaidAmount = Math.max(0, totalAmount - paidAmount);
          
          // 헬퍼 정보 조회
          const helperIds = contracts.map(c => c.helperId).filter(Boolean);
          let helperName = "미배정";
          if (helperIds.length > 0) {
            const helper = await storage.getUser(helperIds[0]);
            helperName = helper?.name || "미배정";
          }
          
          // 마감 데이터가 있으면 실제 수량으로 금액 재계산
          const [closingReport] = await db.select()
            .from(closingReports)
            .where(eq(closingReports.orderId, order.id))
            .limit(1);
          
          // 계약금/잔금 정보 추가 - SSOT 함수 사용
          const firstContract = contracts[0];
          const depositInfo = await getOrderDepositInfo(order.id);
          const depositPaid = depositInfo.paymentStatus === 'paid';
          const balancePaid = firstContract?.balancePaid || false;
          const balancePaidAt = firstContract?.balancePaidAt || null;
          
          // 마감 데이터가 있으면 실제 수량으로 금액 계산, 없으면 계약 금액 사용
          let depositAmount = depositInfo.depositAmount || Number(firstContract?.depositAmount || firstContract?.downPaymentAmount || 0);
          let balanceAmount = Number(firstContract?.calculatedBalanceAmount || firstContract?.remainingAmount || 0);
          let actualTotalAmount = totalAmount;
          
          if (closingReport) {
            // 통합 계산 모듈 사용 (Single Source of Truth)
            const closingData = parseClosingReport(closingReport, order);
            const settlement = calculateSettlement(closingData);
            
            actualTotalAmount = settlement.totalAmount;
            balanceAmount = Math.max(0, actualTotalAmount - depositAmount);
            totalAmount = actualTotalAmount;
            
            // 마감 수량 업데이트
            deliveryCount = settlement.deliveredCount;
            returnCount = settlement.returnedCount;
            otherCount = settlement.etcCount;
          }
          
          // T-04: applicantCount / selectedHelperId 추가
          const applications = await storage.getOrderApplications(order.id);
          const activeApplications = applications.filter(a => 
            a.status === "applied" || a.status === "selected"
          );
          const applicantCount = activeApplications.length;
          const selectedHelperId = order.matchedHelperId || null;
          
          // 리뷰 존재 여부 확인
          let hasReview = false;
          if (firstContract) {
            const existingReview = await storage.getReviewByContract(firstContract.id);
            hasReview = !!existingReview;
          }
          
          return {
            ...order,
            totalAmount,
            paidAmount,
            unpaidAmount,
            depositAmount,
            balanceAmount,
            depositPaid,
            balancePaid,
            balancePaidAt,
            deliveryCount,
            returnCount,
            otherCount,
            helperName,
            isPaid: unpaidAmount <= 0,
            applicantCount,
            selectedHelperId,
            contractId: firstContract?.id || null,
            hasReview,
            applicants: await Promise.all(activeApplications.slice(0, 3).map(async (app) => {
              const helper = await storage.getUser(app.helperId);
              return {
                id: app.id,
                helperId: app.helperId,
                helperName: helper?.name || "헬퍼",
                helperNickname: helper?.nickname || null,
                averageRating: helper?.averageRating || null,
                reviewCount: helper?.reviewCount || 0,
                profileImageUrl: helper?.profileImageUrl || null,
                status: app.status,
              };
            })),
          };
        } catch (error) {
          console.error(`Error processing order ${order.id}:`, error);
          // 계약 정보를 가져오지 못한 경우 기본값 반환
          return {
            ...order,
            totalAmount: 0,
            depositAmount: 0,
            balanceAmount: 0,
            depositPaid: false,
            balancePaid: false,
            paidAmount: 0,
            unpaidAmount: 0,
            deliveryCount: 0,
            returnCount: 0,
            otherCount: 0,
            helperName: "미배정",
            applicantCount: 0,
            selectedHelperId: order.matchedHelperId || null,
            contractId: null,
            isPaid: false,
            hasReview: false,
          };
        }
      }));
      
      res.json(ordersWithPayment);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Requester: Get disputes list (이의제기 목록 조회)
  app.get("/api/requester/disputes", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 접근 가능합니다" });
      }
      
      const disputesList = await storage.getDisputesByRequester(user.id);
      
      res.json(disputesList.map((d: any) => ({
        id: d.id,
        orderId: d.orderId,
        workDate: d.workDate,
        disputeType: d.disputeType,
        description: d.description,
        status: d.status,
        resolution: d.resolution,
        adminReply: d.adminReply,
        createdAt: d.createdAt,
        resolvedAt: d.resolvedAt,
      })));
    } catch (err) {
      console.error("Get requester disputes error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  // GET /api/requester/orders/:orderId/dispute-status - 해당 오더의 이의제기 상태 조회
  app.get("/api/requester/orders/:orderId/dispute-status", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 접근 가능합니다" });
      }
      
      const orderId = Number(req.params.orderId);
      const order = await storage.getOrder(orderId);
      
      if (!order || order.requesterId !== user.id) {
        return res.status(403).json({ message: "해당 오더에 대한 권한이 없습니다" });
      }
      
      const disputes = await storage.getDisputesByOrder(orderId);
      const activeDispute = disputes.find((d: any) => 
        d.submitterRole === "requester" && ["pending", "in_review"].includes(d.status)
      );
      
      res.json({
        hasActiveDispute: !!activeDispute,
        activeDispute: activeDispute ? {
          id: activeDispute.id,
          status: activeDispute.status,
          disputeType: activeDispute.disputeType,
          createdAt: activeDispute.createdAt,
        } : null,
        totalDisputes: disputes.filter((d: any) => d.submitterRole === "requester").length,
      });
    } catch (err) {
      console.error("Dispute status check error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });


  // GET /api/requester/disputes/:id - 요청자 이의제기 상세 조회
  app.get("/api/requester/disputes/:id", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 접근 가능합니다" });
      }
      
      const id = Number(req.params.id);
      const dispute = await storage.getDispute(id);
      
      if (!dispute || dispute.submitterRole !== "requester") {
        return res.status(404).json({ message: "이의제기를 찾을 수 없습니다" });
      }
      
      // Verify ownership through order
      if (dispute.orderId) {
        const order = await storage.getOrder(dispute.orderId);
        if (!order || order.requesterId !== user.id) {
          return res.status(403).json({ message: "해당 이의제기에 대한 권한이 없습니다" });
        }
      }
      
      // Get order info
      let order = null;
      let helperName = null;
      if (dispute.orderId) {
        const [orderData] = await db.select().from(orders).where(eq(orders.id, dispute.orderId));
        order = orderData;
        
        if (orderData?.matchedHelperId) {
          const [helperData] = await db.select({ name: users.name }).from(users).where(eq(users.id, orderData.matchedHelperId));
          helperName = helperData?.name;
        }
      }
      
      res.json({
        id: dispute.id,
        orderId: dispute.orderId,
        workDate: dispute.workDate,
        disputeType: dispute.disputeType,
        description: dispute.description,
        status: dispute.status,
        resolution: dispute.resolution,
        adminReply: dispute.adminReply,
        adminReplyAt: dispute.adminReplyAt,
        createdAt: dispute.createdAt,
        resolvedAt: dispute.resolvedAt,
        order: order ? { ...order, helperName } : null,
        helperName,
        evidencePhotoUrl: dispute.evidencePhotoUrl,
      });
    } catch (err) {
      console.error("Get requester dispute detail error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Requester: Create a dispute (이의제기 접수)

  // POST /api/requester/disputes - 요청자 이의제기 접수
  app.post("/api/requester/disputes", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      if (user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 이의제기를 신청할 수 있습니다" });
      }
      
      const { orderId, incidentType, description } = req.body;
      
      // Idempotency check
      const idempotencyKey = getIdempotencyKeyFromRequest(req);
      if (idempotencyKey) {
        const { isDuplicate, isConflict, cachedResponse } = await checkIdempotency(
          userId,
          `POST:/api/requester/disputes`,
          idempotencyKey,
          req.body
        );
        if (isConflict) {
          return res.status(409).json({
            error: { code: "IDEMPOTENCY_CONFLICT", message: "동일 Idempotency-Key에 다른 요청이 감지되었습니다." }
          });
        }
        if (isDuplicate && cachedResponse) {
          console.log(`[Idempotency] Returning cached dispute for key: ${idempotencyKey}`);
          return res.status(cachedResponse.status).json(cachedResponse.body);
        }
      }
      
      if (!orderId || !incidentType || !description) {
        return res.status(400).json({ message: "필수 정보가 누락되었습니다" });
      }
      
      // 이의제기 유형 검증 (정산/결제 관련 유형만 허용)
      const validDisputeTypes = ["settlement_error", "invoice_error", "contract_dispute", "service_complaint", "amount_error", "other"];
      if (!validDisputeTypes.includes(incidentType)) {
        return res.status(400).json({ message: "유효하지 않은 이의제기 유형입니다" });
      }
      
      // 오더 소유권 확인
      const order = await storage.getOrder(orderId);
      if (!order || order.requesterId !== userId) {
        return res.status(403).json({ message: "해당 오더에 대한 권한이 없습니다" });
      }
      
      // 매칭된 헬퍼 확인 (이의제기는 매칭 후에만 가능)
      if (!order.matchedHelperId) {
        return res.status(400).json({ message: "매칭된 헬퍼가 없는 오더입니다. 이의제기는 매칭 후에만 가능합니다." });
      }
      
      // 중복 이의제기 확인 (pending 또는 in_review 상태의 기존 이의제기가 있는 경우)
      const existingDisputes = await storage.getDisputesByOrder(orderId);
      const activeDispute = existingDisputes.find((d: any) => 
        d.submitterRole === "requester" && ["pending", "in_review"].includes(d.status)
      );
      if (activeDispute) {
        return res.status(409).json({ 
          message: "이미 처리 중인 이의제기가 있습니다.",
          existingDisputeId: activeDispute.id,
          existingDisputeStatus: activeDispute.status
        });
      }
      
      // disputes 테이블에 이의제기 생성
      const dispute = await storage.createDispute({
        helperId: order.matchedHelperId,
        submitterRole: "requester",
        orderId,
        workDate: order.scheduledDate || new Date().toISOString().split("T")[0],
        disputeType: incidentType,
        description,
        status: "pending",
      });
      
      // WebSocket으로 관리자에게 실시간 알림
      broadcastToAllAdmins("dispute", "created", dispute.id, {
        disputeId: dispute.id,
        orderId,
        disputeType: incidentType,
        submitterRole: "requester",
        submitterName: user.name || user.email,
      });

      // 이의제기 유형 라벨
      const disputeTypeLabel = incidentType === "settlement_error" ? "정산 금액 오류" :
        incidentType === "invoice_error" ? "세금계산서 오류" :
        incidentType === "contract_dispute" ? "계약 조건 분쟁" :
        incidentType === "service_complaint" ? "서비스 불만" :
        incidentType === "amount_error" ? "금액 오류" : "기타";

      // 헬퍼에게 이의제기 접수 알림 전송
      const disputeMessage = `의뢰인이 이의제기를 접수했습니다.\n유형: ${disputeTypeLabel}\n내용: ${description.substring(0, 100)}${description.length > 100 ? "..." : ""}`;

      await storage.createNotification({
        userId: order.matchedHelperId,
        type: "dispute_submitted",
        title: "이의제기 접수 알림",
        message: disputeMessage,
        data: JSON.stringify({ disputeId: dispute.id, orderId, disputeType: incidentType }),
        isRead: false,
      });

      await sendPushToUser(order.matchedHelperId, {
        title: "이의제기 접수 알림",
        body: `의뢰인이 이의제기를 접수했습니다. 유형: ${disputeTypeLabel}`,
        data: { type: "dispute_submitted", disputeId: String(dispute.id), orderId: String(orderId) },
      });
      
      // Store idempotency response
      if (idempotencyKey) {
        await storeIdempotencyResponse(userId, `POST:/api/requester/disputes`, idempotencyKey, 201, dispute, req.body);
      }
      
      console.log(`[Dispute] New dispute created by requester ${userId}: ${incidentType} for order ${orderId}`);
      
      res.status(201).json({ 
        success: true, 
        message: "이의제기가 접수되었습니다.",
        dispute 
      });
    } catch (err) {
      console.error("Requester dispute creation error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Universal orders/my endpoint - works for both helpers and requesters
  app.get("/api/orders/my", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      let resultOrders: any[] = [];
      if (user.role === "requester") {
        resultOrders = await storage.getOrdersByRequesterId(userId);
      } else if (user.role === "helper") {
        // Get orders from contracts where helper is involved
        const contracts = await storage.getHelperContracts(userId);
        // Fetch each order individually (more efficient than loading all orders)
        const orderPromises = contracts.map(c => storage.getOrder(c.orderId));
        const orders = await Promise.all(orderPromises);
        resultOrders = orders.filter((o): o is NonNullable<typeof o> => o !== undefined);
      }
      
      res.json(resultOrders);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Order routes
  
  // 헬퍼용 내 오더 전체 목록 (예정/진행중/완료 포함)
  app.get("/api/helper/my-orders", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      // 헬퍼에게 배정된 모든 오더 조회 (예정/진행중/완료 등)
      const helperOrders = await db.select().from(orders)
        .where(eq(orders.matchedHelperId, userId))
        .orderBy(desc(orders.createdAt));
      
      // 지원해서 선정된 오더도 포함
      const applications = await db.select().from(orderApplications)
        .where(and(
          eq(orderApplications.helperId, userId),
          eq(orderApplications.status, "selected")
        ));
      
      const selectedOrderIds = applications.map(a => a.orderId);
      let selectedOrders: typeof helperOrders = [];
      
      if (selectedOrderIds.length > 0) {
        selectedOrders = await db.select().from(orders)
          .where(and(
            inArray(orders.id, selectedOrderIds),
            not(eq(orders.matchedHelperId, userId)) // 중복 제외
          ))
          .orderBy(desc(orders.createdAt));
      }
      
      // 합쳐서 반환
      const allOrders = [...helperOrders, ...selectedOrders];
      res.json(allOrders);
    } catch (err) {
      console.error("Error in /api/helper/my-orders:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  app.get("/api/orders/scheduled", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      const scheduledOrders = await storage.getHelperScheduledOrders(userId);
      res.json(scheduledOrders);
    } catch (err) {
      console.error("Error in /api/orders/scheduled:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/orders/my-applications", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 역할 검증: 헬퍼만 접근 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      const applications = await storage.getHelperApplications(userId);
      
      // 각 지원에 오더 상세 정보 포함
      const applicationsWithOrders = await Promise.all(
        applications.map(async (app) => {
          const order = await storage.getOrder(app.orderId);
          return {
            ...app,
            order: order || null,
          };
        })
      );
      
      res.json(applicationsWithOrders);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get(api.orders.list.path, async (req, res) => {
    try {
      const status = req.query.status as string | undefined;
      const includeHidden = req.query.includeHidden === "true";
      let orders = await storage.getAllOrders(status, { includeHidden });
      
      // Filter by helper's service areas if authenticated as helper
      const token = req.headers.authorization?.split(" ")[1];
      if (token) {
        try {
          const decoded = jwt.verify(token, JWT_SECRET) as { userId: string };
          const user = await storage.getUser(decoded.userId);
          if (user?.role === "helper") {
            const serviceAreas = await storage.getHelperServiceAreas(decoded.userId);
            if (serviceAreas.length > 0) {
              const regions = serviceAreas.map(a => a.region);
              orders = orders.filter(order => {
                if (!order.deliveryArea) return true;
                return regions.some(region => order.deliveryArea?.includes(region));
              });
            }
          }
        } catch (e) {
          // Token invalid, continue without filtering
        }
      }
      
      res.json(orders);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get(api.orders.get.path, async (req, res) => {
    try {
      const order = await storage.getOrder(Number(req.params.id));
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      res.json(order);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post(api.orders.create.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 멱등성 체크: 중복 요청 방지
      const idempotencyKey = getIdempotencyKeyFromRequest(req);
      if (idempotencyKey) {
        const { isDuplicate, cachedResponse } = await checkIdempotency(
          userId,
          "POST:/api/orders",
          idempotencyKey
        );
        if (isDuplicate && cachedResponse) {
          console.log(`[Idempotency] Returning cached order creation for key: ${idempotencyKey}`);
          return res.status(cachedResponse.status).json(cachedResponse.body);
        }
      }
      
      // 역할 검증: 의뢰인만 오더 생성 가능 (관리자 제외)
      if (user.role !== "requester" && !user.isHqStaff) {
        return res.status(403).json({ message: "의뢰인만 오더를 생성할 수 있습니다" });
      }
      
      const input = api.orders.create.input.parse(req.body);
      
      // 클라이언트 필드 → DB 필드 매핑
      // pickupAddress → campAddress (캠프 및 터미널주소)
      // description → deliveryGuide (배송가이드 텍스트)
      // referenceImageUri → regionMapUrl (배송지 이미지)
      const mappedInput = {
        ...input,
        campAddress: (req.body as any).pickupAddress || input.campAddress,
        deliveryGuide: (req.body as any).description || input.deliveryGuide,
        regionMapUrl: (req.body as any).referenceImageUri || input.regionMapUrl,
        courierCompany: input.companyName || null,
      };
      
      // 현재 글로벌 수수료 정책 스냅샷 가져오기
      // 주의: 오더 생성 시점에는 헬퍼가 배정되지 않았으므로 글로벌 정책만 스냅샷
      // 헬퍼별/팀별 오버라이드는 정산 시점에 적용됨
      // 이 스냅샷은 정산 시 폴백 값으로 사용되며, 정책 변경 후에도 기존 오더의 기준 수수료율 보존
      const helperPolicy = await storage.getCommissionPolicy("helper");
      const snapshotCommissionRate = helperPolicy?.defaultRate ?? 10;
      const snapshotPlatformRate = helperPolicy?.platformRate ?? 8;
      const snapshotTeamLeaderRate = helperPolicy?.teamLeaderRate ?? 2;
      
      // 최저운임 스냅샷 계산
      // 택배사 설정에서 minTotal 조회
      let basePricePerBox = mappedInput.pricePerUnit || 1200;
      let finalPricePerBox = basePricePerBox;
      let minTotalApplied = 0;
      
      const courierCompany = mappedInput.companyName;
      if (courierCompany) {
        const couriers = await storage.getAllCourierSettings();
        const courierSetting = couriers.find(c => c.courierName === courierCompany);
        
        if (courierSetting?.minTotal && courierSetting.minTotal > 0) {
          // 박스 수량 파싱 (예: "200box" -> 200)
          const quantityStr = mappedInput.averageQuantity || "100";
          const boxCount = parseInt(quantityStr.replace(/[^0-9]/g, '')) || 0;
          
          if (boxCount > 0) {
            const { calcPerBoxPricing } = await import("./utils/min-total-calculator");
            
            // 긴급 여부 확인 (mappedInput에서)
            const isUrgent = mappedInput.isUrgent === true || mappedInput.type === "cold_truck" || mappedInput.type === "etc_courier";
            const urgentSurchargeRate = courierSetting.urgentSurchargeRate || 0;
            
            const calcResult = calcPerBoxPricing({
              basePricePerBox,
              boxCount,
              minTotalAmount: courierSetting.minTotal,
              urgentSurchargeRate,
              isUrgent,
            });
            
            finalPricePerBox = calcResult.finalPricePerBox;
            minTotalApplied = calcResult.minApplied ? courierSetting.minTotal : 0;
            
            // 긴급 할증 또는 최저운임 적용 시 로깅
            if (calcResult.urgentApplied || calcResult.minApplied) {
              console.log(`[Order Create] 가격조정: ${basePricePerBox} → ${finalPricePerBox}원 (긴급: ${calcResult.urgentApplied}, 최저운임: ${calcResult.minApplied})`);
            }
          }
        }
      }
      
      // 오더 생성 (기본 상태: awaiting_deposit - 입금 대기)
      const order = await storage.createOrder({ 
        ...mappedInput, 
        requesterId: userId,
        helperId: null,
        trackingNumber: null,
        status: "awaiting_deposit",
        approvalStatus: "pending",
        maxHelpers: mappedInput.maxHelpers || 3,
        snapshotCommissionRate,
        snapshotPlatformRate,
        snapshotTeamLeaderRate,
        basePricePerBox,
        finalPricePerBox,
        minTotalApplied,
        pricePerUnit: finalPricePerBox, // 최종 조정된 단가 사용
      });
      
      // 정책 스냅샷 저장 (정산 자동화용)
      try {
        const { snapshotPoliciesForOrder } = await import("./utils/settlement-calculator");
        await snapshotPoliciesForOrder(order.id, mappedInput.carrierCode || null);
      } catch (snapshotErr) {
        console.warn("[Order Create] Policy snapshot failed (non-critical):", snapshotErr);
      }
      
      // 의뢰인에게 입금 안내 알림
      await storage.createNotification({
        userId,
        type: "order_created",
        title: "오더 등록 대기",
        message: `${order.companyName} 오더가 등록 대기 상태입니다. 예약금 입금 후 등록이 완료됩니다.`,
        relatedId: order.id,
      });
      
      // 관리자에게 새 오더 알림 브로드캐스트
      broadcastToAllAdmins("order", "created", order.id, {
        orderId: order.id,
        companyName: order.companyName,
        requesterId: userId,
        helperId: null,
        trackingNumber: null,
        status: "awaiting_deposit",
      });
      
      // 멱등성 응답 저장
      if (idempotencyKey) {
        await storeIdempotencyResponse(userId, "POST:/api/orders", idempotencyKey, 201, order);
      }
      
      res.status(201).json(order);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({
          message: err.errors[0].message,
          field: err.errors[0].path.join("."),
        });
      }
      console.error("[Order Create Error]", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 헬퍼가 오더에 신청 (applied 상태로 생성)
  app.post(api.orders.apply.path, requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      const orderId = Number(req.params.id);
      
      // 멱등성 체크: 중복 신청 방지
      const idempotencyKey = getIdempotencyKeyFromRequest(req);
      if (idempotencyKey) {
        const { isDuplicate, cachedResponse } = await checkIdempotency(
          userId,
          `POST:/api/orders/${orderId}/apply`,
          idempotencyKey
        );
        if (isDuplicate && cachedResponse) {
          console.log(`[Idempotency] Returning cached apply for order ${orderId}, key: ${idempotencyKey}`);
          return res.status(cachedResponse.status).json(cachedResponse.body);
        }
      }
      
      // 역할 검증: 헬퍼만 오더 신청 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 오더에 신청할 수 있습니다" });
      }
      
      // 온보딩 승인 검증: 승인된 헬퍼만 오더 신청 가능
      if (user.onboardingStatus !== "approved") {
        const statusMessage = user.onboardingStatus === "rejected" 
          ? "가입 심사가 반려되었습니다. 정보를 수정 후 다시 제출해주세요."
          : "가입 심사가 완료되지 않았습니다. 서류 검토 후 승인이 완료되면 오더 신청이 가능합니다.";
        return res.status(403).json({ message: statusMessage });
      }
      
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      // 오더가 open 상태일 때만 신청 가능 (표준)
      const legacyApplyStatus = normalizeOrderStatus(order.status);
      if (!isOneOfStatus(legacyApplyStatus, CAN_APPLY_STATUSES)) {
        return res.status(400).json({ message: "현재 신청할 수 없는 오더입니다" });
      }
      
      const existingApplication = await storage.getOrderApplication(orderId, userId);
      if (existingApplication) {
        return res.status(400).json({ message: "이미 신청한 오더입니다" });
      }
      
      // T-03: 헬퍼 중복 접수 제한 - 같은 입차일에 이미 매칭된 오더가 있으면 추가 지원 불가
      if (order.scheduledDate) {
        const matchedOrderOnDate = await storage.getHelperMatchedOrderByDate(userId, order.scheduledDate);
        if (matchedOrderOnDate) {
          return res.status(409).json({ 
            code: "DUPLICATE_ACTIVE_ORDER",
            message: `동일 날짜에 예정된 오더가 있어 지원이 불가합니다.`
          });
        }
      }
      
      // 3명 제한 체크 (원자적 처리를 위해 현재 헬퍼 수 확인)
      const currentApplications = await storage.getOrderApplications(orderId);
      const activeApplications = currentApplications.filter(a => 
        a.status === "applied" || a.status === "selected" || a.status === "scheduled" || a.status === "in_progress"
      );
      const maxHelpers = order.maxHelpers || 3;
      
      if (activeApplications.length >= maxHelpers) {
        return res.status(400).json({ message: "최대 신청 인원에 도달했습니다" });
      }
      
      // 신청 생성 (applied 상태)
      const application = await storage.createOrderApplication({
        orderId,
        helperId: userId,
        status: "applied",
      });
      
      // T-02: currentHelpers 제거 - applications COUNT로 계산
      const newHelperCount = activeApplications.length + 1;
      
      // 지원 시 상태 변경 없음 (open 유지) - 지원자 수는 applications 테이블로 관리
      
      // 의뢰인에게 알림 발송 (한 번만)
      if (order.requesterId) {
        await storage.createNotification({
          userId: order.requesterId,
          type: "helper_applied",
          title: "헬퍼 업무 신청",
          message: `${user.name || "헬퍼"}님이 ${order.companyName} 오더에 신청했습니다. (${newHelperCount}/${maxHelpers}명)`,
          relatedId: orderId,
        });
        
        // WebSocket 실시간 알림 (상태는 open 유지)
        notificationWS.sendOrderStatusUpdate(order.requesterId, {
          orderId,
          status: order.status || "open",
          approvalStatus: order.approvalStatus || undefined,
          applicantCount: newHelperCount,
        });
        
        // 푸시 알림 (태그로 중복 방지)
        sendPushToUser(order.requesterId, {
          title: "헬퍼 업무 신청",
          body: `${user.name || "헬퍼"}님이 ${order.companyName} 오더에 신청했습니다. (${newHelperCount}/${maxHelpers}명)`,
          url: "/requester-home",
          tag: `application-${orderId}-${userId}`,
        });
      }
      
      // 관리자에게 실시간 브로드캐스트
      broadcastToAllAdmins("order_application", "helper_applied", orderId, {
        orderId,
        helperId: userId,
        helperName: user.name,
        companyName: order.companyName,
        applicationsCount: newHelperCount,
      });
      
      // 멱등성 응답 저장
      if (idempotencyKey) {
        await storeIdempotencyResponse(userId, `POST:/api/orders/${orderId}/apply`, idempotencyKey, 201, application);
      }
      
      res.status(201).json(application);
    } catch (err) {
      console.error("[Apply Error]", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // T-05: DELETE /api/orders/:orderId/apply - 헬퍼 지원취소
  app.delete("/api/orders/:orderId/apply", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      const orderId = Number(req.params.orderId);
      if (isNaN(orderId)) {
        return res.status(400).json({ message: "유효하지 않은 오더 ID입니다" });
      }
      
      // 역할 검증: 헬퍼만 취소 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 지원을 취소할 수 있습니다" });
      }
      
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }
      
      // 지원 내역 확인
      const application = await storage.getOrderApplication(orderId, userId);
      if (!application) {
        return res.status(404).json({ message: "지원 내역이 없습니다" });
      }
      
      // applied 상태에서만 취소 가능 (selected/scheduled 상태는 취소 불가)
      if (application.status !== "applied") {
        return res.status(400).json({ message: "이미 선정되었거나 진행 중인 지원은 취소할 수 없습니다" });
      }
      
      // 지원 상태를 cancelled로 변경
      await storage.updateOrderApplication(application.id, { status: "cancelled" });
      
      // 남은 지원자 수 확인 (상태 변경 없음 - open 유지)
      const remainingApplications = await storage.getOrderApplications(orderId);
      const activeApplications = remainingApplications.filter(a => 
        a.status === "applied" || a.status === "selected"
      );
      
      // 요청자에게 알림 (선택)
      if (order.requesterId) {
        await storage.createNotification({
          userId: order.requesterId,
          type: "helper_cancelled",
          title: "지원 취소",
          message: `${user.name || "헬퍼"}님이 지원을 취소했습니다. (${activeApplications.length}/3명)`,
          relatedId: orderId,
        });
      }
      
      res.json({ success: true, message: "지원이 취소되었습니다" });
    } catch (err) {
      console.error("Cancel application error:", err);
      res.status(500).json({ message: "지원 취소에 실패했습니다" });
    }
  });

  // Notification routes
  app.get("/api/notifications", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const notifications = await storage.getUserNotifications(userId);
      res.json(notifications);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/notifications/unread-count", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const count = await storage.getUnreadNotificationCount(userId);
      res.json({ count });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/notifications/:id/read", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const notification = await storage.markNotificationAsRead(Number(req.params.id));
      res.json(notification);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/notifications/read-all", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      await storage.markAllNotificationsAsRead(userId);
      res.json({ success: true });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create test notifications endpoint (for testing)
  app.post("/api/notifications/test", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const testNotifications = [
        { userId, type: "matching_success" as const, title: "매칭 성공", message: "쿠팡 주간 배송 오더가 매칭되었습니다. 담당자 연락처: 010-1234-5678" },
        { userId, type: "announcement" as const, title: "본사 공지", message: "12월 31일은 정상 운영됩니다." },
      ];
      
      for (const notif of testNotifications) {
        await storage.createNotification(notif);
      }
      
      res.json({ success: true, message: "테스트 알림이 생성되었습니다" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Contract routes
  app.post("/api/contracts", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const { orderId, helperId, totalAmount } = req.body;
      const depositAmount = Math.floor(totalAmount * 0.2);
      const balanceAmount = totalAmount - depositAmount;
      
      const contract = await storage.createContract({
        orderId,
        requesterId: userId,
        helperId: null,
        trackingNumber: null,
        totalAmount,
        depositAmount,
        balanceAmount,
        depositPaid: false,
        balancePaid: false,
        status: "pending",
      });

      // Get order info for notification message
      const order = await storage.getOrder(orderId);
      const requester = await storage.getUser(userId);
      const helper = await storage.getUser(helperId);
      
      // Send push notification to Helper (selected for the job) - includes requester contact info
      const requesterPhone = requester?.phoneNumber || "연락처 미등록";
      await storage.createNotification({
        userId: helperId,
        type: "matching_success",
        title: "매칭 성공",
        message: `${order?.companyName || "배송"} 오더에 선택되었습니다.\n의뢰인: ${requester?.name || "의뢰인"}\n연락처: ${requesterPhone}`,
      });
      // 운영 로그: 민감정보 제외
      if (process.env.NODE_ENV !== "production") {
        console.log(`[Push Notification] Sent to Helper ${helperId}: 매칭 성공`);
      }

      // Send push notification to Requester (confirmation of selection) - includes helper contact info
      const helperPhone = helper?.phoneNumber || "연락처 미등록";
      await storage.createNotification({
        userId,
        type: "matching_success",
        title: "헬퍼 선택 완료",
        message: `${helper?.name || "헬퍼"}님이 ${order?.companyName || "배송"} 오더에 배정되었습니다.\n헬퍼 연락처: ${helperPhone}`,
      });
      // 운영 로그: 민감정보 제외
      if (process.env.NODE_ENV !== "production") {
        console.log(`[Push Notification] Sent to Requester ${userId}: 헬퍼 선택 완료`);
      }
      
      res.status(201).json(contract);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/contracts", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      let contracts;
      if (user.role === "helper") {
        contracts = await storage.getHelperContracts(userId);
      } else {
        contracts = await storage.getRequesterContracts(userId);
      }
      
      res.json(contracts);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/contracts/:id", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const contract = await storage.getContract(Number(req.params.id));
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      res.json(contract);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/contracts/:id/payment", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const contractId = Number(req.params.id);
      const contract = await storage.getContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      if (contract.requesterId !== userId && contract.helperId !== userId) {
        return res.status(403).json({ message: "이 계약에 대한 권한이 없습니다" });
      }
      
      const payment = await storage.getPaymentByContract(contractId);
      if (!payment) {
        return res.status(404).json({ message: "결제 정보가 없습니다" });
      }
      
      res.json(payment);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/contracts/:id/deposit", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const contractId = Number(req.params.id);
      const existingContract = await storage.getContract(contractId);
      
      const contract = await storage.updateContract(contractId, {
        depositPaid: true,
          depositPaidAt: new Date(),
          downPaymentStatus: "paid",
        status: "deposit_paid",
      });
      
      // 오더 상태 업데이트: awaiting_deposit → scheduled (계약금 결제 완료)
      if (existingContract?.orderId) {
        const order = await storage.getOrder(existingContract.orderId);
        if (order && order.status === "awaiting_deposit") {
          await storage.updateOrder(existingContract.orderId, { status: "scheduled" });
        }
      }
      
      res.json(contract);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/contracts/:id/balance", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const contract = await storage.updateContract(Number(req.params.id), {
        balancePaid: true,
        balancePaidAt: new Date(),
        status: "completed",
      });
      
      res.json(contract);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 새 운영 체계 APIs - Phase 2: 후보 지원/선택 워크플로우
  // ============================================

  // 헬퍼 지원 API (3명 제한 적용)
  app.post("/api/orders/:orderId/candidates/apply", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      // 헬퍼만 지원 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 지원 가능합니다" });
      }

      // 오더 확인
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 지원 가능한 상태 확인 (OPEN 상태에서만 - 표준)
      const candidateApplyStatus = normalizeOrderStatus(order.status);
      if (!isOneOfStatus(candidateApplyStatus, CAN_APPLY_STATUSES)) {
        return res.status(400).json({ 
          message: "현재 지원할 수 없는 상태입니다",
          currentStatus: order.status
        });
      }

      // 중복 접수 불가 검증: 헬퍼가 다른 Active 오더가 있으면 지원 불가
      const { hasActive, activeOrder } = await storage.hasActiveOrderAssignment(user.id);
      if (hasActive && activeOrder) {
        return res.status(409).json({ 
          error: {
            code: "DUPLICATE_ASSIGNMENT",
            message: "이미 예정된 오더가 있어 신규 지원이 불가합니다.",
            details: [{
              field: "activeOrderId",
              reason: `현재 오더: ${activeOrder.companyName} (상태: ${activeOrder.status})`
            }]
          }
        });
      }

      // 이미 지원했는지 확인
      const existingCandidate = await storage.getOrderCandidate(orderId, user.id);
      if (existingCandidate) {
        return res.status(400).json({ message: "이미 지원한 오더입니다" });
      }

      // 현재 활성 후보 수 확인 (최대 3명)
      const activeCount = await storage.countActiveOrderCandidates(orderId);
      if (activeCount >= 3) {
        return res.status(400).json({ 
          message: "최대 지원자 수(3명)에 도달했습니다",
          maxReached: true
        });
      }

      // 헬퍼 평점 정보 가져오기
      const ratingSummary = await storage.getHelperRatingSummary(user.id);

      // 후보 생성
      const candidate = await storage.createOrderCandidate({
        orderId,
        helperUserId: user.id,
        status: "applied",
        rankSnapshot: JSON.stringify({
          avgRating: ratingSummary?.avgRating || null,
          reviewCount: ratingSummary?.reviewCount || 0,
          completionRate: ratingSummary?.completionRate || null,
          last30dJobs: ratingSummary?.last30dJobs || 0,
        }),
      });

      // 알림 생성 (요청자에게)
      if (order.requesterId) {
        await storage.createNotification({
          userId: order.requesterId,
          type: "application" as any,
          title: "새로운 지원자",
          message: `${user.name || "헬퍼"}님이 오더에 지원했습니다. (${activeCount + 1}/3)`,
          data: JSON.stringify({ orderId, candidateId: candidate.id }),
        });
      }

      res.status(201).json({
        success: true,
        candidate,
        remainingSlots: 3 - (activeCount + 1),
      });
    } catch (err) {
      console.error("Error in candidate apply:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 오더 후보 목록 조회 (요청자용)
  app.get("/api/orders/:orderId/candidates", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      // 오더 확인
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 권한 확인 (요청자 또는 관리자)
      const isOwner = order.requesterId === user.id;
      const isAdmin = user.isHqStaff;
      if (!isOwner && !isAdmin) {
        return res.status(403).json({ message: "조회 권한이 없습니다" });
      }

      // 후보 목록 조회
      const candidates = await storage.getOrderCandidates(orderId);

      // 헬퍼 정보와 평점 정보 조회
      const enrichedCandidates = await Promise.all(
        candidates.map(async (c) => {
          const helper = await storage.getUser(c.helperUserId);
          const ratingSummary = await storage.getHelperRatingSummary(c.helperUserId);
          const helperCredential = await storage.getHelperCredential(c.helperUserId);
          const helperVehicle = await storage.getHelperVehicle(c.helperUserId);

          // 연락처 공개 여부 확인 (계약금 입금 후에만)
          const canReveal = await canRevealContact(orderId);

          return {
            ...c,
            helper: helper ? {
              id: helper.id,
              name: helper.name,
              profilePhoto: helper.profileImageUrl || null,
              // 연락처는 계약금 입금 후에만 공개
              phone: (c.status === "selected" && canReveal) ? helper.phoneNumber : null,
            } : null,
            ratingSummary: ratingSummary ? {
              avgRating: ratingSummary.avgRating,
              totalCompleted: ratingSummary.totalJobs || 0,
              noShowCount: 0,
            } : null,
            credential: helperCredential ? {
              cargoId: helperCredential.licenseNumber || null,
            } : null,
            vehicle: helperVehicle ? {
              type: helperVehicle.vehicleType,
              carModel: helperVehicle.plateNumber || null,
            } : null,
          };
        })
      );

      res.json({
        orderId,
        totalCandidates: candidates.length,
        maxCandidates: 3,
        candidates: enrichedCandidates,
      });
    } catch (err) {
      console.error("Error fetching candidates:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 헬퍼 선택 + 연락처 공개 (요청자용)
  app.post("/api/orders/:orderId/candidates/:candidateId/withdraw", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);
      const candidateId = Number(req.params.candidateId);

      // 헬퍼만 취소 가능
      if (user.role !== "helper") {
        return res.status(403).json({ 
          error: { code: "FORBIDDEN_ROLE", message: "헬퍼만 취소 가능합니다" } 
        });
      }

      // 후보 조회
      const candidate = await storage.getOrderCandidateById(candidateId);
      if (!candidate || candidate.orderId !== orderId) {
        return res.status(404).json({ 
          error: { code: "CANDIDATE_NOT_FOUND", message: "지원 내역이 없습니다" } 
        });
      }

      // 본인 지원만 취소 가능
      if (candidate.helperUserId !== user.id) {
        return res.status(403).json({ 
          error: { code: "FORBIDDEN", message: "본인의 지원만 취소할 수 있습니다" } 
        });
      }

      // 이미 선택된 경우 취소 불가 (관리자 조치로 처리)
      if (candidate.status === "selected") {
        return res.status(400).json({ 
          error: { code: "ALREADY_SELECTED", message: "이미 선택되어 취소할 수 없습니다. 관리자에게 문의하세요." } 
        });
      }

      // APPLIED/SHORTLISTED만 WITHDRAWN 가능
      if (!["applied", "shortlisted"].includes(candidate.status || "")) {
        return res.status(400).json({ 
          error: { code: "INVALID_STATUS", message: "취소할 수 없는 상태입니다" } 
        });
      }

      // 상태 업데이트 (applied/shortlisted → withdrawn)
      const updated = await storage.updateOrderCandidate(candidate.id, {
        status: "withdrawn",
        withdrawnAt: new Date(),
      });

      res.json({
        candidate_id: String(candidate.id),
        status: "WITHDRAWN",
      });
    } catch (err) {
      console.error("Error withdrawing candidate:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 헬퍼 지원 취소 (스펙: DELETE /api/orders/{orderId}/candidates/me)
  app.delete("/api/orders/:orderId/candidates/me", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      // 헬퍼만 취소 가능
      if (user.role !== "helper") {
        return res.status(403).json({ 
          error: { code: "FORBIDDEN_ROLE", message: "헬퍼만 취소 가능합니다" } 
        });
      }

      // 본인의 후보 조회
      const candidate = await storage.getOrderCandidate(orderId, user.id);
      if (!candidate) {
        return res.status(404).json({ 
          error: { code: "CANDIDATE_NOT_FOUND", message: "지원 내역이 없습니다" } 
        });
      }

      // 이미 취소/탈락된 경우
      if (candidate.status === "withdrawn" || candidate.status === "rejected") {
        return res.status(400).json({ 
          error: { code: "ALREADY_PROCESSED", message: "이미 처리된 지원입니다" } 
        });
      }

      // 이미 선택된 경우 취소 불가 (관리자 조치로 처리)
      if (candidate.status === "selected") {
        return res.status(400).json({ 
          error: { code: "ALREADY_SELECTED", message: "이미 선택되어 취소할 수 없습니다. 관리자에게 문의하세요." } 
        });
      }

      // APPLIED/SHORTLISTED만 WITHDRAWN 가능
      if (!["applied", "shortlisted"].includes(candidate.status || "")) {
        return res.status(400).json({ 
          error: { code: "INVALID_STATUS", message: "취소할 수 없는 상태입니다" } 
        });
      }

      // 상태 업데이트 (applied/shortlisted → withdrawn)
      await storage.updateOrderCandidate(candidate.id, {
        status: "withdrawn",
        withdrawnAt: new Date(),
      });

      // 오더의 지원자 수 갱신
      const order = await storage.getOrder(orderId);
      if (order) {
        const currentCount = (order.currentHelpers || 0) - 1;
        await storage.updateOrder(orderId, {
          currentHelpers: Math.max(0, currentCount),
        });
      }

      res.json({
        ok: true,
        candidateId: candidate.id,
        status: "withdrawn",
      });
    } catch (err) {
      console.error("Error withdrawing candidate:", err);
      res.status(500).json({ error: { code: "INTERNAL_ERROR", message: "서버 오류가 발생했습니다" } });
    }
  });

  // 비용 항목 타입 목록 조회 (관리자/요청자용)
  app.get("/api/cost-item-types", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const types = await storage.getAllCostItemTypes();
      res.json(types);
    } catch (err) {
      console.error("Error fetching cost item types:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 오더 비용 항목 조회
  app.get("/api/orders/:orderId/cost-items", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 권한 확인
      const isOwner = order.requesterId === user.id || order.matchedHelperId === user.id;
      const isAdmin = user.isHqStaff;
      if (!isOwner && !isAdmin) {
        return res.status(403).json({ message: "조회 권한이 없습니다" });
      }

      const costItems = await storage.getOrderCostItems(orderId);
      res.json(costItems);
    } catch (err) {
      console.error("Error fetching cost items:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 오더 비용 항목 추가 (관리자용)
  app.post("/api/orders/:orderId/cost-items", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      // 관리자만 비용 항목 추가 가능
      if (!user.isHqStaff) {
        return res.status(403).json({ message: "관리자만 비용 항목을 추가할 수 있습니다" });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      const { typeId, label, amount, memo } = req.body;

      const costItem = await storage.createOrderCostItem({
        orderId,
        typeId: typeId || null,
        label,
        amount,
        memo: memo || null,
        addedBy: user.id,
      });

      res.status(201).json(costItem);
    } catch (err) {
      console.error("Error adding cost item:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 오더 비용 항목 삭제 (관리자용)
  app.delete("/api/orders/:orderId/cost-items/:itemId", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);
      const itemId = Number(req.params.itemId);

      // 관리자만 삭제 가능
      if (!user.isHqStaff) {
        return res.status(403).json({ message: "관리자만 비용 항목을 삭제할 수 있습니다" });
      }

      await storage.deleteOrderCostItem(itemId);
      res.json({ success: true });
    } catch (err) {
      console.error("Error deleting cost item:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 오더 증빙 업로드 목록 조회
  app.get("/api/orders/:orderId/proofs", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 권한 확인
      const isOwner = order.requesterId === user.id || order.matchedHelperId === user.id;
      const isAdmin = user.isHqStaff;
      if (!isOwner && !isAdmin) {
        return res.status(403).json({ message: "조회 권한이 없습니다" });
      }

      const proofs = await storage.getOrderCarrierProofs(orderId);
      res.json(proofs);
    } catch (err) {
      console.error("Error fetching proofs:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 오더 마감 보고서 조회
  app.get("/api/orders/:orderId/closure-report", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 권한 확인
      const isOwner = order.requesterId === user.id || order.matchedHelperId === user.id;
      const isAdmin = user.isHqStaff;
      if (!isOwner && !isAdmin) {
        return res.status(403).json({ message: "조회 권한이 없습니다" });
      }

      const report = await storage.getOrderClosureReport(orderId);
      res.json(report || null);
    } catch (err) {
      console.error("Error fetching closure report:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 오더 마감 보고서 생성/업데이트 (헬퍼용)
  app.post("/api/orders/:orderId/closure-report", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      // 헬퍼만 마감 보고서 작성 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 마감 보고서를 작성할 수 있습니다" });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 담당 헬퍼인지 확인
      if (order.matchedHelperId !== user.id) {
        return res.status(403).json({ message: "담당 헬퍼만 마감 보고서를 작성할 수 있습니다" });
      }

      // IN_PROGRESS 상태에서만 마감 보고서 작성 가능 (scheduled도 편의상 허용)
      if (!["in_progress", "scheduled"].includes(order.status ?? "")) {
        return res.status(400).json({ 
          message: "업무 진행 중 상태에서만 마감 보고서를 작성할 수 있습니다",
          currentStatus: order.status,
        });
      }

      const { actualDeliveryCount, memo, anomalyFlag, anomalyDetail } = req.body;

      // 기존 보고서 확인
      const existingReport = await storage.getOrderClosureReport(orderId);
      
      let report;
      if (existingReport) {
        report = await storage.updateOrderClosureReport(existingReport.id, {
          actualDeliveryCount,
          memo,
          anomalyFlag: anomalyFlag || false,
          anomalyDetail,
        });
      } else {
        report = await storage.createOrderClosureReport({
          orderId,
          helperUserId: user.id,
          actualDeliveryCount,
          memo,
          anomalyFlag: anomalyFlag || false,
          anomalyDetail,
          submittedAt: new Date(),
        });
      }

      res.status(201).json(report);
    } catch (err) {
      console.error("Error creating closure report:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 오더 가격 스냅샷 조회
  app.get("/api/orders/:orderId/pricing-snapshot", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 권한 확인
      const isOwner = order.requesterId === user.id || order.matchedHelperId === user.id;
      const isAdmin = user.isHqStaff;
      if (!isOwner && !isAdmin) {
        return res.status(403).json({ message: "조회 권한이 없습니다" });
      }

      const snapshot = await storage.getOrderPricingSnapshot(orderId);
      res.json(snapshot || null);
    } catch (err) {
      console.error("Error fetching pricing snapshot:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // GET /api/orders/:orderId/contract-breakdown - 계약 금액 breakdown (서버 계산)
  app.get("/api/orders/:orderId/contract-breakdown", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 권한 확인 - 요청자 또는 관리자만 조회 가능
      const isOwner = order.requesterId === user.id;
      const isAdmin = user.isHqStaff || user.role === 'admin' || user.role === 'superadmin';
      if (!isOwner && !isAdmin) {
        return res.status(403).json({ message: "조회 권한이 없습니다" });
      }

      const pricePerUnit = Number(order.pricePerUnit) || 0;
      const avgQty = parseInt(String(order.averageQuantity || '1').replace(/[^0-9]/g, '')) || 1;
      
      const supplyAmount = pricePerUnit * avgQty;
      const vatAmount = Math.round(supplyAmount * 0.1);
      const totalAmount = supplyAmount + vatAmount;
      const depositAmount = Math.floor(totalAmount * 0.2);
      const balanceAmount = totalAmount - depositAmount;

      res.json({
        pricePerUnit,
        quantity: avgQty,
        supplyAmount,
        vatAmount,
        totalAmount,
        depositAmount,
        balanceAmount,
      });
    } catch (err) {
      console.error("Error fetching contract breakdown:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 오더 재정산 (관리자용) - 비용 항목 기반 가격 재계산
  app.post("/api/orders/:orderId/reprice", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      // 관리자만 재정산 가능
      if (!user.isHqStaff) {
        return res.status(403).json({ message: "관리자만 재정산할 수 있습니다" });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 비용 항목 합계 계산
      const costItems = await storage.getOrderCostItems(orderId);
      const costPlusItems = costItems.filter(item => item.type === 'add' || item.type === 'plus');
      const costMinusItems = costItems.filter(item => item.type === 'subtract' || item.type === 'minus');
      const costPlusTotal = costPlusItems.reduce((sum, item) => sum + Number(item.amount || 0), 0);
      const costMinusTotal = costMinusItems.reduce((sum, item) => sum + Number(item.amount || 0), 0);

      // 기본 단가 × 수량 (공급가 기준)
      const qty = parseInt(String(order.averageQuantity || 0)) || 0;
      const baseSupplyAmount = Number(order.pricePerUnit || 0) * qty + costPlusTotal - costMinusTotal;
      
      // VAT 10%
      const vatAmount = Math.round(baseSupplyAmount * 0.1);
      const grossAmount = baseSupplyAmount + vatAmount;
      
      // 계약금 20%
      const depositAmount = Math.round(grossAmount * 0.2);
      const balanceAmount = grossAmount - depositAmount;

      // 가격 스냅샷 저장 (스키마 컬럼명과 일치)
      const snapshot = await storage.createPricingSnapshot({
        orderId,
        baseSupplyAmount,
        vatAmount,
        grossAmount,
        depositAmount,
        balanceAmount,
        costPlusTotal,
        costMinusTotal,
      });

      res.json({
        success: true,
        snapshot,
        breakdown: {
          baseSupplyAmount,
          costPlusTotal,
          costMinusTotal,
          vatAmount,
          grossAmount,
          depositAmount,
          balanceAmount,
        },
      });
    } catch (err) {
      console.error("Error repricing order:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 업무 시작 API (SCHEDULED → WORKING)
  // 스펙: POST /api/orders/{orderId}/start
  app.post("/api/orders/:orderId/start", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      // 헬퍼만 업무 시작 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 업무를 시작할 수 있습니다" });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 담당 헬퍼인지 확인
      if (order.matchedHelperId !== user.id) {
        return res.status(403).json({ message: "담당 헬퍼만 업무를 시작할 수 있습니다" });
      }

      // SCHEDULED 상태에서만 업무 시작 가능
      if (order.status !== "scheduled") {
        return res.status(400).json({ 
          message: "예정된 상태에서만 업무를 시작할 수 있습니다",
          currentStatus: order.status,
        });
      }

      // 오더 상태 업데이트 (SCHEDULED → WORKING/in_progress)
      await storage.updateOrder(orderId, {
        status: "in_progress",
      });

      // 오더 상태 이벤트 기록
      await storage.createOrderStatusEvent({
        orderId,
        previousStatus: "scheduled",
        newStatus: "in_progress",
        reason: "업무 시작",
        changedBy: user.id,
      });

      // 요청자에게 알림
      if (order.requesterId) {
        await storage.createNotification({
          userId: order.requesterId,
          type: "work_started" as any,
          title: "업무 시작",
          message: `${user.name || "헬퍼"}님이 ${order.companyName} 오더의 업무를 시작했습니다.`,
          data: JSON.stringify({ orderId }),
        });
      }

      res.json({
        success: true,
        newStatus: "in_progress",
      });
    } catch (err) {
      console.error("Error starting work:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // QR 체크인 API - QR 코드 스캔 후 업무 시작
  // 스펙: POST /api/orders/{orderId}/qr-checkin
  app.post("/api/orders/:orderId/qr-checkin", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);
      const { qrData, timestamp } = req.body;

      // 헬퍼만 체크인 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 체크인할 수 있습니다" });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 담당 헬퍼인지 확인
      if (order.matchedHelperId !== user.id) {
        return res.status(403).json({ message: "담당 헬퍼만 체크인할 수 있습니다" });
      }

      // SCHEDULED 상태에서만 체크인 가능
      if (order.status !== "scheduled") {
        return res.status(400).json({ 
          message: "예정된 상태에서만 체크인할 수 있습니다",
          currentStatus: order.status,
        });
      }

      // QR 코드 검증 - 요청자 QR 코드와 매칭
      // QR 데이터 형식: hellpme://checkin/{requesterId}/{orderIdHash}
      let qrValid = false;
      if (qrData && order.requesterId) {
        // QR 코드가 order.requesterId를 포함하는지 검증
        // 간단한 검증 - 실제로는 암호화된 토큰 검증 필요
        if (qrData.includes(`hellpme://checkin/${order.requesterId}`) ||
            qrData.includes(`order:${orderId}`) ||
            qrData === `checkin-${order.requesterId}-${orderId}`) {
          qrValid = true;
        }
      }

      // 체크인 기록 저장 (QR 검증 여부와 관계없이 기록)
      const checkinTime = timestamp ? new Date(timestamp) : new Date();

      // 오더 상태 업데이트 (SCHEDULED → in_progress)
      await storage.updateOrder(orderId, {
        status: "in_progress",
      });

      // 오더 상태 이벤트 기록
      await storage.createOrderStatusEvent({
        orderId,
        previousStatus: "scheduled",
        newStatus: "in_progress",
        reason: qrValid ? "QR 체크인으로 업무 시작" : "QR 스캔으로 업무 시작 (미검증)",
        changedBy: user.id,
      });

      // 요청자에게 알림
      if (order.requesterId) {
        await storage.createNotification({
          userId: order.requesterId,
          type: "work_started" as any,
          title: "업무 시작",
          message: `${user.name || "헬퍼"}님이 ${order.companyName} 오더에 QR 체크인하여 업무를 시작했습니다.`,
          data: JSON.stringify({ orderId, checkinTime: checkinTime.toISOString() }),
        });
      }

      res.json({
        success: true,
        message: "출근 체크인 완료! 업무가 시작되었습니다.",
        newStatus: "in_progress",
        checkinTime: checkinTime.toISOString(),
        qrVerified: qrValid,
      });
    } catch (err) {
      console.error("Error QR checkin:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // T-17: QR 시작 토큰 (1회성/만료) 발급 및 검증
  // ============================================

  // POST /api/orders/:orderId/qr/start/create - QR 시작 토큰 발급 (관리자/요청자)
  app.post("/api/orders/:orderId/qr/start/create", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);
      const { expiryHours = 24 } = req.body;

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 요청자 또는 관리자만 토큰 발급 가능
      if (user.role !== "requester" && user.role !== "admin" && !user.isHqStaff) {
        return res.status(403).json({ message: "토큰 발급 권한이 없습니다" });
      }

      // 요청자인 경우 본인 오더인지 확인
      if (user.role === "requester" && order.requesterId !== user.id) {
        return res.status(403).json({ message: "본인 오더에만 토큰을 발급할 수 있습니다" });
      }

      // SCHEDULED 상태에서만 토큰 발급 가능
      if (order.status !== "scheduled") {
        return res.status(400).json({ 
          message: "예정된 상태에서만 시작 토큰을 발급할 수 있습니다",
          currentStatus: order.status,
        });
      }

      // 기존 유효 토큰 무효화
      await db.update(orderStartTokens)
        .set({ isRevoked: true })
        .where(and(
          eq(orderStartTokens.orderId, orderId),
          sql`${orderStartTokens.usedAt} IS NULL`,
          eq(orderStartTokens.isRevoked, false)
        ));

      // 새 토큰 생성
      const token = randomUUID();
      const expiresAt = new Date();
      expiresAt.setHours(expiresAt.getHours() + expiryHours);

      const [newToken] = await db.insert(orderStartTokens).values({
        orderId,
        token,
        createdBy: user.id,
        createdByRole: user.role === "admin" || user.isHqStaff ? "ADMIN" : "REQUESTER",
        expiresAt,
      }).returning();

      // QR 코드 데이터 생성
      const qrData = `hellpme://order/${orderId}/start?token=${token}`;

      res.json({
        success: true,
        tokenId: newToken.id,
        token,
        qrData,
        expiresAt: expiresAt.toISOString(),
        expiryHours,
      });
    } catch (err) {
      console.error("Error creating QR start token:", err);
      res.status(500).json({ message: "토큰 생성에 실패했습니다" });
    }
  });

  // POST /api/orders/:orderId/qr/start/verify - QR 시작 토큰 검증 (헬퍼)
  app.post("/api/orders/:orderId/qr/start/verify", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);
      const { token } = req.body;

      if (!token) {
        return res.status(400).json({ code: "INVALID_INPUT", message: "토큰이 필요합니다" });
      }

      // 헬퍼만 검증 가능
      if (user.role !== "helper") {
        return res.status(403).json({ code: "FORBIDDEN", message: "헬퍼만 업무를 시작할 수 있습니다" });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ code: "NOT_FOUND", message: "오더를 찾을 수 없습니다" });
      }

      // 배정된 헬퍼인지 확인
      if (order.matchedHelperId !== user.id && order.helperId !== user.id) {
        return res.status(403).json({ code: "NOT_ASSIGNED", message: "배정된 기사만 시작할 수 있습니다" });
      }

      // 이미 업무중인지 확인
      if (order.status === "in_progress") {
        return res.status(400).json({ code: "ALREADY_STARTED", message: "이미 업무중 처리된 오더입니다" });
      }

      // SCHEDULED 상태에서만 시작 가능
      if (order.status !== "scheduled") {
        return res.status(400).json({ 
          code: "INVALID_STATUS",
          message: "예정된 상태에서만 업무를 시작할 수 있습니다",
          currentStatus: order.status,
        });
      }

      // 토큰 조회
      const [tokenRecord] = await db.select()
        .from(orderStartTokens)
        .where(and(
          eq(orderStartTokens.orderId, orderId),
          eq(orderStartTokens.token, token)
        ))
        .limit(1);

      if (!tokenRecord) {
        return res.status(400).json({ code: "INVALID_TOKEN", message: "유효하지 않은 QR입니다" });
      }

      // 토큰 만료 확인
      if (new Date() > tokenRecord.expiresAt) {
        return res.status(400).json({ code: "TOKEN_EXPIRED", message: "만료된 QR입니다" });
      }

      // 이미 사용된 토큰인지 확인
      if (tokenRecord.usedAt) {
        return res.status(400).json({ code: "TOKEN_USED", message: "이미 사용된 QR입니다" });
      }

      // 취소된 토큰인지 확인
      if (tokenRecord.isRevoked) {
        return res.status(400).json({ code: "TOKEN_REVOKED", message: "취소된 QR입니다" });
      }

      // 토큰 사용 처리
      await db.update(orderStartTokens)
        .set({
          usedAt: new Date(),
          usedBy: user.id,
        })
        .where(eq(orderStartTokens.id, tokenRecord.id));

      // 오더 상태 업데이트 (SCHEDULED → IN_PROGRESS)
      await storage.updateOrder(orderId, {
        status: "in_progress",
        checkedInAt: new Date(),
      });

      // 오더 상태 이벤트 기록
      await storage.createOrderStatusEvent({
        orderId,
        previousStatus: "scheduled",
        newStatus: "in_progress",
        reason: "QR 토큰 검증으로 업무 시작",
        changedBy: user.id,
      });

      // 감사 로그 기록
      await db.insert(auditLogs).values({
        actorRole: "HELPER",
        userId: user.id,
        action: "QR_START_VERIFIED",
        orderId,
        targetType: "order",
        targetId: String(orderId),
        reason: "QR 토큰으로 업무 시작",
        oldValue: JSON.stringify({ status: "scheduled" }),
        newValue: JSON.stringify({ status: "in_progress" }),
      });

      // 요청자에게 알림 + 푸시
      if (order.requesterId) {
        await storage.createNotification({
          userId: order.requesterId,
          type: "work_started" as any,
          title: "업무 시작",
          message: `${user.name || "헬퍼"}님이 ${order.companyName} 오더의 업무를 시작했습니다.`,
          data: JSON.stringify({ orderId, checkinTime: new Date().toISOString() }),
        });
        
        // 푸시 알림 발송
        sendPushToUser(order.requesterId, {
          title: "업무 시작",
          body: `${user.name || "헬퍼"}님이 ${order.companyName} 오더의 업무를 시작했습니다.`,
          url: `/orders/${orderId}`,
          tag: `work-started-${orderId}`,
        });
      }

      res.json({
        success: true,
        message: "업무가 시작되었습니다",
        newStatus: "in_progress",
        checkinTime: new Date().toISOString(),
      });
    } catch (err) {
      console.error("Error verifying QR start token:", err);
      res.status(500).json({ message: "토큰 검증에 실패했습니다" });
    }
  });

  // GET /api/orders/:orderId/qr/start/status - 현재 토큰 상태 조회
  app.get("/api/orders/:orderId/qr/start/status", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 권한 확인 (요청자/관리자/배정된 헬퍼)
      const isRequester = order.requesterId === user.id;
      const isHelper = order.matchedHelperId === user.id || order.helperId === user.id;
      const isAdmin = user.role === "admin" || user.isHqStaff;

      if (!isRequester && !isHelper && !isAdmin) {
        return res.status(403).json({ message: "접근 권한이 없습니다" });
      }

      // 최신 유효 토큰 조회
      const [latestToken] = await db.select()
        .from(orderStartTokens)
        .where(and(
          eq(orderStartTokens.orderId, orderId),
          eq(orderStartTokens.isRevoked, false)
        ))
        .orderBy(desc(orderStartTokens.createdAt))
        .limit(1);

      if (!latestToken) {
        return res.json({
          hasToken: false,
          orderStatus: order.status,
        });
      }

      const isExpired = new Date() > latestToken.expiresAt;
      const isUsed = !!latestToken.usedAt;

      res.json({
        hasToken: true,
        tokenStatus: isUsed ? "used" : isExpired ? "expired" : "valid",
        expiresAt: latestToken.expiresAt.toISOString(),
        usedAt: latestToken.usedAt?.toISOString() || null,
        orderStatus: order.status,
        // QR 데이터는 요청자/관리자에게만 표시
        qrData: (isRequester || isAdmin) && !isUsed && !isExpired 
          ? `hellpme://order/${orderId}/start?token=${latestToken.token}` 
          : null,
      });
    } catch (err) {
      console.error("Error getting QR token status:", err);
      res.status(500).json({ message: "토큰 상태 조회에 실패했습니다" });
    }
  });

  // 업무 종료 API (WORKING → CLOSED) - 마감 보고서 제출 후
  app.post("/api/orders/:orderId/end-work", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      // 헬퍼만 업무 종료 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 업무를 종료할 수 있습니다" });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 담당 헬퍼인지 확인
      if (order.matchedHelperId !== user.id) {
        return res.status(403).json({ message: "담당 헬퍼만 업무를 종료할 수 있습니다" });
      }

      // in_progress 상태에서만 업무 종료 가능
      if (order.status !== "in_progress") {
        return res.status(400).json({ 
          message: "진행 중 상태에서만 업무를 종료할 수 있습니다",
          currentStatus: order.status,
        });
      }

      // 마감 보고서가 있는지 확인
      const closureReport = await storage.getOrderClosureReport(orderId);
      if (!closureReport) {
        return res.status(400).json({ 
          message: "먼저 마감 보고서를 제출해주세요",
        });
      }

      // 오더 상태 업데이트 (WORKING → CLOSED)
      await storage.updateOrder(orderId, {
        status: "closed",
      });

      // 마감 보고서에 승인 시간 기록
      await storage.updateOrderClosureReport(closureReport.id, {
        approvedAt: new Date(),
        approvedBy: user.id,
      });

      // 오더 상태 이벤트 기록
      await storage.createOrderStatusEvent({
        orderId,
        previousStatus: "in_progress",
        newStatus: "closed",
        reason: "업무 완료 및 마감 보고서 제출",
        changedBy: user.id,
      });

      // 요청자에게 알림
      if (order.requesterId) {
        await storage.createNotification({
          userId: order.requesterId,
          type: "work_completed" as any,
          title: "업무 완료",
          message: `${user.name || "헬퍼"}님이 ${order.companyName} 오더의 업무를 완료했습니다.`,
          data: JSON.stringify({ orderId }),
        });
      }

      res.json({
        success: true,
        newStatus: "closed",
        closureReport,
      });
    } catch (err) {
      console.error("Error ending work:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 증빙 파일 업로드 API (헬퍼용)
  app.post("/api/orders/:orderId/proofs", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      // 헬퍼만 증빙 업로드 가능
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 증빙을 업로드할 수 있습니다" });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 담당 헬퍼인지 확인
      if (order.matchedHelperId !== user.id) {
        return res.status(403).json({ message: "담당 헬퍼만 증빙을 업로드할 수 있습니다" });
      }

      const { fileKey, fileName, fileType, proofType } = req.body;

      if (!fileKey) {
        return res.status(400).json({ message: "파일 키가 필요합니다" });
      }

      const proof = await storage.createCarrierProofUpload({
        orderId,
        helperUserId: user.id,
        fileKey,
        fileName: fileName || null,
        fileType: fileType || null,
        proofType: proofType || "delivery", // delivery, pickup, damage, etc.
      });

      res.status(201).json(proof);
    } catch (err) {
      console.error("Error uploading proof:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 증빙 파일 삭제 API (헬퍼용)
  app.delete("/api/orders/:orderId/proofs/:proofId", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);
      const proofId = Number(req.params.proofId);

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 담당 헬퍼 또는 관리자만 삭제 가능
      if (order.matchedHelperId !== user.id && !user.isHqStaff) {
        return res.status(403).json({ message: "삭제 권한이 없습니다" });
      }

      await storage.deleteCarrierProofUpload(proofId);
      res.json({ success: true });
    } catch (err) {
      console.error("Error deleting proof:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // Phase 3: 정산 통합 APIs - 계약금/잔여금 분리, 수수료 차감
  // ============================================

  // 잔여금 청구서 조회
  app.get("/api/orders/:orderId/balance-invoice", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 권한 확인
      const isOwner = order.requesterId === user.id || order.matchedHelperId === user.id;
      const isAdmin = user.isHqStaff;
      if (!isOwner && !isAdmin) {
        return res.status(403).json({ message: "조회 권한이 없습니다" });
      }

      const invoice = await storage.getOrderBalanceInvoice(orderId);
      res.json(invoice || null);
    } catch (err) {
      console.error("Error fetching balance invoice:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 잔여금 청구서 생성 (오더 마감 후 관리자가 생성)
  app.post("/api/orders/:orderId/balance-invoice", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      // 관리자만 잔여금 청구서 생성 가능
      if (!user.isHqStaff) {
        return res.status(403).json({ message: "관리자만 잔여금 청구서를 생성할 수 있습니다" });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // CLOSED 또는 SETTLEMENT_PAID 상태에서만 잔여금 청구서 생성 가능
      if (!["closed", "settlement_paid"].includes(order.status ?? "")) {
        return res.status(400).json({ 
          message: "마감된 오더에서만 잔여금 청구서를 생성할 수 있습니다",
          currentStatus: order.status,
        });
      }

      // 가격 스냅샷 확인
      const snapshot = await storage.getOrderPricingSnapshot(orderId);
      if (!snapshot) {
        return res.status(400).json({ message: "먼저 가격 재계산을 해주세요" });
      }

      // 기존 청구서 확인
      const existingInvoice = await storage.getOrderBalanceInvoice(orderId);
      if (existingInvoice) {
        return res.status(400).json({ message: "이미 잔여금 청구서가 존재합니다" });
      }

      // 잔금 금액 검증
      const balanceAmount = Number(snapshot.balanceKrw);
      
      // 음수 잔금 처리 (환불 필요 케이스)
      if (balanceAmount < 0) {
        return res.status(400).json({ 
          message: "잔금이 음수입니다. 환불 처리가 필요합니다.",
          balanceAmount,
          note: "계약금이 최종금액보다 많습니다. 관리자에게 문의하세요.",
        });
      }
      
      // 0원 잔금 처리 (결제 생략)
      if (balanceAmount === 0) {
        // 0원 청구서를 "paid"로 바로 생성
        const invoice = await storage.createBalanceInvoice({
          orderId,
          pricingSnapshotId: snapshot.id,
          balanceAmountKrw: 0,
          status: "paid",
          issuedAt: new Date(),
          issuedBy: user.id,
          paidAt: new Date(),
        });
        
        // 오더 상태 자동 변경 (BALANCE_PAID)
        await storage.updateOrder(orderId, { status: "balance_paid" });
        await storage.createOrderStatusEvent({
          orderId,
          previousStatus: order.status,
          newStatus: "balance_paid",
          reason: "잔금 0원 (자동 완료)",
          changedBy: user.id,
        });
        
        return res.status(201).json({ 
          invoice, 
          message: "잔금이 0원이므로 결제 없이 완료 처리되었습니다." 
        });
      }

      // 청구서 생성 (일반 케이스)
      const invoice = await storage.createBalanceInvoice({
        orderId,
        pricingSnapshotId: snapshot.id,
        balanceAmountKrw: balanceAmount,
        status: "pending",
        issuedAt: new Date(),
        issuedBy: user.id,
      });

      // 요청자에게 알림
      if (order.requesterId) {
        await storage.createNotification({
          userId: order.requesterId,
          type: "balance_invoice" as any,
          title: "잔여금 청구",
          message: `${order.companyName} 오더의 잔여금 ₩${Number(snapshot.balanceKrw).toLocaleString()}이 청구되었습니다.`,
          data: JSON.stringify({ orderId, invoiceId: invoice.id }),
        });
      }

      res.status(201).json(invoice);
    } catch (err) {
      console.error("Error creating balance invoice:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 잔여금 결제 확인 (입금 확인 후 관리자가 처리)
  app.patch("/api/orders/:orderId/balance-invoice/paid", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      // 관리자만 결제 확인 가능
      if (!user.isHqStaff) {
        return res.status(403).json({ message: "관리자만 결제를 확인할 수 있습니다" });
      }

      const invoice = await storage.getOrderBalanceInvoice(orderId);
      if (!invoice) {
        return res.status(404).json({ message: "잔여금 청구서를 찾을 수 없습니다" });
      }

      if (invoice.status !== "pending") {
        return res.status(400).json({ message: "이미 처리된 청구서입니다" });
      }

      const updated = await storage.updateBalanceInvoice(invoice.id, {
        status: "paid",
        paidAt: new Date(),
      });

      // 오더 상태 변경: FINAL_AMOUNT_CONFIRMED → BALANCE_PAID
      const order = await storage.getOrder(orderId);
      if (order) {
        await storage.updateOrder(orderId, {
          status: "balance_paid",
        });

        // 오더 상태 이벤트 기록
        await storage.createOrderStatusEvent({
          orderId,
          previousStatus: order.status,
          newStatus: "balance_paid",
          reason: "잔여금 결제 완료",
          changedBy: user.id,
        });
      }

      res.json(updated);
    } catch (err) {
      console.error("Error updating balance invoice:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 잔여금 결제 요청 (요청자가 결제 시작)
  // 스펙: POST /api/orders/{orderId}/balance-invoice/pay
  app.post("/api/orders/:orderId/balance-invoice/pay", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);
      const { payment_method, return_url } = req.body;

      // 요청자만 결제 가능
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ 
          error: { code: "ORDER_NOT_FOUND", message: "오더를 찾을 수 없습니다" } 
        });
      }

      if (order.requesterId !== user.id) {
        return res.status(403).json({ 
          error: { code: "FORBIDDEN", message: "요청자만 결제할 수 있습니다" } 
        });
      }

      // 잔여금 청구서 확인
      const invoice = await storage.getOrderBalanceInvoice(orderId);
      if (!invoice) {
        return res.status(404).json({ 
          error: { code: "INVOICE_NOT_FOUND", message: "잔여금 청구서가 없습니다" } 
        });
      }

      if (invoice.status !== "pending") {
        return res.status(400).json({ 
          error: { code: "INVALID_INVOICE_STATUS", message: "결제 대기 상태가 아닙니다" } 
        });
      }

      // 결제 금액
      const amount = Number(invoice.amount);

      // payments 테이블에 결제 요청 생성 (PortOne 연동 준비)
      const payment = await storage.createPayment({
        userId: user.id,
        amount,
        type: "balance",
        status: "pending",
        metadata: JSON.stringify({
          orderId,
          invoiceId: invoice.id,
          paymentMethod: payment_method || "CARD",
          returnUrl: return_url || "",
        }),
      });

      // 청구서에 결제 ID 연결
      await storage.updateBalanceInvoice(invoice.id, {
        paymentId: payment.id,
      });

      // PortOne 결제 URL 생성 (실제 SDK 연동 시 여기서 PortOne API 호출)
      // 현재는 결제 정보만 반환하고 클라이언트에서 PortOne SDK로 결제 진행
      res.json({
        invoice_id: String(invoice.id),
        status: "PENDING",
        payment: {
          payment_id: String(payment.id),
          provider: "PORTONE",
          amount,
          order_name: `오더 #${orderId} 잔여금`,
          customer_email: user.email,
        },
      });
    } catch (err) {
      console.error("Error initiating balance payment:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 정산 요약 조회 (오더별)
  app.get("/api/orders/:orderId/settlement-summary", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const orderId = Number(req.params.orderId);

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      // 권한 확인
      const isOwner = order.requesterId === user.id || order.matchedHelperId === user.id;
      const isAdmin = user.isHqStaff;
      if (!isOwner && !isAdmin) {
        return res.status(403).json({ message: "조회 권한이 없습니다" });
      }

      // 각 정보 조회
      const pricingSnapshot = await storage.getOrderPricingSnapshot(orderId);
      const costItems = await storage.getOrderCostItems(orderId);
      const balanceInvoice = await storage.getOrderBalanceInvoice(orderId);
      const closureReport = await storage.getOrderClosureReport(orderId);

      // 시스템 설정에서 수수료율 조회 (기본 12%)
      const commissionRateSetting = await storage.getSystemSetting("default_commission_rate");
      const commissionRatePercent = commissionRateSetting?.value ? parseFloat(commissionRateSetting.value) : 12;
      const baseAmount = pricingSnapshot ? Number(pricingSnapshot.baseSupplyAmount) : 0;
      const commissionAmount = Math.round(baseAmount * commissionRatePercent / 100);
      const helperPayout = baseAmount - commissionAmount;

      res.json({
        orderId,
        orderStatus: order.status,
        pricing: pricingSnapshot ? {
          baseSupplyAmount: Number(pricingSnapshot.baseSupplyAmount),
          costPlusTotal: Number(pricingSnapshot.costPlusTotal || 0),
          costMinusTotal: Number(pricingSnapshot.costMinusTotal || 0),
          vat: Number(pricingSnapshot.vatAmount),
          grossAmount: Number(pricingSnapshot.grossAmount),
          deposit: Number(pricingSnapshot.depositAmount),
          balance: Number(pricingSnapshot.balanceAmount),
        } : null,
        costItems: costItems.map(item => ({
          id: item.id,
          label: item.label,
          amount: Number(item.amount),
        })),
        balanceInvoice: balanceInvoice ? {
          id: balanceInvoice.id,
          amount: Number(balanceInvoice.amount),
          status: balanceInvoice.status,
          issuedAt: balanceInvoice.issuedAt,
          paidAt: balanceInvoice.paidAt,
        } : null,
        closureReport: closureReport ? {
          actualDeliveryCount: closureReport.actualDeliveryCount,
          anomalyFlag: closureReport.anomalyFlag,
          submittedAt: closureReport.submittedAt,
          approvedAt: closureReport.approvedAt,
        } : null,
        helperSettlement: {
          grossAmount: baseAmount,
          commissionRate,
          commissionAmount,
          netPayout: helperPayout,
        },
      });
    } catch (err) {
      console.error("Error fetching settlement summary:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Work confirmation routes
  // Get helper's completed orders for review
  app.get("/api/helper/completed-orders-for-review", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      // Get all completed contracts for this helper
      const contracts = await storage.getHelperContracts(userId);
      const completedContracts = contracts.filter(c => c.status === "completed");
      
      const ordersForReview = [];
      for (const contract of completedContracts) {
        const order = await storage.getOrder(contract.orderId);
        // Check for helper->requester review specifically
        const existingReview = await storage.getReviewByContractAndType(contract.id, "helper");
        
        if (order) {
          const requester = order.requesterId ? await storage.getUser(order.requesterId) : null;
          ordersForReview.push({
            id: order.id,
            orderId: order.id,
            contractId: contract.id,
            companyName: order.companyName,
            pricePerUnit: order.pricePerUnit,
            averageQuantity: order.averageQuantity,
            deliveryArea: order.deliveryArea,
            scheduledDate: order.scheduledDate,
            vehicleType: order.vehicleType,
            requesterId: order.requesterId,
            requesterName: requester?.name || "의뢰인",
            hasReview: !!existingReview,
          });
        }
      }
      
      res.json(ordersForReview);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper submits review for requester
  app.post("/api/helper/reviews", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 리뷰를 작성할 수 있습니다" });
      }
      
      const { contractId, orderId, requesterId, rating, comment } = req.body;
      
      if (!contractId || !orderId || !requesterId || !rating) {
        return res.status(400).json({ message: "필수 정보가 누락되었습니다" });
      }
      
      if (rating < 1 || rating > 5) {
        return res.status(400).json({ message: "평점은 1-5 사이여야 합니다" });
      }
      
      if (comment && comment.length > 100) {
        return res.status(400).json({ message: "리뷰는 100자 이내로 작성해주세요" });
      }
      
      // Check if helper->requester review already exists for this contract
      const existingReview = await storage.getReviewByContractAndType(contractId, "helper");
      if (existingReview) {
        return res.status(400).json({ message: "이미 리뷰를 작성했습니다" });
      }
      
      const review = await storage.createReview({
        contractId,
        orderId,
        helperId: userId,
        requesterId,
        reviewerType: "helper", // Helper reviewing requester
        rating,
        comment: comment || "",
      });
      
      res.status(201).json(review);
    } catch (err) {
      console.error("Helper review error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // GET /api/helper/settlement - 헬퍼 월별 정산 요약
  app.get("/api/helper/settlement", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }

      const year = parseInt(req.query.year as string) || new Date().getFullYear();
      const month = parseInt(req.query.month as string) || new Date().getMonth() + 1;

      // 해당 월의 시작/끝 날짜
      const startDate = new Date(year, month - 1, 1);
      const endDate = new Date(year, month, 0, 23, 59, 59);

      // 1. 마감 보고서 조회 (closing_submitted 상태 포함)
      const helperClosingReports = await db.select()
        .from(closingReports)
        .where(eq(closingReports.helperId, user.id));

      // 해당 월 마감 보고서의 오더 정보 조회
      const closingWorkDays = [];
      let closingSupplyAmount = 0;
      let closingVatAmount = 0;
      let closingDeductions = 0;

      for (const report of helperClosingReports) {
        const order = await storage.getOrder(report.orderId);
        if (!order) continue;

        // scheduledDate 기준으로 해당 월 확인
        const workDate = order.scheduledDate ? new Date(order.scheduledDate) : null;
        if (!workDate) continue;
        if (workDate < startDate || workDate > endDate) continue;
        // 통합 계산 모듈 사용 (Single Source of Truth)
        const closingData = parseClosingReport(report, order);
        const settlement = calculateSettlement(closingData);
        
        const deliveredCount = settlement.deliveredCount;
        const returnedCount = settlement.returnedCount;
        const pricePerUnit = closingData.unitPrice;
        const etcCount = settlement.etcCount;
        const etcAmount = settlement.etcAmount;
        const extraCostsTotal = settlement.extraCostsTotal;
        const supplyAmount = settlement.supplyAmount;
        const vatAmount = settlement.vatAmount;
        const dailyRate = settlement.totalAmount; // VAT 포함 총액
        closingSupplyAmount += supplyAmount;
        closingVatAmount += vatAmount;

        // 차감액 계산 (사고보고서 등에서)
        const incidentReportsForOrder = await db.select()
          .from(incidentReports)
          .where(eq(incidentReports.orderId, report.orderId));
        const orderDeductions = incidentReportsForOrder.reduce((sum, ir) => sum + (ir.deductionAmount || 0), 0);
        closingDeductions += orderDeductions;

        closingWorkDays.push({
          date: workDate.toISOString().split('T')[0],
          orderId: report.orderId,
          orderTitle: order.companyName || order.deliveryArea || '오더',
          pricePerUnit: order.pricePerUnit || 0,
          dailyRate: dailyRate, // VAT 포함 총액
          supplyAmount: supplyAmount, // 공급가
          vatAmount: vatAmount, // VAT
          deliveredCount: deliveredCount,
          returnedCount: report.returnedCount || 0,
          etcCount: etcCount,
          etcAmount: etcAmount,
          extraCostsTotal: extraCostsTotal,
          status: report.status,
          closingReportId: report.id,
          hasDeduction: orderDeductions > 0,
          deductionAmount: orderDeductions,
        });
      }

      // 2. 기존 정산서도 조회 (아직 마감 보고서가 없는 경우)
      const allSettlements = await storage.getAllSettlementStatements();
      const helperSettlements = allSettlements.filter(s => {
        if (s.helperId !== user.id) return false;
        if (!s.workDate) return false;
        const d = new Date(s.workDate);
        return d.getFullYear() === year && d.getMonth() + 1 === month;
      });

      // 중복 제거 (마감 보고서에 이미 있는 오더 제외)
      const closingOrderIds = new Set(closingWorkDays.map(w => w.orderId));
      const settlementWorkDays = await Promise.all(
        helperSettlements
          .filter(s => !closingOrderIds.has(s.orderId))
          .map(async (s) => {
            const order = s.orderId ? await storage.getOrder(s.orderId) : null;
            return {
              date: s.workDate,
              orderId: s.orderId,
              orderTitle: order?.companyName || order?.deliveryArea || '오더',
              dailyRate: s.basePay || 0,
              deliveredCount: 0,
              returnedCount: 0,
              status: s.status,
              hasDeduction: (s.deduction || 0) > 0,
              deductionAmount: s.deduction || 0,
            };
          })
      );

      // 전체 근무일 목록 합치기
      const workDays = [...closingWorkDays, ...settlementWorkDays].sort((a, b) => 
        new Date(a.date!).getTime() - new Date(b.date!).getTime()
      );

      // 합계 계산 (부가세 별도 기준)
      const settlementIncome = helperSettlements
        .filter(s => !closingOrderIds.has(s.orderId))
        .reduce((sum, s) => sum + (s.basePay || 0), 0);
      const supplyAmount = closingSupplyAmount + settlementIncome; // 공급가액 (VAT 별도)
      const vat = closingVatAmount + Math.round(settlementIncome * 0.1); // 부가세 10%
      const totalAmount = supplyAmount + vat; // 합계 (공급가액 + 부가세)
      
      // 수수료 계산 (시스템 설정 우선, 기본 12%)
      const helperPolicy = await storage.getCommissionPolicy("helper");
      const defaultCommissionSetting = await storage.getSystemSetting("default_commission_rate");
      const commissionRate = helperPolicy?.defaultRate ?? (defaultCommissionSetting?.value ? parseFloat(defaultCommissionSetting.value) : 12);
      const commissionAmount = Math.round(totalAmount * commissionRate / 100);
      
      const settlementDeductions = helperSettlements
        .filter(s => !closingOrderIds.has(s.orderId))
        .reduce((sum, s) => sum + (s.deduction || 0), 0);
      const deductions = closingDeductions + settlementDeductions;
      const payoutAmount = totalAmount - commissionAmount - deductions; // 지급액 (합계 - 수수료 - 차감액)

      res.json({
        supplyAmount, // 공급가액
        vat, // 부가세
        totalAmount, // 합계
        commissionRate, // 수수료율 (%)
        commissionAmount, // 수수료
        deductions, // 차감액
        payoutAmount, // 지급액
        workDays,
      });
    } catch (err) {
      console.error("Helper settlement error:", err);
      res.status(500).json({ message: "정산 정보를 불러오는데 실패했습니다" });
    }
  });

  // GET /api/helper/work-detail - 특정 날짜/오더 근무 상세
  app.get("/api/helper/work-detail", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }

      const date = req.query.date as string;
      const orderId = req.query.orderId ? parseInt(req.query.orderId as string) : null;
      
      if (!date && !orderId) {
        return res.status(400).json({ message: "날짜 또는 오더ID가 필요합니다" });
      }

      // 1. 먼저 마감 보고서에서 조회 시도
      let closingReport = null;
      let order = null;

      if (orderId) {
        // 오더 ID로 직접 조회
        const [report] = await db.select()
          .from(closingReports)
          .where(and(
            eq(closingReports.orderId, orderId),
            eq(closingReports.helperId, user.id)
          ))
          .limit(1);
        closingReport = report;
        order = await storage.getOrder(orderId);
      } else if (date) {
        // 날짜로 조회 - 마감 보고서가 있는 오더 찾기
        const helperReports = await db.select()
          .from(closingReports)
          .where(eq(closingReports.helperId, user.id));

        for (const report of helperReports) {
          const reportOrder = await storage.getOrder(report.orderId);
          if (reportOrder?.scheduledDate) {
            const orderDate = new Date(reportOrder.scheduledDate).toISOString().split('T')[0];
            if (orderDate === date) {
              closingReport = report;
              order = reportOrder;
              break;
            }
          }
        }
      }

      // 2. 마감 보고서가 없으면 정산서에서 조회
      let settlement = null;
      if (!closingReport) {
        const allSettlements = await storage.getAllSettlementStatements();
        settlement = allSettlements.find(s => {
          if (s.helperId !== user.id) return false;
          if (orderId && s.orderId === orderId) return true;
          if (date && s.workDate) {
            const settlementDate = new Date(s.workDate).toISOString().split('T')[0];
            return settlementDate === date;
          }
          return false;
        });

        if (settlement) {
          order = settlement.orderId ? await storage.getOrder(settlement.orderId) : null;
          // 해당 정산서의 오더에 대한 마감 보고서 조회
          if (settlement.orderId) {
            const [report] = await db.select()
              .from(closingReports)
              .where(eq(closingReports.orderId, settlement.orderId))
              .limit(1);
            closingReport = report;
          }
        }
      }

      if (!closingReport && !settlement) {
        return res.status(404).json({ message: "해당 날짜의 근무 정보를 찾을 수 없습니다" });
      }

      // 이미지 파싱
      const deliveryHistoryImages = closingReport?.deliveryHistoryImagesJson 
        ? JSON.parse(closingReport.deliveryHistoryImagesJson) 
        : [];
      const etcImages = closingReport?.etcImagesJson 
        ? JSON.parse(closingReport.etcImagesJson) 
        : [];
      const dynamicFields = closingReport?.dynamicFieldsJson
        ? JSON.parse(closingReport.dynamicFieldsJson)
        : {};

      // 사고보고서에서 차감액 조회
      const orderIdToCheck = closingReport?.orderId || settlement?.orderId;
      let deductionAmount = 0;
      let deductionReason = '';
      if (orderIdToCheck) {
        const orderIncidents = await db.select()
          .from(incidentReports)
          .where(eq(incidentReports.orderId, orderIdToCheck));
        deductionAmount = orderIncidents.reduce((sum, ir) => sum + (ir.deductionAmount || 0), 0);
        if (orderIncidents.length > 0) {
          deductionReason = orderIncidents.map(ir => ir.incidentType).join(', ');
        }
      }

      // 금액 계산 (pricePerUnit * (배송건수 + 반품건수))
      const pricePerUnit = order?.pricePerUnit || 0;
      const deliveredCountForCalc = closingReport?.deliveredCount || 0;
      const returnedCountForCalc = closingReport?.returnedCount || 0;
      const dailyRate = settlement?.basePay || (pricePerUnit * (deliveredCountForCalc + returnedCountForCalc));
      const supplyAmount = dailyRate; // 부가세 별도이므로 일급이 공급가액
      const vatAmount = Math.round(supplyAmount * 0.1); // 부가세 10%
      const totalAmount = supplyAmount + vatAmount; // 합계
      
      // 수수료 계산 (시스템 설정 우선, 기본 12%)
      const helperPolicyDetail = await storage.getCommissionPolicy("helper");
      const defaultCommissionSettingDetail = await storage.getSystemSetting("default_commission_rate");
      const commissionRateDetail = helperPolicyDetail?.defaultRate ?? (defaultCommissionSettingDetail?.value ? parseFloat(defaultCommissionSettingDetail.value) : 12);
      const commissionAmountDetail = Math.round(totalAmount * commissionRateDetail / 100);
      
      const netAmount = totalAmount - commissionAmountDetail - deductionAmount;

      res.json({
        orderId: closingReport?.orderId || settlement?.orderId,
        orderTitle: order?.companyName || order?.deliveryArea || '오더',
        companyName: order?.companyName,
        deliveryArea: order?.deliveryArea,
        workDate: order?.scheduledDate || settlement?.workDate,
        // 단가 정보
        pricePerUnit: order.pricePerUnit || 0,
        // 금액 정보 (부가세 별도 기준)
        dailyRate: dailyRate, // 공급가액 (= pricePerUnit * 배송건수)
        supplyAmount: supplyAmount, // 공급가액
        vatAmount: vatAmount, // 부가세 (10%)
        totalAmount: totalAmount, // 합계 (공급가액 + 부가세)
        commissionRate: commissionRateDetail, // 수수료율 (%)
        commissionAmount: commissionAmountDetail, // 수수료
        deductionAmount: deductionAmount,
        deductionReason: deductionReason,
        netAmount: netAmount, // 지급액 (합계 - 수수료 - 차감액)
        // 실적 정보
        deliveredCount: closingReport?.deliveredCount ?? 0,
        etcCount: closingReport?.etcCount ?? 0,
        etcPricePerUnit: closingReport?.etcPricePerUnit ?? 0,
        returnedCount: closingReport?.returnedCount ?? 0,
        closingText: closingReport?.memo || '',
        dynamicFields: dynamicFields,
        // 이미지
        deliveryHistoryImages,
        etcImages,
        // 상태
        status: closingReport?.status || settlement?.status,
        submittedAt: closingReport?.createdAt,
      });
    } catch (err) {
      console.error("Helper work detail error:", err);
      res.status(500).json({ message: "근무 정보를 불러오는데 실패했습니다" });
    }
  });

  // Get helper's work history (work confirmations)
  app.get("/api/helper/work-history", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      // First, try to get settlements from the settlement_statements table
      const allSettlements = await storage.getAllSettlementStatements();
      const helperSettlements = allSettlements.filter(s => s.helperId === userId);
      
      const workHistory = [];
      
      // Use settlement statements if available
      for (const settlement of helperSettlements) {
        const order = settlement.orderId ? await storage.getOrder(settlement.orderId) : null;
        
        // Calculate values from settlement (hiding commission from helper)
        const supplyAmount = settlement.supplyAmount || (settlement.basePay || 0) - (settlement.commissionAmount || 0);
        const taxAmount = settlement.vatAmount || Math.round(supplyAmount * 0.1);
        const deductionAmount = settlement.deduction || 0;
        const netAmount = settlement.netAmount || (supplyAmount + taxAmount - deductionAmount);
        
        workHistory.push({
          id: settlement.id,
          settlementId: settlement.id,
          date: settlement.workDate || order?.scheduledDate,
          companyName: order?.companyName || "-",
          deliveryArea: order?.deliveryArea || "-",
          deliveryCount: settlement.deliveryCount || 0,
          returnCount: settlement.returnCount || 0,
          pickupCount: settlement.pickupCount || 0,
          otherCount: settlement.otherCount || 0,
          supplyAmount,
          taxAmount,
          deductionAmount,
          deductionReason: settlement.holdReason || "",
          netAmount,
          status: settlement.status || "pending",
          helperConfirmed: settlement.helperConfirmed || false,
          helperConfirmedAt: settlement.helperConfirmedAt 
            ? (typeof settlement.helperConfirmedAt === 'string' ? settlement.helperConfirmedAt : settlement.helperConfirmedAt.toISOString())
            : null,
        });
      }
      
      // Fallback: Get from contracts if no settlements exist
      if (workHistory.length === 0) {
        const contracts = await storage.getHelperContracts(userId);
        const completedContracts = contracts.filter(c => c.status === "completed");
        
        for (const contract of completedContracts) {
          const order = await storage.getOrder(contract.orderId);
          const confirmation = await storage.getWorkConfirmationByContract(contract.id);
          
          if (order) {
            let deliveryCount = 0, returnCount = 0, pickupCount = 0, otherCount = 0;
            if (confirmation?.notes) {
              const deliveryMatch = confirmation.notes.match(/배송:\s*(\d+)/);
              const returnMatch = confirmation.notes.match(/반품:\s*(\d+)/);
              const pickupMatch = confirmation.notes.match(/수거:\s*(\d+)/);
              const otherMatch = confirmation.notes.match(/기타:\s*(\d+)/);
              if (deliveryMatch) deliveryCount = parseInt(deliveryMatch[1]);
              if (returnMatch) returnCount = parseInt(returnMatch[1]);
              if (pickupMatch) pickupCount = parseInt(pickupMatch[1]);
              if (otherMatch) otherCount = parseInt(otherMatch[1]);
            }
            
            const pricePerUnit = order.pricePerUnit || 0;
            const billableCount = deliveryCount + returnCount;
            const otherAmount = otherCount * 200;
            const supplyAmount = (billableCount * pricePerUnit) + otherAmount;
            const taxAmount = Math.floor(supplyAmount * 0.1);
            const deductionAmount = 0;
            const netAmount = supplyAmount + taxAmount - deductionAmount;
            
            workHistory.push({
              id: contract.id,
              settlementId: null,
              date: order.scheduledDate,
              companyName: order.companyName,
              deliveryArea: order.deliveryArea,
              deliveryCount,
              returnCount,
              pickupCount,
              otherCount,
              supplyAmount,
              taxAmount,
              deductionAmount,
              deductionReason: "",
              netAmount,
              status: confirmation?.status || "completed",
              helperConfirmed: false,
              helperConfirmedAt: null,
            });
          }
        }
      }
      
      res.json(workHistory);
    } catch (err) {
      console.error("Error in /api/helper/work-history:", err);
      res.status(500).json({ message: "Internal server error", error: err instanceof Error ? err.message : String(err) });
    }
  });

  // Helper: Get my disputes
  app.get("/api/helper/disputes", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const disputes = await storage.getDisputesByHelper(userId);
      res.json(disputes);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // GET /api/helper/disputes/:id - 헬퍼 이의제기 상세 조회
  app.get("/api/helper/disputes/:id", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const id = Number(req.params.id);
      const [dispute] = await db.select().from(disputes).where(
        and(eq(disputes.id, id), eq(disputes.helperId, userId))
      );
      
      if (!dispute) {
        return res.status(404).json({ message: "이의제기를 찾을 수 없습니다" });
      }
      
      // Get order info if exists
      let order = null;
      if (dispute.orderId) {
        const [orderData] = await db.select().from(orders).where(eq(orders.id, dispute.orderId));
        order = orderData;
      }
      
      // Get admin user info if replied
      let adminUser = null;
      if (dispute.adminReplyBy) {
        const [admin] = await db.select({ name: users.name }).from(users).where(eq(users.id, dispute.adminReplyBy));
        adminUser = admin;
      }
      
      res.json({
        ...dispute,
        order: order ? { ...order, helperName } : null,
        adminUserName: adminUser?.name || null,
      });
    } catch (err) {
      console.error("Get helper dispute detail error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==========================================
  // 헬퍼 사고 관련 API
  // ==========================================

  // GET /api/helper/incidents - 헬퍼가 관련된 사고 목록 조회
  app.get("/api/helper/incidents", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근할 수 있습니다" });
      }

      const incidents = await db.select({
        id: incidentReports.id,
        orderId: incidentReports.orderId,
        incidentType: incidentReports.incidentType,
        incidentDate: incidentReports.incidentDate,
        description: incidentReports.description,
        status: incidentReports.status,
        helperStatus: incidentReports.helperStatus,
        helperActionAt: incidentReports.helperActionAt,
        helperNote: incidentReports.helperNote,
        createdAt: incidentReports.createdAt,
        resolvedAt: incidentReports.resolvedAt,
      })
      .from(incidentReports)
      .where(eq(incidentReports.helperId, user.id))
      .orderBy(desc(incidentReports.createdAt));

      const formattedIncidents = incidents.map(inc => ({
        ...inc,
        createdAt: inc.createdAt?.toISOString() || null,
        resolvedAt: inc.resolvedAt?.toISOString() || null,
        helperActionAt: inc.helperActionAt?.toISOString() || null,
      }));

      res.json(formattedIncidents);
    } catch (err) {
      console.error("Get helper incidents error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // GET /api/helper/incidents/:id - 헬퍼 사고 상세 조회
  app.get("/api/helper/incidents/:id", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근할 수 있습니다" });
      }

      const id = Number(req.params.id);
      const [incident] = await db.select()
        .from(incidentReports)
        .where(and(
          eq(incidentReports.id, id),
          eq(incidentReports.helperId, user.id)
        ));

      if (!incident) {
        return res.status(404).json({ message: "사고를 찾을 수 없습니다" });
      }
      // Get order info with helper name
      let order = null;
      let helperName = null;
      if (incident.orderId) {
        const [orderData] = await db.select({
          id: orders.id,
          campAddress: orders.campAddress,
          deliveryArea: orders.deliveryArea,
          scheduledDate: orders.scheduledDate,
          courierCompany: orders.courierCompany,
          averageQuantity: orders.averageQuantity,
          matchedHelperId: orders.matchedHelperId,
        }).from(orders).where(eq(orders.id, incident.orderId));
        order = orderData;
        
        // Get helper name
        if (orderData?.matchedHelperId) {
          const [helperData] = await db.select({ name: users.name })
            .from(users)
            .where(eq(users.id, orderData.matchedHelperId));
          helperName = helperData?.name || null;
        }
      }

      // Get requester info
      let requester = null;
      if (incident.requesterId) {
        const [requesterData] = await db.select({
          name: users.name,
          phone: users.phone,
        }).from(users).where(eq(users.id, incident.requesterId));
        requester = requesterData;
      }

      // Get evidence
      const evidence = await db.select()
        .from(incidentEvidence)
        .where(eq(incidentEvidence.incidentId, id));

      // 날짜 필드를 ISO 문자열로 변환
      const formattedIncident = {
        ...incident,
        createdAt: incident.createdAt?.toISOString() || null,
        resolvedAt: incident.resolvedAt?.toISOString() || null,
        helperActionAt: incident.helperActionAt?.toISOString() || null,
      };

      res.json({
        ...formattedIncident,
        order: order ? { ...order, helperName } : null,
        requester,
        evidence,
      });
    } catch (err) {
      console.error("Get helper incident detail error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // POST /api/helper/incidents/:id/action - 헬퍼 사고 대응 액션
  app.post("/api/helper/incidents/:id/action", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근할 수 있습니다" });
      }

      const id = Number(req.params.id);
      const { action, note } = req.body;

      // action: item_found (물건찾음), request_handling (처리요망), confirmed (확인완료)
      const validActions = ['item_found', 'recovered', 'redelivered', 'damage_confirmed', 'request_handling', 'confirmed', 'dispute'];
      if (!validActions.includes(action)) {
        return res.status(400).json({ message: "유효하지 않은 액션입니다" });
      }

      // Check if incident belongs to helper
      const [incident] = await db.select()
        .from(incidentReports)
        .where(and(
          eq(incidentReports.id, id),
          eq(incidentReports.helperId, user.id)
        ));

      if (!incident) {
        return res.status(404).json({ message: "사고를 찾을 수 없습니다" });
      }

      // Update incident with helper action
      await db.update(incidentReports)
        .set({
          helperStatus: action,
          helperActionAt: new Date(),
          helperNote: note || null,
          updatedAt: new Date(),
        })
        .where(eq(incidentReports.id, id));

      // Add action log
      await db.insert(incidentActions).values({
        incidentId: id,
        actorId: user.id,
        actorRole: 'helper',
        actionType: `helper_${action}`,
        notes: note || null,
      });

      // Notify requester about helper action
      if (incident.requesterId) {
        const actionLabels: Record<string, string> = {
          item_found: '물건을 찾았습니다',
          recovered: '오배송 회수 완료',
          redelivered: '재배송 완료',
          damage_confirmed: '파손 확인',
          request_handling: '처리를 요망합니다',
          confirmed: '사고를 확인했습니다',
          dispute: '이의를 제기했습니다',
        };
        sendPushToUser(incident.requesterId, {
          title: '사고 처리 업데이트',
          body: `헬퍼가 "${actionLabels[action]}"(으)로 응답했습니다.`,
          data: { type: 'incident_update', incidentId: id },
        });
      }

      res.json({ message: "액션이 처리되었습니다", action });
    } catch (err) {
      console.error("Helper incident action error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });


  // Helper: Create a dispute (이의제기 신청)
  app.post("/api/helper/disputes", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 이의제기를 신청할 수 있습니다" });
      }
      
      const { 
        settlementId, 
        orderId, 
        workDate, 
        disputeType, 
        description,
        courierName,
        invoiceNumber,
        evidencePhotoUrl,
        requestedDeliveryCount,
        requestedReturnCount,
        requestedPickupCount,
        requestedOtherCount
      } = req.body;
      
      if (!workDate || !disputeType || !description) {
        return res.status(400).json({ message: "필수 항목을 입력해주세요" });
      }
      
      const dispute = await storage.createDispute({
        helperId: userId,
        submitterRole: "helper",
        settlementId: settlementId || null,
        orderId: orderId || null,
        workDate,
        disputeType,
        description,
        courierName: courierName || null,
        invoiceNumber: invoiceNumber || null,
        evidencePhotoUrl: evidencePhotoUrl || null,
        requestedDeliveryCount: requestedDeliveryCount || null,
        requestedReturnCount: requestedReturnCount || null,
        requestedPickupCount: requestedPickupCount || null,
        requestedOtherCount: requestedOtherCount || null,
        status: "pending",
      });

      // Send push notification to the helper
      sendPushToUser(userId, {
        title: "이의제기 접수 완료",
        body: `${workDate} 작업건에 대한 이의제기가 접수되었습니다.`,
        url: "/work-history",
        tag: `dispute-${dispute.id}`,
      });
      
      // Notify admins via WebSocket
      broadcastToAllAdmins("dispute", "created", dispute.id, {
        disputeId: dispute.id,
        helperId: userId,
        helperName: user.name || user.username,
        workDate,
        disputeType,
        description,
      });
      
      // Send push notification to all admins
      sendPushToAdmins({
        title: "새 이의제기 접수",
        body: `${user.name || user.username}님이 ${workDate} 작업건에 대해 이의제기를 접수했습니다.`,
        url: "/disputes",
        tag: `admin-dispute-${dispute.id}`,
      });
      
      console.log(`[Dispute] New dispute created by helper ${userId}: ${disputeType} for ${workDate}`);
      
      res.status(201).json({ 
        success: true, 
        message: "이의제기가 접수되었습니다.",
        dispute 
      });
    } catch (err) {
      console.error("Create dispute error:", err);
      res.status(500).json({ message: "이의제기 접수에 실패했습니다" });
    }
  });

  // Helper: Get service areas (배송가능 지역)
  app.get("/api/helper/service-areas", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const areas = await storage.getHelperServiceAreas(userId);
      res.json(areas);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper: Set service areas (배송가능 지역 설정)
  app.post("/api/helper/service-areas", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const { areas } = req.body;
      if (!Array.isArray(areas)) {
        return res.status(400).json({ message: "지역 목록이 필요합니다" });
      }
      
      const savedAreas = await storage.setHelperServiceAreas(userId, areas);
      res.json({ success: true, areas: savedAreas });
    } catch (err) {
      console.error("Set service areas error:", err);
      res.status(500).json({ message: "지역 설정에 실패했습니다" });
    }
  });

  app.post("/api/work-confirmations", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const { contractId, orderId, proofImageUrl, notes, deliveryCount, returnCount, pickupCount, otherCount } = req.body;
      
      const confirmation = await storage.createWorkConfirmation({
        contractId,
        orderId,
        helperId: userId,
        proofImageUrl,
        notes,
        status: "submitted",
        deliveryCount: deliveryCount || 0,
        returnCount: returnCount || 0,
        pickupCount: pickupCount || 0,
        otherCount: otherCount || 0,
      });
      
      res.status(201).json(confirmation);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/work-confirmations/:contractId", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const confirmation = await storage.getWorkConfirmationByContract(Number(req.params.contractId));
      if (!confirmation) {
        return res.status(404).json({ message: "Work confirmation not found" });
      }
      res.json(confirmation);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/work-confirmations/:id/confirm", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const confirmation = await storage.updateWorkConfirmation(Number(req.params.id), {
        status: "confirmed",
      });
      
      res.json(confirmation);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get work confirmations for an order (for requester)
  app.get("/api/orders/:orderId/work-confirmations", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const order = await storage.getOrder(Number(req.params.orderId));
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      // Verify requester owns this order
      const { balancePaymentDate } = req.body;
      
      if (!balancePaymentDate) {
        return res.status(400).json({ message: "잔금 결제 예정일을 선택해주세요" });
      }
      
      if (order.requesterId !== userId) {
        return res.status(403).json({ message: "권한이 없습니다" });
      }
      
      const confirmations = await storage.getWorkConfirmationsByOrder(Number(req.params.orderId));
      
      // Enhance with helper info using structured fields
      const enhancedConfirmations = await Promise.all(confirmations.map(async (conf) => {
        const helper = await storage.getUser(conf.helperId);
        const contract = await storage.getContract(conf.contractId);
        
        // Use structured fields directly, fallback to notes parsing for legacy data
        let deliveryCount = conf.deliveryCount ?? 0;
        let returnCount = conf.returnCount ?? 0;
        let pickupCount = conf.pickupCount ?? 0;
        let otherCount = conf.otherCount ?? 0;
        
        // Fallback: parse notes for legacy data without structured fields
        if (deliveryCount === 0 && returnCount === 0 && pickupCount === 0 && otherCount === 0) {
          const notes = conf.notes || "";
          const deliveryMatch = notes.match(/배송:\s*(\d+)/);
          const returnMatch = notes.match(/반품:\s*(\d+)/);
          const pickupMatch = notes.match(/집하:\s*(\d+)/) || notes.match(/수거:\s*(\d+)/);
          const otherMatch = notes.match(/기타:\s*(\d+)/);
          
          deliveryCount = deliveryMatch ? parseInt(deliveryMatch[1]) : 0;
          returnCount = returnMatch ? parseInt(returnMatch[1]) : 0;
          pickupCount = pickupMatch ? parseInt(pickupMatch[1]) : 0;
          otherCount = otherMatch ? parseInt(otherMatch[1]) : 0;
        }
        
        return {
          ...conf,
          helperName: helper?.name || "Unknown",
            helperNickname: (helper as any)?.nickname || null,
          helperPhone: helper?.phoneNumber || "",
          contractAmount: contract?.totalAmount || 0,
          depositAmount: contract?.depositAmount || 0,
          remainingAmount: contract?.balanceAmount || 0,
          deliveryCount,
          returnCount,
          pickupCount,
          otherCount,
        };
      }));
      
      res.json(enhancedConfirmations);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Review routes
  app.post("/api/reviews", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const { contractId, orderId, helperId, rating, comment } = req.body;
      
      // Check for requester->helper review specifically
      const existingReview = await storage.getReviewByContractAndType(contractId, "requester");
      if (existingReview) {
        return res.status(400).json({ message: "이미 리뷰를 작성했습니다" });
      }
      
      const review = await storage.createReview({
        contractId,
        orderId,
        requesterId: userId,
        helperId: null,
        trackingNumber: null,
        reviewerType: "requester", // Requester reviewing helper
        rating,
        comment,
      });
      
      res.status(201).json(review);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/reviews/helper/:helperId", async (req, res) => {
    try {
      const reviews = await storage.getHelperReviews(req.params.helperId);
      const avgRating = await storage.getHelperAverageRating(req.params.helperId);
      res.json({ reviews, averageRating: avgRating });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get my reviews (requester)
  app.get("/api/reviews/my", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // Get reviews written by this user
      const allReviews = await storage.getReviewsByReviewer(userId);
      
      // Enhance with order info
      const reviewsWithDetails = await Promise.all(allReviews.map(async (review) => {
        const order = await storage.getOrder(review.orderId);
        const helper = await storage.getUser(review.helperId);
        return {
          id: review.id,
          orderId: review.orderId,
          helperName: helper?.name || "Unknown",
            helperNickname: (helper as any)?.nickname || null,
          rating: review.rating,
          comment: review.comment,
          courierCompany: order?.companyName || "",
          workDate: order?.scheduledDate || "",
          createdAt: review.createdAt,
        };
      }));
      
      res.json(reviewsWithDetails);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get orders pending review (requester)
  app.get("/api/orders/review-pending", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      if (user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 접근 가능합니다" });
      }
      
      // Get requester's completed orders (balance_paid, settlement_paid, closed)
      const orders = await storage.getOrdersByRequesterId(userId);
      const completedOrders = orders.filter(o => 
        o.status === "balance_paid" || o.status === "settlement_paid" || o.status === "closed"
      );
      
      const pendingOrders = [];
      for (const order of completedOrders) {
        // Get contracts for this order
        const contracts = await storage.getOrderContracts(order.id);
        
        for (const contract of contracts) {
          if (contract.status === "completed") {
            // Check if review exists for this contract
            const existingReview = await storage.getReviewByContract(contract.id);
            if (!existingReview) {
              const helper = await storage.getUser(contract.helperId);
              pendingOrders.push({
                id: order.id,
                contractId: contract.id,
                courierCompany: order.companyName,
                workDate: order.scheduledDate,
                helperName: helper?.name || "Unknown",
            helperNickname: (helper as any)?.nickname || null,
              });
            }
          }
        }
      }
      
      res.json(pendingOrders);
    } catch (err) {
      console.error("Review pending orders error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 오더 수정 (의뢰인만 가능, 매칭 전 상태만)
  app.patch("/api/orders/:id", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const orderId = Number(req.params.id);
      const order = await storage.getOrder(orderId);
      
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }
      
      const { balancePaymentDate } = req.body;
      
      if (!balancePaymentDate) {
        return res.status(400).json({ message: "잔금 결제 예정일을 선택해주세요" });
      }
      
      if (order.requesterId !== userId) {
        return res.status(403).json({ message: "수정 권한이 없습니다" });
      }
      
      // 매칭완료 이상 상태는 수정 불가 (표준)
      const editOrderStatus = normalizeOrderStatus(order.status);
      if (isOneOfStatus(editOrderStatus, CANNOT_EDIT_STATUSES)) {
        return res.status(400).json({ message: "매칭 완료된 오더는 수정할 수 없습니다" });
      }
      
      const { pricePerUnit, deliveryArea, scheduledDate, vehicleType, requestDateEnd } = req.body;
      
      const updates: Record<string, any> = {};
      if (pricePerUnit !== undefined) updates.pricePerUnit = parseInt(pricePerUnit);
      if (deliveryArea !== undefined) updates.deliveryArea = deliveryArea;
      if (scheduledDate !== undefined) updates.scheduledDate = scheduledDate;
      if (vehicleType !== undefined) updates.vehicleType = vehicleType;
      if (requestDateEnd !== undefined) updates.requestDateEnd = requestDateEnd;
      
      const updated = await storage.updateOrder(orderId, updates);
      
      res.json({ message: "오더가 수정되었습니다", order: updated });
    } catch (err) {
      console.error("Update order error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });


  // 오더 숨기기 (의뢰인 홈에서 숨김)
  app.post("/api/orders/:id/hide", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const orderId = Number(req.params.id);
      const order = await storage.getOrder(orderId);
      
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }
      
      if (order.requesterId !== userId) {
        return res.status(403).json({ message: "권한이 없습니다" });
      }
      
      await storage.updateOrder(orderId, { hiddenAt: new Date() });
      res.json({ success: true, message: "오더가 숨겨졌습니다" });
    } catch (err) {
      console.error("Hide order error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 오더 삭제 (의뢰인만 가능, 매칭 전 상태만)
  app.delete("/api/orders/:id", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const orderId = Number(req.params.id);
      const order = await storage.getOrder(orderId);
      
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }
      
      const { balancePaymentDate } = req.body;
      
      if (!balancePaymentDate) {
        return res.status(400).json({ message: "잔금 결제 예정일을 선택해주세요" });
      }
      
      if (order.requesterId !== userId) {
        return res.status(403).json({ message: "삭제 권한이 없습니다" });
      }
      
      // 매칭완료 이상 상태는 삭제 불가 (표준)
      const deleteOrderStatus = normalizeOrderStatus(order.status);
      if (isOneOfStatus(deleteOrderStatus, CANNOT_DELETE_STATUSES)) {
        return res.status(400).json({ message: "매칭 완료된 오더는 삭제할 수 없습니다" });
      }
      
      await storage.deleteOrder(orderId);
      
      res.json({ message: "오더가 삭제되었습니다" });
    } catch (err) {
      console.error("Delete order error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 헬퍼 선택 (applied → selected 상태 변경)
  app.post("/api/orders/:id/select-helper", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const orderId = Number(req.params.id);
      const { helperId } = req.body;
      // totalAmount는 클라이언트에서 받지 않고 서버에서 재계산 (금액 조작 방지)
      
      // 멱등성 체크: 중복 선택 방지
      const idempotencyKey = getIdempotencyKeyFromRequest(req);
      if (idempotencyKey) {
        const { isDuplicate, cachedResponse } = await checkIdempotency(
          userId,
          `POST:/api/orders/${orderId}/select-helper`,
          idempotencyKey
        );
        if (isDuplicate && cachedResponse) {
          console.log(`[Idempotency] Returning cached select-helper for order ${orderId}, key: ${idempotencyKey}`);
          return res.status(cachedResponse.status).json(cachedResponse.body);
        }
      }
      
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      // 이미 선택 완료된 경우 (idempotent 응답)
      if (order.status === "scheduled" && order.matchedHelperId === helperId) {
        const existingContract = await storage.getOrderContract(orderId);
        if (existingContract) {
          return res.json({ contract: existingContract, message: "이미 헬퍼가 선택되었습니다." });
        }
      }
      
      // 다른 헬퍼가 이미 선택된 경우
      if (order.status === "scheduled" && order.matchedHelperId && order.matchedHelperId !== helperId) {
        return res.status(409).json({ message: "이미 다른 헬퍼가 선택되었습니다" });
      }
      
      if ((order.currentHelpers || 0) >= (order.maxHelpers || 3)) {
        return res.status(400).json({ message: "최대 헬퍼 수에 도달했습니다" });
      }
      
      const application = await storage.getOrderApplication(orderId, helperId);
      if (!application) {
        return res.status(404).json({ message: "Application not found" });
      }
      
      const helper = await storage.getUser(helperId);
      const requester = await storage.getUser(userId);
      
      // 헬퍼의 실효 수수료율 스냅샷 저장 (매칭 시점 값 보존)
      const effectiveRate = await storage.getEffectiveCommissionRate(helperId);
      
      // 헬퍼 상태를 selected로 변경 (매칭중) + 수수료 스냅샷 저장
      await storage.updateOrderApplication(application.id, { 
        status: "selected",
        selectedAt: new Date(),
        snapshotCommissionRate: effectiveRate.rate,
        snapshotPlatformRate: effectiveRate.platformRate,
        snapshotTeamLeaderRate: effectiveRate.teamLeaderRate,
        snapshotTeamLeaderId: effectiveRate.teamLeaderId,
        snapshotSource: effectiveRate.source,
      });
      
      // A안: 선택된 헬퍼 외 다른 지원자들 자동 REJECTED 처리
      const allApplications = await storage.getOrderApplications(orderId);
      for (const app of allApplications) {
        if (app.id !== application.id && app.status === "applied") {
          await storage.updateOrderApplication(app.id, { 
            status: "rejected",
            rejectedAt: new Date(),
            rejectionReason: "다른 헬퍼가 선택되었습니다",
          });
          // 탈락 알림
          await storage.createNotification({
            type: "application_rejected",
            title: "지원 결과 안내",
            message: `${order.companyName} 오더에 다른 헬퍼가 배정되었습니다.`,
            relatedId: orderId,
          });
        }
      }

      // 같은 입차일의 다른 오더 지원 자동 취소 (중복 배정 방지)
      if (order.scheduledDate) {
        const otherApplications = await storage.getHelperAppliedApplicationsByDate(
          helperId, order.scheduledDate, orderId
        );
        if (otherApplications.length > 0) {
          const applicationIds = otherApplications.map(a => a.applicationId);
          await storage.cancelApplicationsByIds(applicationIds);
          console.log(`[Select Helper] Auto-cancelled ${applicationIds.length} applications for helper ${helperId} on same date`);
        }
      }
      
      const newHelperCount = (order.currentHelpers || 0) + 1;
      
      // 레이스 컨디션 방지: 조건부 업데이트 (matchedHelperId가 null인 경우만)
      const updateResult = await db.update(orders)
        .set({
          currentHelpers: newHelperCount,
          status: "scheduled",
          requesterPhone: requester?.phoneNumber || null,
          helperPhoneShared: true,
          updatedAt: new Date(),
        })
        .where(and(
          eq(orders.id, orderId),
          or(
            isNull(orders.matchedHelperId),
            eq(orders.matchedHelperId, helperId) // 멱등성: 같은 헬퍼 재선택 허용
          )
        ))
        .returning();
      
      // 업데이트 실패 = 다른 헬퍼가 이미 선택됨
      if (updateResult.length === 0) {
        return res.status(409).json({ 
          code: "ALREADY_MATCHED",
          message: "다른 요청에서 이미 헬퍼가 선택되었습니다. 새로고침해주세요." 
        });
      }
      
      // 서버에서 금액 재계산 (금액 조작 방지)
      // averageQuantity에서 숫자만 추출
      const boxCount = parseInt((order.averageQuantity || '0').replace(/[^0-9]/g, '')) || 0;
      const pricePerUnit = order.pricePerUnit || 0;
      
      // 공급가 계산: 박스수 × 단가
      const supplyAmount = boxCount * pricePerUnit;
      
      // VAT 포함 금액
      const totalWithVat = Math.round(supplyAmount * 1.1);
      
      // 계약금 20%, 잔금 80%
      const depositAmount = Math.floor(totalWithVat * 0.2);
      const balanceAmount = totalWithVat - depositAmount;
      
      // 계산된 공급가를 totalAmount로 사용 (계약 저장용)
      const totalAmount = supplyAmount;
      
      const contract = await storage.createContract({
        orderId,
        requesterId: userId,
        helperId: null,
        trackingNumber: null,
        totalAmount,
        depositAmount,
        balanceAmount,
        depositPaid: false,
        balancePaid: false,
        status: "pending",
      });
      
      const orderCardPayload = JSON.stringify({
        orderId,
        companyName: order.companyName,
        deliveryArea: order.deliveryArea,
        scheduledDate: order.scheduledDate,
        pricePerUnit: order.pricePerUnit,
        averageQuantity: order.averageQuantity,
        vehicleType: order.vehicleType,
        regionMapUrl: order.regionMapUrl,
        deliveryGuideUrl: order.deliveryGuideUrl,
      });
      
      // 헬퍼에게 선택됨 알림 (매칭중)
      await storage.createNotification({
        type: "helper_selected",
        title: "오더 매칭중",
        message: `${order.companyName} 오더에 선택되었습니다. 매칭완료를 기다려주세요.`,
        relatedId: orderId,
        payload: orderCardPayload,
      });
      
      // WebSocket 알림
      notificationWS.sendToUser(helperId, {
        type: "helper_selected",
        title: "오더 매칭중",
        message: `${order.companyName} 오더에 선택되었습니다.`,
        relatedId: orderId,
        payload: orderCardPayload,
      });
      
      // 푸시 알림
      sendPushToUser(helperId, {
        title: "오더 매칭중",
        body: `${order.companyName} 오더에 선택되었습니다. 매칭완료를 기다려주세요.`,
        url: "/helper-dashboard",
        tag: `selected-${orderId}`,
      });
      
      // 관리자에게 브로드캐스트
      broadcastToAllAdmins("order_status", "helper_selected", orderId, {
        orderId,
        helperName: helper?.name,
        companyName: order.companyName,
        currentHelpers: newHelperCount,
      });
      
      const response = { contract, message: "헬퍼가 선택되었습니다. 매칭완료 버튼을 눌러주세요." };
      
      // 멱등성 응답 저장
      if (idempotencyKey) {
        await storeIdempotencyResponse(userId, `POST:/api/orders/${orderId}/select-helper`, idempotencyKey, 200, response);
      }
      
      res.json(response);
    } catch (err) {
      console.error("[select-helper] Error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 매칭완료 확정 (selected → scheduled 상태 변경)
  app.post("/api/orders/:id/confirm-matching", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const orderId = Number(req.params.id);
      
      // 멱등성 체크: 중복 매칭확정 방지
      const idempotencyKey = getIdempotencyKeyFromRequest(req);
      if (idempotencyKey) {
        const { isDuplicate, cachedResponse } = await checkIdempotency(
          userId,
          `POST:/api/orders/${orderId}/confirm-matching`,
          idempotencyKey
        );
        if (isDuplicate && cachedResponse) {
          console.log(`[Idempotency] Returning cached confirm-matching for order ${orderId}, key: ${idempotencyKey}`);
          return res.status(cachedResponse.status).json(cachedResponse.body);
        }
      }
      
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      // 의뢰인 권한 확인
      const { balancePaymentDate } = req.body;
      
      if (!balancePaymentDate) {
        return res.status(400).json({ message: "잔금 결제 예정일을 선택해주세요" });
      }
      
      if (order.requesterId !== userId) {
        return res.status(403).json({ message: "권한이 없습니다" });
      }
      
      // 선택된 헬퍼 조회
      const applications = await storage.getOrderApplications(orderId);
      const selectedApplications = applications.filter(a => a.status === "selected");
      
      if (selectedApplications.length === 0) {
        return res.status(400).json({ message: "선택된 헬퍼가 없습니다" });
      }
      
      const requester = await storage.getUser(userId);
      
      // 선택된 모든 헬퍼를 scheduled 상태로 변경 + 같은 날짜 다른 오더 신청 자동취소
      for (const app of selectedApplications) {
        // 스냅샷이 없으면 현재 시점에서 캡처 (select-helper를 거치지 않은 경우)
        let snapshotUpdate: Record<string, any> = {};
        if (app.snapshotCommissionRate == null || app.snapshotPlatformRate == null || app.snapshotTeamLeaderRate == null) {
          const effectiveRate = await storage.getEffectiveCommissionRate(app.helperId);
          snapshotUpdate = {
            snapshotCommissionRate: effectiveRate.rate,
            snapshotPlatformRate: effectiveRate.platformRate,
            snapshotTeamLeaderRate: effectiveRate.teamLeaderRate,
            snapshotTeamLeaderId: effectiveRate.teamLeaderId,
            snapshotSource: effectiveRate.source,
          };
          console.log(`[Matching] Snapshot captured for application ${app.id}: ${effectiveRate.rate}% (${effectiveRate.source})`);
        }
        
        await storage.updateOrderApplication(app.id, {
          status: "scheduled",
          scheduledAt: new Date(),
          ...snapshotUpdate,
        });
        
        const helper = await storage.getUser(app.helperId);
        
        // 같은 날짜 다른 오더 신청 자동취소 (중복 매칭 방지)
        // 단, 업무마감(completed/closed) 상태가 아닌 신청만 취소
        const helperApps = await storage.getHelperApplications(app.helperId);
        for (const otherApp of helperApps) {
          // 현재 오더 또는 이미 처리된 신청은 스킵
          if (otherApp.orderId === orderId || 
              otherApp.status === "completed" || 
              otherApp.status === "rejected" ||
              otherApp.status === "cancelled") {
            continue;
          }
          
          // 다른 오더의 날짜 확인
          const otherOrder = await storage.getOrder(otherApp.orderId);
          if (otherOrder && otherOrder.scheduledDate === order.scheduledDate) {
            // 같은 날짜의 다른 신청은 자동취소
            await storage.updateOrderApplication(otherApp.id, {
              status: "cancelled",
              processedAt: new Date(),
            });
            
            // 자동취소 알림
            await storage.createNotification({
              type: "application_auto_cancelled",
              title: "신청 자동취소",
              message: `${otherOrder.companyName} 오더 신청이 자동취소되었습니다. (동일 날짜 중복 매칭 불가)`,
              relatedId: otherApp.orderId,
            });
          }
        }
        
        // 헬퍼에게 매칭완료 알림
        await storage.createNotification({
          type: "matching_completed",
          title: "매칭 완료",
          message: `${order.companyName} 오더 매칭이 완료되었습니다.`,
          relatedId: orderId,
        });
        
        // WebSocket 알림
        notificationWS.sendToUser(app.helperId, {
          type: "matching_completed",
          title: "매칭 완료",
        });
        
        // 푸시 알림
        sendPushToUser(app.helperId, {
          title: "매칭 완료",
          body: `${order.companyName} 오더 매칭이 완료되었습니다.`,
          url: "/helper-home",
          tag: `matching-complete-${orderId}`,
        });
      }
      
      // 나머지 applied 상태 신청은 rejected로 변경
      const appliedApplications = applications.filter(a => a.status === "applied");
      for (const app of appliedApplications) {
        await storage.updateOrderApplication(app.id, {
          status: "rejected",
          processedAt: new Date(),
        });
        
        // 거절 알림
        await storage.createNotification({
          type: "application_rejected",
          title: "오더 신청 결과",
          message: `${order.companyName} 오더에 다른 헬퍼가 선택되었습니다.`,
          relatedId: orderId,
        });
      }
      
      // 오더 상태를 scheduled로 변경
      await storage.updateOrder(orderId, {
        status: "scheduled",
        matchedAt: new Date(),
        helperPhoneShared: true,
        requesterPhone: requester?.phoneNumber || null,
      });
      
      // 선택된 헬퍼 정보 가져오기
      const matchedHelper = selectedApplications.length > 0 ? await storage.getUser(selectedApplications[0].helperId) : null;
      
      // 의뢰인에게 알림
      await storage.createNotification({
        userId: userId,
        type: "matching_completed",
        title: "매칭 완료",
        message: `${order.companyName} 오더 매칭이 완료되었습니다.`,
        relatedId: orderId,
      });

      
      // 관리자에게 브로드캐스트
      broadcastToAllAdmins("order_status", "matching_completed", orderId, {
        orderId,
        companyName: order.companyName,
        selectedHelpers: selectedApplications.length,
      });
      
      // 멱등성 응답 저장
      const responseBody = { success: true, message: "매칭이 완료되었습니다" };
      if (idempotencyKey) {
        await storeIdempotencyResponse(userId, `POST:/api/orders/${orderId}/confirm-matching`, idempotencyKey, 200, responseBody);
      }
      
      res.json(responseBody);
    } catch (err) {
      console.error("Confirm matching error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 계약 확정 (의뢰인이 오더 생성 후 계약 동의)
  app.post("/api/orders/:id/confirm-contract", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const orderId = Number(req.params.id);
      const order = await storage.getOrder(orderId);
      
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      const { balancePaymentDate } = req.body;
      
      if (!balancePaymentDate) {
        return res.status(400).json({ message: "잔금 결제 예정일을 선택해주세요" });
      }
      
      if (order.requesterId !== userId) {
        return res.status(403).json({ message: "권한이 없습니다" });
      }
      
      // 계약 확정: awaiting_deposit 상태 유지 (입금 대기)
      await storage.updateOrder(orderId, {
        contractConfirmed: true,
        balancePaymentDueDate: balancePaymentDate,
        contractConfirmedAt: new Date(),
      });
      
      // 의뢰인에게 입금 안내 알림 (부가세 포함 기준)
      const pricePerUnit = order.pricePerUnit || 0;
      const avgQty = parseInt(order.averageQuantity || "1") || 1;
      const supplyAmount = pricePerUnit * avgQty;
      const totalWithVat = Math.round(supplyAmount * 1.1);
      const depositAmount = Math.floor(totalWithVat * 0.2);
      
      await storage.createNotification({
        userId: userId,
        type: "contract_confirmed",
        title: "계약 확정 완료",
        message: `${order.companyName} 오더 계약이 확정되었습니다. 예약금 ${depositAmount.toLocaleString()}원 입금 후 헬퍼 매칭이 진행됩니다.`,
        relatedId: orderId,
      });
      
      // 관리자에게 알림
      broadcastToAllAdmins("order", "contract_confirmed", orderId, {
        orderId,
        companyName: order.companyName,
        requesterId: userId,
        helperId: null,
        trackingNumber: null,
        depositAmount,
      });
      
      res.json({ 
        success: true, 
        message: "계약이 확정되었습니다. 예약금 입금 안내를 확인해주세요.",
        depositAmount,
      });
    } catch (err) {
      console.error("Confirm contract error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 업무 마감 (in_progress → closing_submitted 상태 변경) - 헬퍼가 업무마감 전송
  // 참고: 이 API는 레거시 호환성을 위해 유지됨. 신규 클라이언트는 /api/orders/:id/closing/submit 사용 권장
  app.post("/api/orders/complete", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const { orderId, deliveryCount, returnCount, pickupCount, otherCount, proofImageUrl } = req.body;
      
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      // Get the contract for this order and helper
      const contracts = await storage.getAllContracts();
      const contract = contracts.find(c => c.orderId === orderId && c.helperId === userId);
      
      if (!contract) {
        return res.status(404).json({ message: "계약을 찾을 수 없습니다" });
      }
      
      // 헬퍼 신청 상태 업데이트 (in_progress → closing_submitted)
      const application = await storage.getOrderApplication(orderId, userId);
      if (application) {
        await storage.updateOrderApplication(application.id, {
          status: "closing_submitted",
        });
      }
      
      // 정산 = {(배송수량+반품수량)*단가+(기타*200)}*1.1
      const pricePerUnit = order.pricePerUnit || 0;
      const billableCount = deliveryCount + (returnCount || 0);
      const otherAmount = (otherCount || 0) * 200;
      const baseAmount = (billableCount * pricePerUnit) + otherAmount;
      const settlementAmount = Math.floor(baseAmount * 1.1);
      
      // Update contract with closing_submitted data (do NOT auto-mark complete - handled by admin approval)
      await storage.updateContract(contract.id, {
        status: "closing_submitted",
      });
      
      // Update order status to closing_submitted (마감제출 - 관리자 승인 대기)
      await storage.updateOrder(orderId, {
        status: "closing_submitted",
      });
      
      // Check if work confirmation exists, update or create
      const existingConfirmation = await storage.getWorkConfirmationByContract(contract.id);
      const confirmationNotes = `배송: ${deliveryCount}건, 반품: ${returnCount || 0}건, 수거: ${pickupCount || 0}건, 기타: ${otherCount || 0}건`;
      const completedAt = new Date();
      
      if (existingConfirmation) {
        await storage.updateWorkConfirmation(existingConfirmation.id, {
          notes: confirmationNotes,
          proofImageUrl: proofImageUrl || existingConfirmation.proofImageUrl,
          status: "submitted",
          deliveryCount: deliveryCount || 0,
          returnCount: returnCount || 0,
          pickupCount: pickupCount || 0,
          otherCount: otherCount || 0,
        });
      } else {
        await storage.createWorkConfirmation({
          contractId: contract.id,
          orderId,
          helperId: userId,
          proofImageUrl: proofImageUrl || null,
          notes: confirmationNotes,
          status: "submitted",
          deliveryCount: deliveryCount || 0,
          returnCount: returnCount || 0,
          pickupCount: pickupCount || 0,
          otherCount: otherCount || 0,
        });
      }
      
      // Create work proof event for completion (immutable log)
      const workSession = await storage.getWorkSessionByOrderAndHelper(orderId, userId);
      await storage.createWorkProofEvent({
        workSessionId: workSession?.id || null,
        helperId: userId,
        eventType: "complete",
        photoUrl: proofImageUrl || null,
        notes: JSON.stringify({
          deliveryCount,
          returnCount: returnCount || 0,
          pickupCount: pickupCount || 0,
          otherCount: otherCount || 0,
          settlementAmount,
          completedAt: completedAt.toISOString(),
        }),
      });
      
      // Auto checkout: Update work session with checkOutTime (업무마감 = 퇴근)
      if (workSession && !workSession.checkOutTime) {
        await storage.updateWorkSession(workSession.id, {
          checkOutTime: completedAt,
          status: "completed",
          workConfirmed: true,
          workConfirmedAt: completedAt,
        });
        console.log(`[Auto Checkout] Helper ${userId} checked out via order completion. Order: ${orderId}`);
      } else if (!workSession) {
        // No check-in record - log warning but allow completion (B안: 운영 현실적)
        console.warn(`[Order Complete] No work session found for helper ${userId} on order ${orderId}. Completion allowed without check-in.`);
      }
      
      // Also update check_in_records with checkOutTime if exists
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const checkInRecords = await storage.getCheckInRecordsByHelper(userId, today);
      const orderCheckIn = checkInRecords.find(r => r.orderId === orderId);
      if (orderCheckIn && !orderCheckIn.checkOutTime) {
        await storage.updateCheckInRecord(orderCheckIn.id, {
          checkOutTime: completedAt,
          status: "checked_out",
        });
        console.log(`[Auto Checkout] Updated check_in_records for helper ${userId}. Order: ${orderId}`);
      }
      
      // Get helper and requester info
      const helper = await storage.getUser(userId);
      const requester = contract.requesterId ? await storage.getUser(contract.requesterId) : null;
      
      // Prepare completion message
      const completionMessage = `${order.companyName} 마감 완료\n배송: ${deliveryCount}건, 반품: ${returnCount || 0}건${pickupCount ? `, 수거: ${pickupCount}건` : ""}${otherCount ? `, 기타: ${otherCount}건` : ""}\n정산금액: ${settlementAmount.toLocaleString()}원 (VAT포함)`;
      
      // Send push notification to Helper
      await storage.createNotification({
        userId: userId,
        type: "order_completed",
        title: "업무 마감 완료",
        message: completionMessage,
        relatedId: orderId,
      });
      
      const helperWsDelivered = notificationWS.sendToUser(userId, {
        type: "order_completed",
        title: "업무 마감 완료",
        message: completionMessage,
        relatedId: orderId,
        payload: { deliveryCount, returnCount, pickupCount, otherCount, settlementAmount },
      });
      
      // Log for admin (helper)
      await storage.createNotificationLog({
        userId: userId,
        type: "order_completed",
        title: "업무 마감 완료",
        message: completionMessage,
        relatedId: orderId,
        deliveryChannel: helperWsDelivered ? "websocket" : "polling",
      });
      
      // Send push notification to Requester
      if (requester) {
        const requesterMessage = `${helper?.name || "헬퍼"}님이 ${order.companyName} 업무를 마감했습니다.\n배송: ${deliveryCount}건, 반품: ${returnCount || 0}건${pickupCount ? `, 수거: ${pickupCount}건` : ""}${otherCount ? `, 기타: ${otherCount}건` : ""}\n정산금액: ${settlementAmount.toLocaleString()}원 (VAT포함)`;
        
        await storage.createNotification({
          userId: requester.id,
          type: "order_completed",
          title: "업무 마감 알림",
          message: requesterMessage,
          relatedId: orderId,
        });
        
        const requesterWsDelivered = notificationWS.sendToUser(requester.id, {
          type: "order_completed",
          title: "업무 마감 알림",
          message: requesterMessage,
          relatedId: orderId,
          payload: { deliveryCount, returnCount, pickupCount, otherCount, settlementAmount, helperName: helper?.name },
        });
        
        // Log for admin (requester)
        await storage.createNotificationLog({
          userId: requester.id,
          type: "order_completed",
          title: "업무 마감 알림",
          message: requesterMessage,
          relatedId: orderId,
          deliveryChannel: requesterWsDelivered ? "websocket" : "polling",
        });
        
        // Send web push to requester (async, non-blocking)
        sendPushToUser(requester.id, {
          title: "업무 마감 알림",
          body: `${helper?.name || "헬퍼"}님이 ${order.companyName} 업무를 마감했습니다. 정산금액: ${settlementAmount.toLocaleString()}원`,
          url: "/requester-dashboard",
          tag: `complete-${orderId}`,
        });
      }
      
      // Send web push to helper (async, non-blocking)
      sendPushToUser(userId, {
        title: "업무 마감 완료",
        body: `${order.companyName} 마감 완료. 정산금액: ${settlementAmount.toLocaleString()}원 (VAT포함)`,
        url: "/helper-dashboard",
        tag: `complete-${orderId}`,
      });
      
      console.log(`[Order Complete] Order ${orderId} completed by Helper ${userId}. Settlement: ${settlementAmount}원`);
      
      // Send order status update for real-time UI refresh
      notificationWS.sendOrderStatusUpdate(userId, {
        orderId,
        status: "completed",
        currentHelpers: order.currentHelpers || 1,
      });
      
      if (requester) {
        notificationWS.sendOrderStatusUpdate(requester.id, {
          orderId,
          status: "completed",
          currentHelpers: order.currentHelpers || 1,
        });
      }
      
      // Notify all other helpers on this order
      notifyOrderHelpers(orderId, "order_completed", "completed");
      
      // Broadcast to all admins for real-time admin console updates
      broadcastToAllAdmins("order", "completed", orderId, { 
        orderId, 
        helperId: userId, 
        status: "completed",
        settlementAmount 
      });
      
      // Create settlement statement (기사정산) automatically with transaction
      // 새로운 계산 방식:
      // 총합계금 = 단가 × 박스수 × 1.1 (부가세 포함)
      // 본사 수수료 = 총합계금 × 수수료율% (본사 + 팀장)
      // 기사 수령액 = 총합계금 - 본사 수수료 (부가세 포함)
      
      try {
        // 멱등성 체크: 이미 정산이 생성되어 있으면 스킵
        const existingSettlement = await storage.getSettlementStatementByOrder(orderId);
        if (existingSettlement) {
          console.log(`[Settlement] Already exists for order ${orderId}, skipping creation`);
        } else {
        // 수수료율 조회 (우선순위: 신청 스냅샷 > 오더 스냅샷 > 현재 정책)
        // 매칭 시점의 헬퍼별 실효 수수료율을 보존하여 정책 변경 후에도 기존 정산에 영향 없음
        let totalCommissionRate: number;
        let platformRate: number;
        let teamLeaderRate: number;
        let rateSource: string;
        let teamLeaderId: string | null = null;
        
        // 1. 헬퍼 신청(application) 스냅샷이 있으면 우선 사용 (매칭 시점 헬퍼별 수수료율)
        const application = await storage.getOrderApplication(orderId, userId);
        if (application?.snapshotCommissionRate != null && 
            application?.snapshotPlatformRate != null && 
            application?.snapshotTeamLeaderRate != null) {
          totalCommissionRate = application.snapshotCommissionRate;
          platformRate = application.snapshotPlatformRate;
          teamLeaderRate = application.snapshotTeamLeaderRate;
          teamLeaderId = application.snapshotTeamLeaderId;
          rateSource = application.snapshotSource || "application_snapshot";
        // 2. 오더 스냅샷이 있으면 사용 (오더 생성 시점 글로벌 정책)
        } else if (order.snapshotCommissionRate != null && 
                   order.snapshotPlatformRate != null && 
                   order.snapshotTeamLeaderRate != null) {
          totalCommissionRate = order.snapshotCommissionRate;
          platformRate = order.snapshotPlatformRate;
          teamLeaderRate = order.snapshotTeamLeaderRate;
          rateSource = "order_snapshot";
          const teamMember = await storage.getTeamMemberByUserId(userId);
          if (teamMember) {
            const team = await storage.getTeamById(teamMember.teamId);
            teamLeaderId = team?.leaderId || null;
          }
        // 3. 스냅샷이 없으면 (레거시) 현재 정책으로 폴백
        } else {
          const effectiveRate = await storage.getEffectiveCommissionRate(userId);
          totalCommissionRate = effectiveRate.rate;
          platformRate = effectiveRate.platformRate;
          teamLeaderRate = effectiveRate.teamLeaderRate;
          rateSource = effectiveRate.source;
          teamLeaderId = effectiveRate.teamLeaderId;
        }
        
        console.log(`[Settlement] Total: ${totalCommissionRate}% (Platform: ${platformRate}%, TeamLeader: ${teamLeaderRate}%), Source: ${rateSource}`);
        
        // 박스수 = 배송 + 반품 + 기타
        const totalBoxCount = (deliveryCount || 0) + (returnCount || 0) + (otherCount || 0);
        
        // 공급가액 = 단가 × 박스수
        const supplyAmount = totalBoxCount * pricePerUnit;
        
        // 부가세 = 공급가액 × 10%
        const vatAmount = Math.round(supplyAmount * 0.1);
        
        // 총합계금 = 공급가액 + 부가세 (= 단가 × 박스수 × 1.1)
        const totalAmountWithVat = supplyAmount + vatAmount;
        
        // 총 수수료 = 총합계금 × 수수료율%
        const totalCommissionAmount = Math.round(totalAmountWithVat * totalCommissionRate / 100);
        
        // 본사 수수료 = 총합계금 × 본사수수료율%
        const platformCommission = Math.round(totalAmountWithVat * platformRate / 100);
        
        // 팀장 인센티브 = 총합계금 × 팀장수수료율%
        const teamLeaderIncentive = Math.round(totalAmountWithVat * teamLeaderRate / 100);
        
        // 기사 수령액 = 총합계금 - 총 수수료 (부가세 포함)
        const netPayout = totalAmountWithVat - totalCommissionAmount;
        
        const workDateStr = new Date().toISOString().split('T')[0];
        
        await storage.createSettlementStatement({
          orderId: orderId,
          helperId: userId,
          requesterId: contract.requesterId || null,
          workDate: workDateStr,
          deliveryCount: deliveryCount || 0,
          returnCount: returnCount || 0,
          pickupCount: pickupCount || 0,
          otherCount: otherCount || 0,
          basePay: supplyAmount, // 공급가액 (부가세 제외)
          additionalPay: 0,
          penalty: 0,
          deduction: 0,
          commissionRate: totalCommissionRate,
          commissionAmount: totalCommissionAmount,
          platformCommission: platformCommission,
          teamLeaderIncentive: teamLeaderIncentive,
          teamLeaderId: teamLeaderId,
          supplyAmount: supplyAmount, // 공급가액
          vatAmount: vatAmount, // 부가세
          totalAmount: totalAmountWithVat, // 총합계금 (부가세 포함)
          netAmount: netPayout, // 기사 수령액 (부가세 포함)
          status: "pending",
        });
        console.log(`[Settlement Created] Order ${orderId}, Helper ${userId}, Source: ${rateSource}, Rate: ${totalCommissionRate}%, Total: ${totalAmountWithVat}원, Commission: ${totalCommissionAmount}원 (Platform: ${platformCommission}원, TeamLeader: ${teamLeaderIncentive}원), Net: ${netPayout}원`);
        }
      } catch (settlementErr) {
        console.error(`[Settlement Error] Failed to create settlement for order ${orderId}:`, settlementErr);
      }
      
      res.json({ 
        message: "마감 등록 완료", 
        settlementAmount,
        deliveryCount,
        returnCount,
        pickupCount,
      });
    } catch (err) {
      console.error("Order completion error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get order applications with helper info
  app.get("/api/orders/:id/applications", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = Number(req.params.id);
      const applications = await storage.getOrderApplications(orderId);
      
      const applicationsWithHelperInfo = await Promise.all(
        applications.map(async (app) => {
          const helper = await storage.getUser(app.helperId);
          const credential = await storage.getHelperCredential(app.helperId);
          const reviews = await storage.getHelperReviews(app.helperId);
          const avgRating = await storage.getHelperAverageRating(app.helperId);
          
          return {
            ...app,
            helperName: helper?.name || "Unknown",
            helperNickname: (helper as any)?.nickname || null,
            helperPhone: helper?.phoneNumber,
            reviewCount: reviews.length,
            recentReviews: reviews.slice(0, 4).map(r => ({
              id: r.id,
              rating: r.rating,
              comment: r.comment,
              createdAt: r.createdAt,
              requesterName: null,
            })),
            averageRating: avgRating,
            profileImage: (helper as any)?.profileImageUrl || null,
          };
        })
      );
      
      res.json(applicationsWithHelperInfo);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== ADMIN ROUTES ====================

  // Admin SMS verification temporary storage
  const adminSmsVerifications = new Map<string, { userId: string; code: string; expiresAt: Date; phoneNumber: string }>();
  const adminPasswordResetTokens = new Map<string, { userId: string; expiresAt: Date }>();

  // Admin-specific login (separate from app login)
  app.post("/api/admin/auth/login", async (req, res) => {
    try {
      const { email, password } = req.body;
      if (!email || !password) {
        return res.status(400).json({ message: "이메일과 비밀번호를 입력해주세요" });
      }

      const user = await storage.getUserByEmail(email);
      if (!user) {
        return res.status(401).json({ message: "이메일 또는 비밀번호가 올바르지 않습니다" });
      }

      // Only allow HQ staff or admin role
      if (!user.isHqStaff && user.role !== "admin") {
        return res.status(403).json({ message: "관리자 권한이 없습니다" });
      }

      // Check adminStatus - only "active" can login
      if (user.adminStatus === "pending") {
        return res.status(403).json({ message: "관리자 승인 대기 중입니다. 승인 후 로그인해 주세요." });
      }
      if (user.adminStatus === "suspended") {
        return res.status(403).json({ message: "계정이 정지되었습니다. 관리자에게 문의해 주세요." });
      }

      const isMatch = await bcrypt.compare(password, user.password);
      if (!isMatch) {
        return res.status(401).json({ message: "이메일 또는 비밀번호가 올바르지 않습니다" });
      }

      // Check if password is expired (90 days)
      let passwordExpired = false;
      let passwordExpiresSoon = false;
      let daysUntilExpiry = 90;
      
      if (user.passwordChangedAt) {
        const daysSinceChange = (Date.now() - new Date(user.passwordChangedAt).getTime()) / (1000 * 60 * 60 * 24);
        daysUntilExpiry = Math.max(0, Math.floor(90 - daysSinceChange));
        
        if (daysSinceChange > 90) {
          passwordExpired = true;
        } else if (daysSinceChange > 80) {
          passwordExpiresSoon = true;
        }
      }

      // If password is expired, return tempToken for password change
      if (passwordExpired) {
        const tempToken = randomBytes(32).toString("hex");
        adminPasswordResetTokens.set(tempToken, {
          userId: user.id,
          expiresAt: new Date(Date.now() + 10 * 60 * 1000),
        });
        
        return res.json({
          passwordExpired: true,
          tempToken,
          message: "비밀번호가 만료되었습니다. 새 비밀번호를 설정해주세요.",
        });
      }

      // SMS 2-Factor Authentication (if user has phone number)
      if (user.phoneNumber) {
        const tempToken = randomBytes(32).toString("hex");
        const smsCode = String(Math.floor(100000 + Math.random() * 900000));
        
        adminSmsVerifications.set(tempToken, {
          userId: user.id,
          code: smsCode,
          expiresAt: new Date(Date.now() + 5 * 60 * 1000),
          phoneNumber: user.phoneNumber,
        });

        // Mask phone number for display
        const maskedPhone = user.phoneNumber.replace(/(\d{3})\d{4}(\d{4})/, "$1****$2");

        // Send SMS
        try {
          await sendSMS(user.phoneNumber, `[Hellp Me] 관리자 로그인 인증번호: ${smsCode}`);
        } catch (smsErr) {
          console.error("SMS send error:", smsErr);
        }

        return res.json({
          requireSmsVerification: true,
          tempToken,
          phoneNumber: maskedPhone,
          passwordExpiresSoon,
          daysUntilExpiry,
        });
      }

      // Direct login if no phone number
      const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: "1h" });
      
      const refreshTokenValue = randomBytes(32).toString("hex");
      const refreshExpiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
      const deviceInfo = req.headers["user-agent"] || undefined;
      await storage.createRefreshToken(user.id, refreshTokenValue, refreshExpiresAt, deviceInfo);

      // Get user permissions
      const userRoles = await storage.getStaffRoleAssignments(user.id);
      const permissions: string[] = [];
      for (const role of userRoles) {
        const rolePerms = await storage.getRolePermissions(role.roleId);
        permissions.push(...rolePerms.map(p => p.permissionKey));
      }

      res.json({
        token,
        refreshToken: refreshTokenValue,
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
          isHqStaff: user.isHqStaff,
          permissions: [...new Set(permissions)],
        },
        passwordExpiresSoon,
        daysUntilExpiry,
      });
    } catch (err) {
      console.error("Admin login error:", err);
      res.status(500).json({ message: "서버 오류가 발생했습니다" });
    }
  });

  // Verify SMS code for admin login
  app.post("/api/admin/auth/verify-sms", async (req, res) => {
    try {
      const { tempToken, code } = req.body;
      
      const verification = adminSmsVerifications.get(tempToken);
      if (!verification) {
        return res.status(400).json({ message: "인증 세션이 만료되었습니다. 다시 로그인해주세요." });
      }

      if (new Date() > verification.expiresAt) {
        adminSmsVerifications.delete(tempToken);
        return res.status(400).json({ message: "인증번호가 만료되었습니다. 다시 로그인해주세요." });
      }

      if (verification.code !== code) {
        return res.status(400).json({ message: "인증번호가 올바르지 않습니다." });
      }

      adminSmsVerifications.delete(tempToken);

      const user = await storage.getUser(verification.userId);
      if (!user) {
        return res.status(400).json({ message: "사용자를 찾을 수 없습니다." });
      }

      const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: "1h" });
      
      const refreshTokenValue = randomBytes(32).toString("hex");
      const refreshExpiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
      const deviceInfo = req.headers["user-agent"] || undefined;
      await storage.createRefreshToken(user.id, refreshTokenValue, refreshExpiresAt, deviceInfo);

      // Get user permissions
      const userRoles = await storage.getStaffRoleAssignments(user.id);
      const permissions: string[] = [];
      for (const role of userRoles) {
        const rolePerms = await storage.getRolePermissions(role.roleId);
        permissions.push(...rolePerms.map(p => p.permissionKey));
      }

      res.json({
        token,
        refreshToken: refreshTokenValue,
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
          isHqStaff: user.isHqStaff,
          permissions: [...new Set(permissions)],
        },
      });
    } catch (err) {
      console.error("SMS verification error:", err);
      res.status(500).json({ message: "서버 오류가 발생했습니다" });
    }
  });

  // Resend SMS code
  app.post("/api/admin/auth/resend-sms", async (req, res) => {
    try {
      const { tempToken } = req.body;
      
      const verification = adminSmsVerifications.get(tempToken);
      if (!verification) {
        return res.status(400).json({ message: "인증 세션이 만료되었습니다. 다시 로그인해주세요." });
      }

      const newCode = String(Math.floor(100000 + Math.random() * 900000));
      verification.code = newCode;
      verification.expiresAt = new Date(Date.now() + 5 * 60 * 1000);

      try {
        await sendSMS(verification.phoneNumber, `[Hellp Me] 관리자 로그인 인증번호: ${newCode}`);
      } catch (smsErr) {
        console.error("SMS resend error:", smsErr);
      }

      res.json({ success: true });
    } catch (err) {
      console.error("SMS resend error:", err);
      res.status(500).json({ message: "서버 오류가 발생했습니다" });
    }
  });

  // Request password reset
  app.post("/api/admin/auth/request-password-reset", async (req, res) => {
    try {
      const { email } = req.body;
      
      const user = await storage.getUserByEmail(email);
      if (!user || (!user.isHqStaff && user.role !== "admin")) {
        return res.json({ success: true });
      }

      const resetToken = randomBytes(32).toString("hex");
      adminPasswordResetTokens.set(resetToken, {
        userId: user.id,
        expiresAt: new Date(Date.now() + 30 * 60 * 1000),
      });

      const tempPassword = randomBytes(4).toString("hex");
      const hashedPassword = await bcrypt.hash(tempPassword, 10);
      await storage.updateUser(user.id, { 
        password: hashedPassword,
        mustChangePassword: true,
        passwordChangedAt: new Date(),
      });

      console.log(`[Admin Password Reset] User: ${email}, Temp Password: ${tempPassword}`);

      res.json({ success: true });
    } catch (err) {
      console.error("Password reset error:", err);
      res.status(500).json({ message: "서버 오류가 발생했습니다" });
    }
  });

  // Change password (for expired password)
  app.post("/api/admin/auth/change-password", async (req, res) => {
    try {
      const { tempToken, newPassword } = req.body;
      
      const resetData = adminPasswordResetTokens.get(tempToken);
      if (!resetData) {
        return res.status(400).json({ message: "세션이 만료되었습니다. 다시 로그인해주세요." });
      }

      if (new Date() > resetData.expiresAt) {
        adminPasswordResetTokens.delete(tempToken);
        return res.status(400).json({ message: "세션이 만료되었습니다. 다시 로그인해주세요." });
      }

      if (!newPassword || newPassword.length < 8) {
        return res.status(400).json({ message: "비밀번호는 8자 이상이어야 합니다." });
      }

      const hasUpperCase = /[A-Z]/.test(newPassword);
      const hasLowerCase = /[a-z]/.test(newPassword);
      const hasNumber = /[0-9]/.test(newPassword);
      const hasSpecial = /[!@#$%^&*(),.?":{}|<>]/.test(newPassword);

      if (!(hasUpperCase && hasLowerCase && hasNumber && hasSpecial)) {
        return res.status(400).json({ message: "대문자, 소문자, 숫자, 특수문자를 모두 포함해야 합니다." });
      }

      adminPasswordResetTokens.delete(tempToken);

      const user = await storage.getUser(resetData.userId);
      if (!user) {
        return res.status(400).json({ message: "사용자를 찾을 수 없습니다." });
      }

      const hashedPassword = await bcrypt.hash(newPassword, 10);
      await storage.updateUser(user.id, {
        password: hashedPassword,
        passwordChangedAt: new Date(),
        mustChangePassword: false,
      });

      const token = jwt.sign({ userId: user.id }, JWT_SECRET, { expiresIn: "1h" });
      
      const refreshTokenValue = randomBytes(32).toString("hex");
      const refreshExpiresAt = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000);
      const deviceInfo = req.headers["user-agent"] || undefined;
      await storage.createRefreshToken(user.id, refreshTokenValue, refreshExpiresAt, deviceInfo);

      const userRoles = await storage.getStaffRoleAssignments(user.id);
      const permissions: string[] = [];
      for (const role of userRoles) {
        const rolePerms = await storage.getRolePermissions(role.roleId);
        permissions.push(...rolePerms.map(p => p.permissionKey));
      }

      res.json({
        token,
        refreshToken: refreshTokenValue,
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          role: user.role,
          isHqStaff: user.isHqStaff,
          permissions: [...new Set(permissions)],
        },
      });
    } catch (err) {
      console.error("Password change error:", err);
      res.status(500).json({ message: "서버 오류가 발생했습니다" });
    }
  });
  // Admin password change
  app.post("/api/admin/auth/change-password", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;

      if (!user.isHqStaff && user.role !== "admin") {
        return res.status(403).json({ message: "관리자 권한이 없습니다" });
      }

      const { currentPassword, newPassword } = req.body;

      // If mustChangePassword is true, currentPassword is not required
      if (!user.mustChangePassword) {
        if (!currentPassword) {
          return res.status(400).json({ message: "현재 비밀번호를 입력해주세요" });
        }
        const isMatch = await bcrypt.compare(currentPassword, user.password);
        if (!isMatch) {
          return res.status(401).json({ message: "현재 비밀번호가 올바르지 않습니다" });
        }
      }

      if (!newPassword || newPassword.length < 8) {
        return res.status(400).json({ message: "새 비밀번호는 8자 이상이어야 합니다" });
      }

      const hashedPassword = await bcrypt.hash(newPassword, 10);
      await storage.updateUser(user.id, {
        password: hashedPassword,
        mustChangePassword: false,
        passwordChangedAt: new Date(),
      });

      res.json({ success: true, message: "비밀번호가 변경되었습니다" });
    } catch (err) {
      // 운영 로그: 민감정보 제외, 에러 타입만 기록
      console.error("[Auth] Password change failed:", (err as Error).message?.substring(0, 50));
      res.status(500).json({ message: "서버 오류가 발생했습니다" });
    }
  });

  // Create admin staff (requires existing admin)
  app.post("/api/admin/staff", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const currentUser = req.user!;

      if (!currentUser.isHqStaff && currentUser.role !== "admin") {
        return res.status(403).json({ message: "관리자 권한이 없습니다" });
      }

      const { email, name, phoneNumber, address, birthDate } = req.body;

      if (!email || !name) {
        return res.status(400).json({ message: "이메일과 이름은 필수입니다" });
      }

      // Check if email already exists
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(409).json({ message: "이미 존재하는 이메일입니다" });
      }

      // Generate random initial password (8 chars)
      const initialPassword = Math.random().toString(36).slice(-8) + Math.random().toString(36).slice(-4).toUpperCase();
      const hashedPassword = await bcrypt.hash(initialPassword, 10);

      const newUser = await storage.createUser({
        username: email,
        email,
        password: hashedPassword,
        name,
        phoneNumber: phoneNumber || null,
        address: address || null,
        birthDate: birthDate || null,
        role: "helper", // Base role, but isHqStaff=true makes them admin
        isHqStaff: true,
        mustChangePassword: true,
        adminStatus: "pending", // Requires approval before login
      });

      res.status(201).json({
        success: true,
        message: "관리자 계정이 생성되었습니다. 승인 후 로그인이 가능합니다.",
        user: {
          id: newUser.id,
          email: newUser.email,
          name: newUser.name,
          adminStatus: "pending",
        },
      });
    } catch (err) {
      console.error("Create admin staff error:", err);
      res.status(500).json({ message: "서버 오류가 발생했습니다" });
    }
  });

  // Approve admin staff (generate new temp password and send SMS)
  app.patch("/api/admin/staff/:id/approve", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const currentUser = req.user!;

      if (!currentUser.isHqStaff && currentUser.role !== "admin") {
        return res.status(403).json({ message: "관리자 권한이 없습니다" });
      }

      const targetUser = await storage.getUser(req.params.id);
      if (!targetUser) {
        return res.status(404).json({ message: "사용자를 찾을 수 없습니다" });
      }

      if (!targetUser.isHqStaff && targetUser.role !== "admin") {
        return res.status(400).json({ message: "관리자 계정이 아닙니다" });
      }

      if (targetUser.adminStatus === "active") {
        return res.status(400).json({ message: "이미 승인된 계정입니다" });
      }

      // Generate new temporary password
      const tempPassword = Math.random().toString(36).slice(-8) + Math.random().toString(36).slice(-4).toUpperCase();
      const hashedPassword = await bcrypt.hash(tempPassword, 10);

      await storage.updateUser(targetUser.id, {
        adminStatus: "active",
        approvedAt: new Date(),
        approvedBy: currentUser.id,
        password: hashedPassword,
        mustChangePassword: true,
      });

      // TODO: Integrate SMS module (Aligo/Solapi/Naver SENS) to send tempPassword
      // SMS should be sent to targetUser.phoneNumber
      // Never return the password in API response for security
      
      res.json({
        success: true,
        message: "관리자 계정이 승인되었습니다. 임시 비밀번호가 등록된 휴대폰으로 SMS 발송됩니다.",
        smsSent: !!targetUser.phoneNumber, // Indicates if SMS could be sent
      });
    } catch (err) {
      console.error("Approve admin staff error:", err);
      res.status(500).json({ message: "서버 오류가 발생했습니다" });
    }
  });

  // Suspend admin staff
  app.patch("/api/admin/staff/:id/suspend", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const currentUser = req.user!;

      if (!currentUser.isHqStaff && currentUser.role !== "admin") {
        return res.status(403).json({ message: "관리자 권한이 없습니다" });
      }

      const targetUser = await storage.getUser(req.params.id);
      if (!targetUser) {
        return res.status(404).json({ message: "사용자를 찾을 수 없습니다" });
      }

      if (!targetUser.isHqStaff && targetUser.role !== "admin") {
        return res.status(400).json({ message: "관리자 계정이 아닙니다" });
      }

      // Prevent self-suspension
      if (targetUser.id === currentUser.id) {
        return res.status(400).json({ message: "자신의 계정을 정지할 수 없습니다" });
      }

      await storage.updateUser(targetUser.id, {
        adminStatus: "suspended",
      });

      res.json({
        success: true,
        message: "관리자 계정이 정지되었습니다.",
      });
    } catch (err) {
      console.error("Suspend admin staff error:", err);
      res.status(500).json({ message: "서버 오류가 발생했습니다" });
    }
  });

  // Reactivate suspended admin staff
  app.patch("/api/admin/staff/:id/reactivate", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const currentUser = req.user!;

      if (!currentUser.isHqStaff && currentUser.role !== "admin") {
        return res.status(403).json({ message: "관리자 권한이 없습니다" });
      }

      const targetUser = await storage.getUser(req.params.id);
      if (!targetUser) {
        return res.status(404).json({ message: "사용자를 찾을 수 없습니다" });
      }

      if (targetUser.adminStatus !== "suspended") {
        return res.status(400).json({ message: "정지된 계정이 아닙니다" });
      }

      await storage.updateUser(targetUser.id, {
        adminStatus: "active",
      });

      res.json({
        success: true,
        message: "관리자 계정이 재활성화되었습니다.",
      });
    } catch (err) {
      console.error("Reactivate admin staff error:", err);
      res.status(500).json({ message: "서버 오류가 발생했습니다" });
    }
  });
  
  // Auth middlewares imported from ./utils/auth-middleware

  // Get all users (admin) with role filtering
  app.get("/api/admin/users", adminAuth, requirePermission("staff.view"), async (req, res) => {
    try {
      const roleFilter = req.query.role as string | undefined;
      let users = await storage.getAllUsers();
      
      // Filter by role if specified
      if (roleFilter) {
        const roles = roleFilter.split(',').map(r => r.trim());
        users = users.filter(u => {
          // For helper/requester queries, exclude admin roles
          if (roles.includes('helper') || roles.includes('requester')) {
            if (u.role === 'superadmin' || u.role === 'admin' || u.isHqStaff) {
              return false;
            }
          }
          return roles.includes(u.role);
        });
      }
      
      const usersWithParsedPerms = users.map(u => ({ ...u, menuPermissions: u.menuPermissions ? JSON.parse(u.menuPermissions) : [] })); res.json(usersWithParsedPerms);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update user (admin)
  app.patch("/api/admin/users/:userId", adminAuth, requirePermission("staff.edit"), async (req, res) => {
    try {
      const updated = await storage.updateUser(req.params.userId, req.body);
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // POST /api/admin/operators - Create new operator (admin user)
  const createOperatorSchema = z.object({
    name: z.string().min(1, "이름을 입력해주세요"),
    email: z.string().email("유효한 이메일을 입력해주세요"),
    password: z.string().min(6, "비밀번호는 최소 6자 이상이어야 합니다"),
    phone: z.string().optional(),
    zipCode: z.string().optional(),
    address: z.string().optional(),
    addressDetail: z.string().optional(),
    role: z.enum(["admin", "superadmin"]).default("admin"),
    position: z.string().optional(),
    department: z.string().optional(),
  });

  app.post("/api/admin/operators", adminAuth, requirePermission("staff.create"), async (req, res) => {
    try {
      const parseResult = createOperatorSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({ 
          message: "입력값이 유효하지 않습니다", 
          errors: parseResult.error.errors 
        });
      }

      const { name, email, password, phone, zipCode, address, addressDetail, role, position, department } = parseResult.data;

      // Check if email already exists
      const existingUser = await storage.getUserByEmail(email);
      if (existingUser) {
        return res.status(409).json({ message: "이미 사용 중인 이메일입니다" });
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(password, 10);

      // Generate unique username from email
      const username = email.split("@")[0] + "_" + Date.now().toString(36);

      // Create user with admin role
      const newUser = await storage.createUser({
        username,
        email,
        password: hashedPassword,
        name,
        phoneNumber: phone || null,
        zipCode: zipCode || null,
        address: address || null,
        addressDetail: addressDetail || null,
        role,
        isHqStaff: role === "admin" || role === "superadmin",
        adminStatus: "active",
        onboardingStatus: "approved",
      });

      // Update position and department if provided
      if (position || department) {
        await storage.updateUser(newUser.id, {
          position: position || null,
          department: department || null,
        });
      }

      // Fetch updated user to return
      const createdUser = await storage.getUser(newUser.id);
      if (!createdUser) {
        return res.status(500).json({ message: "사용자 생성 후 조회에 실패했습니다" });
      }

      // Return user without password
      const { password: _, ...userWithoutPassword } = createdUser;
      res.status(201).json(userWithoutPassword);
    } catch (err) {
      console.error("Create operator error:", err);
      res.status(500).json({ message: "운영자 생성에 실패했습니다" });
    }
  });

  // PATCH /api/admin/operators/:id - Update operator info
  const updateOperatorSchema = z.object({
    name: z.string().min(1).optional(),
    phone: z.string().optional(),
    zipCode: z.string().optional(),
    address: z.string().optional(),
    addressDetail: z.string().optional(),
    position: z.string().optional(),
    department: z.string().optional(),
    role: z.enum(["admin", "superadmin"]).optional(),
    menuPermissions: z.array(z.string()).optional(), // 메뉴 접근 권한 배열
  });

  app.patch("/api/admin/operators/:id", adminAuth, requirePermission("staff.edit"), async (req, res) => {
    try {
      const { id } = req.params;

      const user = await storage.getUser(id);
      if (!user) {
        return res.status(404).json({ message: "운영자를 찾을 수 없습니다" });
      }

      // Verify this is an operator (admin/superadmin with isHqStaff)
      if (!user.isHqStaff) {
        return res.status(400).json({ message: "이 사용자는 운영자가 아닙니다" });
      }

      const parseResult = updateOperatorSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({ 
          message: "입력값이 유효하지 않습니다", 
          errors: parseResult.error.errors 
        });
      }

      const { name, phone, zipCode, address, addressDetail, position, department, role, menuPermissions } = parseResult.data;

      // Build update object (excluding email and password)
      const updateData: Record<string, any> = {};
      if (name !== undefined) updateData.name = name;
      if (phone !== undefined) updateData.phoneNumber = phone;
      if (zipCode !== undefined) updateData.zipCode = zipCode;
      if (address !== undefined) updateData.address = address;
      if (addressDetail !== undefined) updateData.addressDetail = addressDetail;
      if (position !== undefined) updateData.position = position;
      if (department !== undefined) updateData.department = department;
      if (menuPermissions !== undefined) updateData.menuPermissions = JSON.stringify(menuPermissions);
      if (role !== undefined) {
        updateData.role = role;
        updateData.isHqStaff = role === "admin" || role === "superadmin";
      }

      if (Object.keys(updateData).length === 0) {
        return res.status(400).json({ message: "수정할 내용이 없습니다" });
      }

      const updatedUser = await storage.updateUser(id, updateData);
      if (!updatedUser) {
        return res.status(500).json({ message: "운영자 수정에 실패했습니다" });
      }

      // Return user without password
      const { password: _, ...userWithoutPassword } = updatedUser;
      res.json(userWithoutPassword);
    } catch (err) {
      console.error("Update operator error:", err);
      res.status(500).json({ message: "운영자 수정에 실패했습니다" });
    }
  });

  // Get all orders (admin) with requester info

  // 관리자용 택배사 목록 조회 API
  app.get("/api/admin/meta/couriers", adminAuth, async (req, res) => {
    try {
      const settings = await storage.getAllCourierSettings();
      const courierList = settings.filter(s => s.isActive);
      
      const couriers = courierList.map(s => ({
        id: s.id,
        code: s.id.toString(),
        name: s.courierName,
        label: s.courierName,
        category: s.category || 'parcel',
        basePricePerBox: s.basePricePerBox || 0,
        etcPricePerBox: s.etcPricePerBox || 0,
        minDeliveryFee: s.minDeliveryFee || 0,
        minTotal: s.minTotal || 0,
        commissionRate: s.commissionRate || 0,
        urgentCommissionRate: s.urgentCommissionRate || 0,
        urgentSurchargeRate: s.urgentSurchargeRate || 0,
        isDefault: s.isDefault || false,
        active: true,
      }));
      
      res.json({ couriers });
    } catch (err) {
      console.error("Admin meta couriers error:", err);
      res.status(500).json({ message: "택배사 목록 조회에 실패했습니다" });
    }
  });

  // Create order (admin) - 본사 계약권으로 계약금 없이 바로 open 상태로 생성
  app.post("/api/admin/orders", adminAuth, requirePermission("orders.create"), async (req, res) => {
    try {
      const adminId = (req as any).adminUser?.id;
      const {
        requesterId,
        companyName,
        carrierCode,
        courierCompany,
        courierCategory,
        deliveryArea,
        campAddress,
        averageQuantity,
        pricePerUnit,
        scheduledDate,
        scheduledDateEnd,
        vehicleType,
        contactPhone,
        requesterPhone,
        deliveryGuide,
        memo,
        isUrgent,
        regionMapUrl,
      } = req.body;

      // 필수 필드 검증
      if (!companyName || !deliveryArea || !scheduledDate || !vehicleType) {
        return res.status(400).json({ 
          message: "필수 필드를 입력해주세요 (회사명, 배송지역, 입차일, 차종)" 
        });
      }

      // 택배사 정책에서 단가 조회
      let basePricePerBox = pricePerUnit || 1200;
      let finalPricePerBox = basePricePerBox;
      let minTotalApplied = false;
      let snapshotCommissionRate = 0;
      let snapshotPlatformRate = 0;
      let snapshotTeamLeaderRate = 0;

      if (carrierCode) {
        const courierSetting = await storage.getCourierSettingByCode(carrierCode);
        if (courierSetting) {
          basePricePerBox = courierSetting.basePricePerBox || 1200;
          finalPricePerBox = basePricePerBox;
          snapshotCommissionRate = courierSetting.commissionRate || 0;
          
          // 최소보장금 적용 여부 계산
          const boxCount = parseInt(String(averageQuantity || "0").replace(/[^0-9]/g, "")) || 0;
          const minTotal = courierSetting.minTotal || 0;
          if (boxCount > 0 && minTotal > 0) {
            const estimatedTotal = boxCount * basePricePerBox;
            if (estimatedTotal < minTotal) {
              finalPricePerBox = Math.ceil(minTotal / boxCount);
              minTotalApplied = true;
            }
          }
        }
      }

      // 본사 계약권 오더 생성 - 계약금 없이 바로 open 상태
      const order = await storage.createOrder({
        requesterId: requesterId || null,
        companyName,
        carrierCode: carrierCode || null,
        courierCompany: courierCompany || null,
        courierCategory: courierCategory || "parcel",
        deliveryArea,
        campAddress: campAddress || null,
        averageQuantity: averageQuantity || "0",
        pricePerUnit: finalPricePerBox,
        scheduledDate,
        scheduledDateEnd: scheduledDateEnd || null,
        vehicleType,
        contactPhone: contactPhone || null,
        requesterPhone: requesterPhone || null,
        deliveryGuide: deliveryGuide || null,
        memo: memo || null,
        isUrgent: isUrgent || false,
        regionMapUrl: regionMapUrl || null,
        status: "open",
        approvalStatus: "approved",
        maxHelpers: 3,
        currentHelpers: 0,
        snapshotCommissionRate,
        snapshotPlatformRate,
        snapshotTeamLeaderRate,
        basePricePerBox,
        finalPricePerBox,
        minTotalApplied,
        isHqOrder: true,
      });

      // 관리자 액션 로깅
      await logAdminAction({
        req,
        action: "order.create_hq",
        targetType: "order",
        targetId: order.id,
        newValue: { 
          companyName, 
          deliveryArea, 
          scheduledDate,
          isHqOrder: true,
          status: "open"
        },
      });

      res.status(201).json({
        success: true,
        order: order ? { ...order, helperName } : null,
        message: "본사 계약권 오더가 등록되었습니다.",
      });
    } catch (err) {
      console.error("Admin create order error:", err);
      res.status(500).json({ message: "오더 생성에 실패했습니다" });
    }
  });

  app.get("/api/admin/orders", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const orders = await storage.getOrders();
      const users = await storage.getAllUsers();
      const requesterBusinesses = await storage.getAllRequesterBusinesses();
      
      // Build lookup maps
      const userMap = new Map(users.map(u => [u.id, u]));
      const businessMap = new Map(requesterBusinesses.map(b => [b.userId, b]));
      
      // Enrich orders with requester info
      const enrichedOrders = orders.map(order => {
        const requester = order.requesterId ? userMap.get(order.requesterId) : null;
        const business = order.requesterId ? businessMap.get(order.requesterId) : null;
        return {
          ...order,
          requesterName: requester?.name || business?.businessName || "-",
          requesterPhone: order.requesterPhone || requester?.phoneNumber || "-",
          requesterEmail: requester?.email || "",
          boxCount: parseInt(String(order.averageQuantity || "0").replace(/[^0-9]/g, "")) || 0,
          unitPrice: order.pricePerUnit || 0,
          regionMapUrl: order.regionMapUrl || "",
        };
      });
      
      res.json(enrichedOrders);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get single order (admin) - E: 가상계좌 정보 포함, 헬퍼/요청자 정보 포함
  app.get("/api/admin/orders/:orderId", adminAuth, requirePermission("orders.view"), async (req, res) => {
    // 캐시 비활성화 (계약금 등 동적 데이터 포함)
    res.set('Cache-Control', 'no-store, no-cache, must-revalidate');
    res.set('Pragma', 'no-cache');
    res.set('Expires', '0');
    
    try {
      const orderId = Number(req.params.orderId);
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      // 헬퍼 정보 조회
      let helperName = null;
      let helperPhone = null;
      let helperTeamName = null;
      let helperProfileImage = null;
      if (order.matchedHelperId) {
        const helper = await storage.getUser(order.matchedHelperId);
        if (helper) {
          helperName = helper.name || helper.username;
          helperPhone = helper.phoneNumber;
          helperTeamName = helper.teamName || null;
          helperProfileImage = helper.profileImageUrl || null;
        }
      }
      
      // 요청자 정보 조회
      let requesterName = null;
      let requesterPhone = null;
      let requesterEmail = null;
      if (order.requesterId) {
        const requester = await storage.getUser(order.requesterId);
        if (requester) {
          requesterName = requester.name || requester.username;
          requesterPhone = requester.phoneNumber;
          requesterEmail = requester.email;
        }
      }
      
      // E: 가상계좌 정보 조회 및 포함
      let virtualAccount = null;
      try {
        virtualAccount = await storage.getVirtualAccountByOrder(orderId);
      } catch (e) {
        console.error("Failed to get virtual account for order:", e);
      }
      
      // 잔금 결제 예정일 (order 테이블에서 직접 가져옴)
      const balancePaymentDueDate = (order as any).balancePaymentDueDate || null;
      
      // 계약금 조회 (공통 함수 사용 - SSOT)
      const depositInfo = await getOrderDepositInfo(orderId);
      const { depositAmount, paymentStatus: depositPaymentStatus } = depositInfo;
      
      res.json({
        ...order,
        helperName,
        helperPhone,
        helperTeamName,
        helperProfileImage,
        requesterName,
        requesterPhone,
        requesterEmail,
        balancePaymentDueDate,
        depositAmount,
        depositPaymentStatus,
        virtualAccount: virtualAccount ? {
          id: virtualAccount.id,
          bankCode: virtualAccount.bankCode,
          bankName: getBankName(virtualAccount.bankCode || ""),
          accountNumber: virtualAccount.accountNumber,
          accountHolder: virtualAccount.accountHolder,
          amount: virtualAccount.amount,
          status: virtualAccount.status,
          paymentId: virtualAccount.paymentId,
          paidAt: virtualAccount.paidAt,
          paidAmount: virtualAccount.paidAmount,
          dueDate: virtualAccount.dueDate,
          createdAt: virtualAccount.createdAt,
          webhookReceivedAt: virtualAccount.webhookReceivedAt,
        } : null,
      });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update order (admin)
  app.patch("/api/admin/orders/:orderId", adminAuth, requirePermission("orders.edit"), async (req, res) => {
    try {
      const updated = await storage.updateOrder(Number(req.params.orderId), req.body);
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get order applications (admin)
  app.get("/api/admin/orders/:orderId/applications", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const orderId = Number(req.params.orderId);
      const applications = await storage.getOrderApplications(orderId);
      
      // 헬퍼 정보 포함
      const applicationsWithHelperInfo = await Promise.all(
        applications.map(async (app) => {
          const helper = await storage.getUser(app.helperId);
          const avgRating = await storage.getHelperAverageRating(app.helperId);
          
          return {
            ...app,
            helperName: helper?.name || "Unknown",
            helperNickname: (helper as any)?.nickname || null,
            helperPhone: helper?.phoneNumber,
            averageRating: avgRating,
            profileImage: (helper as any)?.profileImageUrl || null,
          };
        })
      );
      
      res.json(applicationsWithHelperInfo);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get service agreements for an order's requester (admin)
  app.get("/api/admin/orders/:orderId/agreements", adminAuth, requirePermission("contracts.view"), async (req, res) => {
    try {
      const order = await storage.getOrder(Number(req.params.orderId));
      if (!order || !order.requesterId) {
        return res.status(404).json({ message: "Order not found" });
      }
      const agreements = await storage.getAllRequesterServiceAgreements();
      const requesterAgreements = agreements.filter(a => a.userId === order.requesterId);
      res.json(requesterAgreements);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });
  // Get order contracts (admin) - 오더별 계약 정보 조회
  app.get("/api/admin/orders/:orderId/contracts", adminAuth, requirePermission("contracts.view"), async (req, res) => {
    try {
      const orderId = Number(req.params.orderId);
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      const orderContracts = await storage.getOrderContracts(orderId);
      const users = await storage.getAllUsers();
      const userMap = new Map(users.map(u => [u.id, u]));
      
      const contractsWithDetails = orderContracts.map(c => {
        const helper = c.helperId ? userMap.get(c.helperId) : null;
        const requester = order.requesterId ? userMap.get(order.requesterId) : null;
        return {
          ...c,
          helperName: helper?.name || '알수없음',
          helperPhone: helper?.phoneNumber,
          requesterName: requester?.name || '알수없음',
          requesterPhone: requester?.phoneNumber,
        };
      });
      
      res.json(contractsWithDetails);
    } catch (err) {
      console.error("Error fetching order contracts:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });


  // Get all contracts (admin)
  app.get("/api/admin/contracts", adminAuth, requirePermission("contracts.view"), async (req, res) => {
    try {
      const contracts = await storage.getAllContracts();
      const users = await storage.getAllUsers();
      const orders = await storage.getOrders();
      const courierSettings = await db.select().from(courierSettings as any).execute();
      const allSettlements = await storage.getAllSettlementStatements();
      
      const userMap = new Map(users.map(u => [u.id, u]));
      const orderMap = new Map(orders.map(o => [o.id, o]));
      const settlementMap = new Map<string, typeof allSettlements[0]>();
      allSettlements.forEach(s => {
        if (s.orderId && s.helperId) {
          settlementMap.set(`${s.orderId}-${s.helperId}`, s);
        }
      });
      
      const enrichedContracts = contracts.map(c => {
        const helper = c.helperId ? userMap.get(c.helperId) : null;
        const requester = c.requesterId ? userMap.get(c.requesterId) : null;
        const order = c.orderId ? orderMap.get(c.orderId) : null;
        const settlement = (c.orderId && c.helperId) ? settlementMap.get(`${c.orderId}-${c.helperId}`) : null;
        
        return {
          ...c,
          // 기본 정보
          helperName: helper?.name || null,
        trackingNumber: incident.trackingNumber || null,
        evidencePhotoUrls,
          helperPhone: helper?.phoneNumber || null,
          helperEmail: helper?.email || null,
          requesterName: requester?.name || null,
          requesterPhone: requester?.phoneNumber || null,
          orderTitle: order?.companyName || null,
          courier: order?.companyName || null,
          // 정산 데이터
          deliveryCount: settlement?.deliveryCount || 0,
          returnCount: settlement?.returnCount || 0,
          otherCount: settlement?.otherCount || 0,
          settlementAmount: settlement?.totalAmount || 0,
          settlementStatus: settlement?.status || null,
        };
      });
      
      res.json(enrichedContracts);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get single contract with details (admin)
  app.get("/api/admin/contracts/:id", adminAuth, requirePermission("contracts.view"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const contract = await storage.getContract(id);
      
      if (!contract) {
        return res.status(404).json({ message: "계약을 찾을 수 없습니다" });
      }
      
      const helper = contract.helperId ? await storage.getUser(contract.helperId) : null;
      const requester = contract.requesterId ? await storage.getUser(contract.requesterId) : null;
      const order = contract.orderId ? await storage.getOrder(contract.orderId) : null;
      const requesterBusiness = contract.requesterId ? await storage.getRequesterBusiness(contract.requesterId) : null;
      
      // Get settlement data if order completed
      const allSettlements = await storage.getAllSettlementStatements();
      const settlement = allSettlements.find(s => s.orderId === contract.orderId && s.helperId === contract.helperId);
      
      res.json({
        ...contract,
        // 헬퍼 정보
        helperName: helper?.name || null,
        trackingNumber: incident.trackingNumber || null,
        evidencePhotoUrls,
        helperPhone: helper?.phoneNumber || null,
        helperEmail: helper?.email || null,
        // 의뢰인 정보
        requesterName: requester?.name || null,
        requesterPhone: requester?.phoneNumber || null,
        requesterEmail: requester?.email || null,
        // 사업자 정보
        businessName: requesterBusiness?.businessName || null,
        // 오더 정보
        orderTitle: order?.companyName || null,
        courier: order?.companyName || null,
        deliveryArea: order?.deliveryArea || null,
        pricePerUnit: order?.pricePerUnit || 0,
        // 정산 데이터 (업무마감 후)
        deliveryCount: settlement?.deliveryCount || 0,
        returnCount: settlement?.returnCount || 0,
        pickupCount: settlement?.pickupCount || 0,
        otherCount: settlement?.otherCount || 0,
        // 금액 정보
        basePay: settlement?.basePay || 0,
        commissionAmount: settlement?.commissionAmount || 0,
        supplyAmount: settlement?.supplyAmount || 0,
        vatAmount: settlement?.vatAmount || 0,
        totalAmount: settlement?.totalAmount || contract.totalAmount || 0,
        netAmount: settlement?.netAmount || 0,
        settlementStatus: settlement?.status || null,
      });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update contract status (admin)
  app.patch("/api/admin/contracts/:id/status", adminAuth, requirePermission("contracts.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { status, notes } = req.body;
      
      const contract = await storage.getContract(id);
      if (!contract) {
        return res.status(404).json({ message: "계약을 찾을 수 없습니다" });
      }
      
      const updated = await storage.updateContract(id, { status });
      
      // 상태 변경 이벤트 기록
      await storage.createContractExecutionEvent({
        contractId: id,
        contractType: "service_contract",
        triggerType: "status_change",
        metadata: JSON.stringify({ previousStatus: contract.status, newStatus: status, notes }),
      });
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Record deposit payment (admin)
  app.patch("/api/admin/contracts/:id/deposit-paid", adminAuth, requirePermission("contracts.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { transactionRef, notes } = req.body;
      
      const contract = await storage.getContract(id);
      if (!contract) {
        return res.status(404).json({ message: "계약을 찾을 수 없습니다" });
      }
      
      const updated = await storage.updateContract(id, {
        depositPaid: true,
          depositPaidAt: new Date(),
          downPaymentStatus: "paid",
        status: "deposit_paid",
      });
      
      // 오더 상태 업데이트: awaiting_deposit → scheduled (계약금 결제 완료)
      const order = await storage.getOrder(contract.orderId);
      if (order && order.status === "awaiting_deposit") {
        await storage.updateOrder(contract.orderId, { status: "scheduled" });
      }
      
      // Payment 기록 생성
      await storage.createPayment({
        contractId: id,
        orderId: contract.orderId,
        payerId: contract.requesterId || "system",
        provider: "manual",
        amount: contract.depositAmount || 0,
        paymentType: "deposit",
        status: "captured",
      });
      
      // 이벤트 기록
      await storage.createContractExecutionEvent({
        contractId: id,
        contractType: "service_contract",
        triggerType: "deposit_paid",
        metadata: JSON.stringify({ transactionRef, notes }),
      });
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Record balance payment (admin)
  app.patch("/api/admin/contracts/:id/balance-paid", adminAuth, requirePermission("contracts.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { transactionRef, notes } = req.body;
      
      const contract = await storage.getContract(id);
      if (!contract) {
        return res.status(404).json({ message: "계약을 찾을 수 없습니다" });
      }
      
      const updated = await storage.updateContract(id, {
        balancePaid: true,
        balancePaidAt: new Date(),
      });
      
      // Payment 기록 생성
      await storage.createPayment({
        contractId: id,
        orderId: contract.orderId,
        payerId: contract.requesterId || "system",
        provider: "manual",
        amount: contract.balanceAmount || 0,
        paymentType: "balance",
        status: "captured",
      });
      
      // 이벤트 기록
      await storage.createContractExecutionEvent({
        contractId: id,
        contractType: "service_contract",
        triggerType: "balance_paid",
        metadata: JSON.stringify({ transactionRef, notes }),
      });
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // POST /admin/orders/{orderId}/balance/manual-paid - 수동 입금 확인 (idempotent)
  app.post("/api/admin/orders/:orderId/balance/manual-paid", adminAuth, requirePermission("contracts.edit"), async (req, res) => {
    try {
      const orderId = Number(req.params.orderId);
      const adminUser = (req as any).adminUser;
      const { paidAmount, memo } = req.body;
      
      // Idempotency check
      const idempotencyKey = getIdempotencyKeyFromRequest(req);
      if (idempotencyKey) {
        const { isDuplicate, isConflict, cachedResponse } = await checkIdempotency(
          adminUser?.id || "admin",
          `POST:/api/admin/orders/${orderId}/balance/manual-paid`,
          idempotencyKey,
          req.body
        );
        if (isConflict) {
          return res.status(409).json({
            error: { code: "IDEMPOTENCY_CONFLICT", message: "동일 Idempotency-Key에 다른 요청이 감지되었습니다." }
          });
        }
        if (isDuplicate && cachedResponse) {
          console.log(`[Idempotency] Returning cached manual-paid for order ${orderId}, key: ${idempotencyKey}`);
          return res.status(cachedResponse.status).json(cachedResponse.body);
        }
      }
      
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ error: { code: "NOT_FOUND", message: "오더를 찾을 수 없습니다" } });
      }
      
      // Get contract
      const contracts = await storage.getOrderContracts(orderId);
      const contract = contracts[0];
      
      if (!contract) {
        return res.status(404).json({ error: { code: "NOT_FOUND", message: "계약을 찾을 수 없습니다" } });
      }
      
      // Update contract balance status
      await storage.updateContract(contract.id, {
        balancePaid: true,
        balancePaidAt: new Date(),
        balancePaymentStatus: "PAID",
      });
      
      // Update order status
      await storage.updateOrder(orderId, { status: "balance_paid" });
      
      // Payment 기록 생성
      await storage.createPayment({
        contractId: contract.id,
        orderId,
        payerId: order.requesterId || "system",
        provider: "manual",
        amount: paidAmount || contract.balanceAmount || 0,
        paymentType: "balance",
        status: "captured",
      });
      
      // Audit log
      await db.insert(auditLogs).values({
        actorRole: "ADMIN",
        userId: adminUser?.id,
        action: "BALANCE_MANUAL_PAID",
        orderId,
        targetType: "order",
        targetId: String(orderId),
        reason: memo || "수동 입금 확인",
        newValue: JSON.stringify({ paidAmount, memo, balanceStatus: "PAID" }),
      });
      
      // Notify requester
      if (order.requesterId) {
        await storage.createNotification({
          userId: order.requesterId,
          type: "announcement",
          title: "입금 확인 완료",
          message: `오더 ${order.orderNumber || orderId}의 입금이 확인되었습니다.`,
          relatedId: orderId,
        });
      }
      
      const response = {
        ok: true,
        orderId: order.orderNumber || `O-${orderId}`,
        balanceStatus: "PAID",
        message: "입금 확인이 완료되었습니다",
      };
      
      // Store idempotency response
      if (idempotencyKey) {
        await storeIdempotencyResponse(adminUser?.id || "admin", `POST:/api/admin/orders/${orderId}/balance/manual-paid`, idempotencyKey, 200, response, req.body);
      }
      
      res.json(response);
    } catch (err) {
      console.error("Manual paid error:", err);
      res.status(500).json({ error: { code: "INTERNAL_ERROR", message: "서버 오류가 발생했습니다" } });
    }
  });

  // Cancel contract (admin)
  app.patch("/api/admin/contracts/:id/cancel", adminAuth, requirePermission("contracts.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { reason } = req.body;
      
      const contract = await storage.getContract(id);
      if (!contract) {
        return res.status(404).json({ message: "계약을 찾을 수 없습니다" });
      }
      
      const updated = await storage.updateContract(id, {
        status: "cancelled",
      });
      
      // 감사 로그 기록
      await logAdminAction({
        req,
        action: "contract.cancel",
        targetType: "contract",
        targetId: id,
        oldValue: { status: contract.status },
        newValue: { status: "cancelled", reason },
      });
      
      // 이벤트 기록
      await storage.createContractExecutionEvent({
        contractId: id,
        contractType: "service_contract",
        triggerType: "cancelled",
        metadata: JSON.stringify({ reason }),
      });
      
      // 알림
      if (contract.helperId) {
        await storage.createNotification({
          type: "announcement",
          title: "계약 취소",
          message: `계약이 취소되었습니다. 사유: ${reason || "관리자에 의한 취소"}`,
        });
      }
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 결제 상태 롤백 (수동) - 잘못된 결제 상태 수정용
  app.patch("/api/admin/contracts/:id/rollback-payment", adminAuth, requirePermission("contracts.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { depositPaid, balancePaid, reason } = req.body;
      
      if (typeof depositPaid !== "boolean" && typeof balancePaid !== "boolean") {
        return res.status(400).json({ message: "depositPaid 또는 balancePaid 값을 지정해주세요" });
      }
      
      if (!reason || reason.trim().length < 5) {
        return res.status(400).json({ message: "롤백 사유를 5자 이상 입력해주세요" });
      }
      
      const contract = await storage.getContract(id);
      if (!contract) {
        return res.status(404).json({ message: "계약을 찾을 수 없습니다" });
      }
      
      const updates: any = {};
      if (typeof depositPaid === "boolean") {
        updates.depositPaid = depositPaid;
        if (!depositPaid) updates.depositPaidAt = null;
      }
      if (typeof balancePaid === "boolean") {
        updates.balancePaid = balancePaid;
        if (!balancePaid) updates.balancePaidAt = null;
      }
      
      const updated = await storage.updateContract(id, updates);
      
      // 감사 로그 기록 (필수 - 금전 관련)
      await logAdminAction({
        req,
        action: "contract.payment_rollback",
        targetType: "contract",
        targetId: id,
        oldValue: { 
          depositPaid: contract.depositPaid, 
          balancePaid: contract.balancePaid,
          depositPaidAt: contract.depositPaidAt,
          balancePaidAt: contract.balancePaidAt
        },
        newValue: { 
          depositPaid: updates.depositPaid ?? contract.depositPaid, 
          balancePaid: updates.balancePaid ?? contract.balancePaid,
          reason
        },
      });
      
      // 이벤트 기록
      await storage.createContractExecutionEvent({
        contractId: id,
        contractType: "service_contract",
        triggerType: "payment_rollback",
        metadata: JSON.stringify({ reason, ...updates }),
      });
      
      res.json(updated);
    } catch (err) {
      console.error("Contract payment rollback error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 정산 재생성 - 결제 성공 후 정산 생성 실패 시 수동 재시도
  app.post("/api/admin/orders/:orderId/regenerate-settlement", adminAuth, requirePermission("settlements.create"), async (req, res) => {
    try {
      const orderId = Number(req.params.orderId);
      const { reason } = req.body;
      
      if (!reason || reason.trim().length < 5) {
        return res.status(400).json({ message: "재생성 사유를 5자 이상 입력해주세요" });
      }
      
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }
      
      // 기존 정산 확인
      const existingSettlements = await storage.getSettlementsByOrderId(orderId);
      if (existingSettlements.length > 0) {
        return res.status(400).json({ 
          message: "이미 정산이 존재합니다. 기존 정산을 취소한 후 재생성해주세요.",
          existingSettlements: existingSettlements.map(s => ({ id: s.id, status: s.status }))
        });
      }
      
      // 계약 정보 조회
      const contracts = await storage.getOrderContracts(orderId);
      if (contracts.length === 0) {
        return res.status(400).json({ message: "계약 정보가 없습니다" });
      }
      
      const contract = contracts[0];
      if (!contract.helperId) {
        return res.status(400).json({ message: "헬퍼 정보가 없습니다" });
      }
      
      // 헬퍼 정보 조회
      const helper = await storage.getUser(contract.helperId);
      if (!helper) {
        return res.status(400).json({ message: "헬퍼를 찾을 수 없습니다" });
      }
      
      // 수수료율 계산 (시스템 설정에서 조회)
      const platformRateSetting = await storage.getSystemSetting("default_commission_rate");
      const teamLeaderRateSetting = await storage.getSystemSetting("default_team_leader_rate");
      const platformRate = platformRateSetting?.settingValue ? parseFloat(platformRateSetting.settingValue) : 8;
      const teamLeaderRate = helper.isTeamLeader ? 0 : (teamLeaderRateSetting?.settingValue ? parseFloat(teamLeaderRateSetting.settingValue) : 2);
      const totalCommissionRate = platformRate + teamLeaderRate;
      
      // 정산 금액 계산
      const totalAmount = contract.totalAmount || 0;
      const supplyAmount = Math.round(totalAmount / 1.1);
      const vatAmount = totalAmount - supplyAmount;
      const totalCommissionAmount = Math.round(totalAmount * totalCommissionRate / 100);
      const platformCommission = Math.round(totalAmount * platformRate / 100);
      const teamLeaderIncentive = Math.round(totalAmount * teamLeaderRate / 100);
      const netPayout = totalAmount - totalCommissionAmount;
      
      // 정산 생성
      const settlement = await storage.createSettlementStatement({
        orderId,
        workDate: order.scheduledDate,
        status: "pending",
        supplyAmount,
        vatAmount,
        totalAmount,
        commissionRate: totalCommissionRate,
        commissionAmount: totalCommissionAmount,
        platformCommission,
        teamLeaderIncentive,
        netAmount: netPayout,
        teamLeaderId: helper.teamLeaderId || undefined,
      });
      
      // 감사 로그 기록
      await logAdminAction({
        req,
        action: "settlement.regenerate",
        targetType: "settlement",
        targetId: settlement.id,
        oldValue: null,
        newValue: { 
          orderId, 
          totalAmount,
          netPayout,
          reason
        },
      });
      
      console.log(`[Settlement Regenerated] Order ${orderId}, Settlement ${settlement.id}, Admin action with reason: ${reason}`);
      
      res.status(201).json({
        success: true,
        message: "정산이 재생성되었습니다",
        settlement,
      });
    } catch (err) {
      console.error("Settlement regeneration error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 정산 취소/롤백 (분쟁 해결 또는 오류 수정용)
  app.patch("/api/admin/settlements/:id/cancel", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { reason } = req.body;
      
      if (!reason || reason.trim().length < 5) {
        return res.status(400).json({ message: "취소 사유를 5자 이상 입력해주세요" });
      }
      
      const settlement = await storage.getSettlementStatement(id);
      if (!settlement) {
        return res.status(404).json({ message: "정산 내역을 찾을 수 없습니다" });
      }
      
      if (settlement.status === "paid") {
        return res.status(400).json({ message: "이미 지급 완료된 정산은 취소할 수 없습니다. 환수 처리를 이용해주세요." });
      }
      
      const updated = await storage.updateSettlementStatement(id, {
        status: "cancelled",
        holdReason: reason,
      });
      
      // 감사 로그 기록
      await logAdminAction({
        req,
        action: "settlement.cancel",
        targetType: "settlement",
        targetId: id,
        oldValue: { status: settlement.status, netAmount: settlement.netAmount },
        newValue: { status: "cancelled", reason },
      });
      
      // 기사에게 알림
      if (settlement.helperId) {
        await storage.createNotification({
          type: "announcement",
          title: "정산 취소",
          message: `정산이 취소되었습니다. 사유: ${reason}`,
          payload: JSON.stringify({ settlementId: id }),
        });
      }
      
      res.json(updated);
    } catch (err) {
      console.error("Settlement cancellation error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get all notifications (admin)
  app.get("/api/admin/notifications", adminAuth, requirePermission("notifications.view"), async (req, res) => {
    try {
      const notifications = await storage.getAllNotifications();
      res.json(notifications);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get all helper credentials (admin)
  app.get("/api/admin/helper-credentials", adminAuth, requirePermission("helpers.view"), async (req, res) => {
    try {
      const credentials = await storage.getAllHelperCredentials();
      res.json(credentials);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/requester-service-agreements", adminAuth, requirePermission("requesters.view"), async (req, res) => {
    try {
      const agreements = await storage.getAllRequesterServiceAgreements();
      res.json(agreements);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/helper-vehicles", adminAuth, requirePermission("helpers.view"), async (req, res) => {
    try {
      const vehicles = await storage.getAllHelperVehicles();
      res.json(vehicles);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/helper-businesses", adminAuth, requirePermission("helpers.view"), async (req, res) => {
    try {
      const businesses = await storage.getAllHelperBusinesses();
      res.json(businesses);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/requester-businesses", adminAuth, requirePermission("requesters.view"), async (req, res) => {
    try {
      const businesses = await storage.getAllRequesterBusinesses();
      res.json(businesses);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/helper-bank-accounts", adminAuth, requirePermission("helpers.view"), async (req, res) => {
    try {
      const accounts = await storage.getAllHelperBankAccounts();
      res.json(accounts);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/helper-licenses", adminAuth, requirePermission("helpers.view"), async (req, res) => {
    try {
      const licenses = await storage.getAllHelperLicenses();
      res.json(licenses);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // Admin 수동 처리 API (T-23: 연동 OFF 시 운영 가능)
  // ============================================

  // 헬퍼 인증 수기 승인 (IDENTITY_PROVIDER=mock 대체)
  app.post("/api/admin/helpers/:helperId/verify", adminAuth, requirePermission("helpers.edit"), async (req: any, res) => {
    try {
      const helperId = req.params.helperId;
      const adminUser = req.user;
      const { reason } = req.body;

      const helper = await storage.getUser(helperId);
      if (!helper || helper.role !== "helper") {
        return res.status(404).json({ code: "NOT_FOUND", message: "헬퍼를 찾을 수 없습니다" });
      }

      if (helper.helperVerified) {
        return res.status(400).json({ code: "ALREADY_VERIFIED", message: "이미 인증된 헬퍼입니다" });
      }

      await db.update(users)
        .set({
          helperVerified: true,
          helperVerifiedAt: new Date(),
          helperVerifiedBy: adminUser.id,
          onboardingStatus: "approved",
        })
        .where(eq(users.id, helperId));

      await db.insert(auditLogs).values({
        actorRole: "ADMIN",
        userId: adminUser.id,
        action: "HELPER_VERIFIED",
        targetType: "user",
        reason: reason || "관리자 수기 승인",
        oldValue: JSON.stringify({ helperVerified: false, onboardingStatus: helper.onboardingStatus }),
        newValue: JSON.stringify({ helperVerified: true, onboardingStatus: "approved" }),
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });

      await storage.createNotification({
        type: "system" as any,
        title: "헬퍼 인증 완료",
        message: "관리자 확인을 통해 헬퍼 인증이 완료되었습니다. 이제 업무를 시작할 수 있습니다.",
      });

      res.json({ success: true, message: "헬퍼 인증이 완료되었습니다" });
    } catch (err) {
      console.error("Helper verify error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 헬퍼 인증 취소 (필요시)
  app.post("/api/admin/helpers/:helperId/unverify", adminAuth, requirePermission("helpers.edit"), async (req: any, res) => {
    try {
      const helperId = req.params.helperId;
      const adminUser = req.user;
      const { reason } = req.body;

      if (!reason) {
        return res.status(400).json({ code: "REASON_REQUIRED", message: "취소 사유를 입력해주세요" });
      }

      const helper = await storage.getUser(helperId);
      if (!helper) {
        return res.status(404).json({ code: "NOT_FOUND", message: "헬퍼를 찾을 수 없습니다" });
      }

      await db.update(users)
        .set({
          helperVerified: false,
          helperVerifiedAt: null,
          helperVerifiedBy: null,
          onboardingStatus: "rejected",
        })
        .where(eq(users.id, helperId));

      await db.insert(auditLogs).values({
        actorRole: "ADMIN",
        userId: adminUser.id,
        action: "HELPER_UNVERIFIED",
        targetType: "user",
        reason,
        oldValue: JSON.stringify({ helperVerified: true, onboardingStatus: helper.onboardingStatus }),
        newValue: JSON.stringify({ helperVerified: false, onboardingStatus: "rejected" }),
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });

      res.json({ success: true, message: "헬퍼 인증이 취소되었습니다" });
    } catch (err) {
      console.error("Helper unverify error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 증빙 재요청 (마감 후 추가 증빙 요청)
  app.post("/api/admin/orders/:orderId/request-evidence", adminAuth, requirePermission("orders.edit"), async (req: any, res) => {
    try {
      const orderId = Number(req.params.orderId);
      const adminUser = req.user;
      const { evidenceType, message: requestMessage } = req.body;

      if (!evidenceType || !requestMessage) {
        return res.status(400).json({ code: "INVALID_INPUT", message: "증빙 유형과 요청 내용을 입력해주세요" });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ code: "NOT_FOUND", message: "오더를 찾을 수 없습니다" });
      }

      const targetUserId = order.matchedHelperId || order.helperId;
      if (targetUserId) {
        await storage.createNotification({
          userId: targetUserId,
          type: "order_update" as any,
          title: "추가 증빙 요청",
          message: `[${evidenceType}] ${requestMessage}`,
          relatedId: orderId,
        });

        sendPushToUser(Number(targetUserId), {
          title: "추가 증빙 요청",
          body: `오더 #${orderId}에 대한 추가 증빙이 요청되었습니다.`,
          url: `/orders/${orderId}/closing`,
          tag: `evidence-request-${orderId}`,
        });
      }

      await db.insert(auditLogs).values({
        actorRole: "ADMIN",
        userId: adminUser.id,
        action: "EVIDENCE_REQUESTED",
        targetType: "order",
        targetId: String(orderId),
        orderId,
        reason: `${evidenceType}: ${requestMessage}`,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });

      res.json({ success: true, message: "증빙 재요청이 전송되었습니다" });
    } catch (err) {
      console.error("Request evidence error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 연동 이벤트 목록 조회 (실패 건 확인)
  app.get("/api/admin/integration-events", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const { status, provider, limit = 100 } = req.query;
      
      let query = db.select().from(integrationEvents);
      
      if (status) {
        query = query.where(eq(integrationEvents.status, String(status))) as any;
      }
      if (provider) {
        query = query.where(eq(integrationEvents.provider, String(provider))) as any;
      }
      
      const events = await query
        .orderBy(desc(integrationEvents.createdAt))
        .limit(Number(limit));
      
      res.json(events);
    } catch (err) {
      console.error("Get integration events error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 연동 상태 조회
  app.get("/api/admin/integration-status", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const status = {
        sms: process.env.SMS_PROVIDER?.toLowerCase() === 'real' ? 'real' : 'mock',
        push: process.env.PUSH_PROVIDER?.toLowerCase() === 'real' ? 'real' : 'mock',
        payment: process.env.PAYMENT_PROVIDER?.toLowerCase() === 'real' ? 'real' : 'mock',
        identity: process.env.IDENTITY_PROVIDER?.toLowerCase() === 'real' ? 'real' : 'mock',
      };
      
      res.json(status);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 미인증 헬퍼 목록 조회 (수기 승인 대기)
  app.get("/api/admin/helpers/pending-verification", adminAuth, requirePermission("helpers.view"), async (req, res) => {
    try {
      const pendingHelpers = await db.select({
        id: users.id,
        name: users.name,
        email: users.email,
        phoneNumber: users.phoneNumber,
        createdAt: users.createdAt,
        onboardingStatus: users.onboardingStatus,
        helperVerified: users.helperVerified,
      })
        .from(users)
        .where(and(
          eq(users.role, "helper"),
          or(
            eq(users.helperVerified, false),
            sql`${users.helperVerified} IS NULL`
          )
        ))
        .orderBy(desc(users.createdAt));
      
      res.json(pendingHelpers);
    } catch (err) {
      console.error("Get pending helpers error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // Admin 비용 항목 타입 CRUD
  // 스펙: POST/PUT/GET /admin/cost-item-types
  // ============================================

  // 비용 항목 타입 목록 조회 (admin)
  app.get("/api/admin/cost-item-types", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const types = await storage.getAllCostItemTypes();
      res.json(types);
    } catch (err) {
      console.error("Error fetching cost item types:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 비용 항목 타입 추가 (admin)
  app.post("/api/admin/cost-item-types", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const user = (req as any).user;
      const { name, sign, is_active, sortOrder } = req.body;

      if (!name || !sign) {
        return res.status(400).json({ 
          error: { code: "INVALID_INPUT", message: "name과 sign은 필수입니다" } 
        });
      }

      if (!["PLUS", "MINUS"].includes(sign)) {
        return res.status(400).json({ 
          error: { code: "INVALID_SIGN", message: "sign은 PLUS 또는 MINUS여야 합니다" } 
        });
      }

      const type = await storage.createCostItemType({
        name,
        sign: sign.toLowerCase(), // 스토리지에서는 소문자 사용
        isActive: is_active !== false,
        sortOrder: sortOrder || 0,
      });

      // 감사 로그 기록
      await logAdminAction({
        userId: user.id,
        action: "create",
        targetType: "cost_item_type",
        targetId: String(type.id),
        reason: `비용 항목 타입 추가: ${name}`,
        metadata: { name, sign, is_active },
      });

      res.status(201).json({
        id: type.id,
        name: type.name,
        sign: type.sign?.toUpperCase(),
        is_active: type.isActive,
      });
    } catch (err) {
      console.error("Error creating cost item type:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 비용 항목 타입 수정 (admin)
  app.put("/api/admin/cost-item-types/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const user = (req as any).user;
      const id = parseInt(req.params.id);
      const { name, sign, is_active } = req.body;

      const existing = await storage.getCostItemType(id);
      if (!existing) {
        return res.status(404).json({ 
          error: { code: "NOT_FOUND", message: "비용 항목 타입을 찾을 수 없습니다" } 
        });
      }

      const updates: any = {};
      if (name !== undefined) updates.name = name;
      if (sign !== undefined) {
        if (!["PLUS", "MINUS"].includes(sign)) {
          return res.status(400).json({ 
            error: { code: "INVALID_SIGN", message: "sign은 PLUS 또는 MINUS여야 합니다" } 
          });
        }
        updates.sign = sign.toLowerCase();
      }
      if (is_active !== undefined) updates.isActive = is_active;

      const updated = await storage.updateCostItemType(id, updates);

      // 감사 로그 기록
      await logAdminAction({
        userId: user.id,
        action: "update",
        targetType: "cost_item_type",
        targetId: String(id),
        reason: `비용 항목 타입 수정: ${updated.name}`,
        metadata: { before: existing, after: updates },
      });

      res.json({
        id: updated.id,
        name: updated.name,
        sign: updated.sign?.toUpperCase(),
        is_active: updated.isActive,
      });
    } catch (err) {
      console.error("Error updating cost item type:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get all payments (admin)
  app.get("/api/admin/payments", adminAuth, requirePermission("payments.view"), async (req, res) => {
    try {
      const payments = await storage.getAllPayments();
      res.json(payments);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get single payment (admin)
  app.get("/api/admin/payments/:id", adminAuth, requirePermission("payments.view"), async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const payment = await storage.getPayment(id);
      if (!payment) {
        return res.status(404).json({ error: { code: "NOT_FOUND", message: "결제를 찾을 수 없습니다" } });
      }
      res.json(payment);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Refund payment (admin)
  app.post("/api/admin/payments/:id/refund", adminAuth, requirePermission("payments.edit"), async (req, res) => {
    try {
      const user = (req as any).adminUser || (req as any).user;
      const id = parseInt(req.params.id);
      const { reason, amount } = req.body;

      if (!reason || reason.length < 5) {
        return res.status(400).json({ 
          error: { code: "INVALID_REASON", message: "환불 사유는 최소 5자 이상이어야 합니다" } 
        });
      }

      const payment = await storage.getPayment(id);
      if (!payment) {
        return res.status(404).json({ error: { code: "NOT_FOUND", message: "결제를 찾을 수 없습니다" } });
      }

      if (payment.status === "refunded") {
        return res.status(400).json({ 
          error: { code: "ALREADY_REFUNDED", message: "이미 환불된 결제입니다" } 
        });
      }

      if (payment.status !== "captured" && payment.status !== "completed") {
        return res.status(400).json({ 
          error: { code: "INVALID_STATUS", message: "환불 가능한 상태가 아닙니다. 결제 완료 상태에서만 환불할 수 있습니다." } 
        });
      }

      // 환불 금액 계산 (부분 환불 지원)
      const refundAmount = amount || payment.amount;
      if (refundAmount > payment.amount) {
        return res.status(400).json({ 
          error: { code: "INVALID_AMOUNT", message: "환불 금액이 결제 금액을 초과합니다" } 
        });
      }

      // TODO: 실제 PG사 환불 API 호출 (PortOne/Toss)
      // const pgRefundResult = await processRefundWithPG(payment.pgTransactionId, refundAmount);

      // 결제 상태 업데이트 (전액/부분 환불 모두 "refunded" 상태로 처리)
      const isFullRefund = refundAmount === payment.amount;
      const updated = await storage.updatePayment(id, {
        status: "refunded",
        refundedAt: new Date(),
        refundReason: isFullRefund ? reason : `[부분환불 ${refundAmount}원] ${reason}`,
      });

      // 감사 로그 기록
      await logAdminAction({
        userId: user.id,
        action: "refund",
        targetType: "payment",
        targetId: String(id),
        reason,
        metadata: { 
          originalAmount: payment.amount, 
          refundAmount, 
          isFullRefund,
          orderId: payment.orderId,
        },
      });

      res.json({
        success: true,
        payment: updated,
        refund_amount: refundAmount,
        is_full_refund: isFullRefund,
      });
    } catch (err) {
      console.error("Payment refund error:", err);
      res.status(500).json({ message: "환불 처리 중 오류가 발생했습니다" });
    }
  });

  // Sync payment status with PG (admin)
  app.post("/api/admin/payments/:id/sync", adminAuth, requirePermission("payments.edit"), async (req, res) => {
    try {
      const user = (req as any).adminUser || (req as any).user;
      const id = parseInt(req.params.id);
      const { reason } = req.body;

      const payment = await storage.getPayment(id);
      if (!payment) {
        return res.status(404).json({ error: { code: "NOT_FOUND", message: "결제를 찾을 수 없습니다" } });
      }

      // TODO: 실제 PG사 결제 상태 조회 API 호출
      // const pgStatus = await queryPaymentStatusFromPG(payment.pgTransactionId);
      
      // 임시: 현재 상태 그대로 반환 (실제 구현 시 PG 조회 결과로 대체)
      const syncedStatus = payment.status;

      // 감사 로그 기록
      await logAdminAction({
        userId: user.id,
        action: "sync",
        targetType: "payment",
        targetId: String(id),
        reason: reason || "결제 상태 동기화",
        metadata: { 
          beforeStatus: payment.status, 
          afterStatus: syncedStatus,
          orderId: payment.orderId,
        },
      });

      res.json({
        success: true,
        payment,
        synced_status: syncedStatus,
        message: "PG 연동 시 실제 상태로 동기화됩니다",
      });
    } catch (err) {
      console.error("Payment sync error:", err);
      res.status(500).json({ message: "결제 동기화 중 오류가 발생했습니다" });
    }
  });

  // Update payment status (admin)
  app.patch("/api/admin/payments/:id/status", adminAuth, requirePermission("payments.edit"), async (req, res) => {
    try {
      const user = (req as any).adminUser || (req as any).user;
      const id = parseInt(req.params.id);
      const { status, reason } = req.body;

      if (!reason || reason.length < 10) {
        return res.status(400).json({ 
          error: { code: "INVALID_REASON", message: "변경 사유는 최소 10자 이상이어야 합니다" } 
        });
      }

      const validStatuses = ["pending", "awaiting_deposit", "captured", "completed", "failed", "cancelled", "refunded"];
      if (!validStatuses.includes(status)) {
        return res.status(400).json({ 
          error: { code: "INVALID_STATUS", message: `유효하지 않은 상태입니다. 허용: ${validStatuses.join(", ")}` } 
        });
      }

      const payment = await storage.getPayment(id);
      if (!payment) {
        return res.status(404).json({ error: { code: "NOT_FOUND", message: "결제를 찾을 수 없습니다" } });
      }

      const updated = await storage.updatePayment(id, { status });

      // 감사 로그 기록
      await logAdminAction({
        userId: user.id,
        action: "status_change",
        targetType: "payment",
        targetId: String(id),
        reason,
        metadata: { 
          beforeStatus: payment.status, 
          afterStatus: status,
          orderId: payment.orderId,
        },
      });

      res.json(updated);
    } catch (err) {
      console.error("Payment status update error:", err);
      res.status(500).json({ message: "결제 상태 변경 중 오류가 발생했습니다" });
    }
  });

  // Retry failed payment (admin)
  app.post("/api/admin/payments/:id/retry", adminAuth, requirePermission("payments.edit"), async (req, res) => {
    try {
      const user = (req as any).adminUser || (req as any).user;
      const id = parseInt(req.params.id);
      const { reason } = req.body;

      if (!reason || reason.length < 5) {
        return res.status(400).json({ 
          error: { code: "INVALID_REASON", message: "재시도 사유는 최소 5자 이상이어야 합니다" } 
        });
      }

      const payment = await storage.getPayment(id);
      if (!payment) {
        return res.status(404).json({ error: { code: "NOT_FOUND", message: "결제를 찾을 수 없습니다" } });
      }

      if (payment.status !== "failed") {
        return res.status(400).json({ 
          error: { code: "INVALID_STATUS", message: "실패 상태의 결제만 재시도할 수 있습니다" } 
        });
      }

      const currentRetryCount = payment.retryCount || 0;
      if (currentRetryCount >= 3) {
        return res.status(400).json({ 
          error: { code: "MAX_RETRY_EXCEEDED", message: "최대 재시도 횟수(3회)를 초과했습니다" } 
        });
      }

      // Update status to pending and increment retry count
      const updated = await storage.updatePayment(id, { 
        status: "pending",
        retryCount: currentRetryCount + 1,
      });

      // Log admin action
      await logAdminAction({
        userId: user.id,
        action: "retry",
        targetType: "payment",
        targetId: String(id),
        reason,
        metadata: { 
          previousStatus: payment.status,
          retryCount: currentRetryCount + 1,
          orderId: payment.orderId,
        },
      });

      res.json({
        success: true,
        payment: updated,
        retry_count: currentRetryCount + 1,
        message: "결제 재시도가 예약되었습니다",
      });
    } catch (err) {
      console.error("Payment retry error:", err);
      res.status(500).json({ message: "결제 재시도 중 오류가 발생했습니다" });
    }
  });

  // ============================================
  // Admin 웹훅 로그 조회/재시도
  // 스펙: GET /admin/webhooks, POST /admin/webhooks/{webhookLogId}/retry
  // ============================================

  // 웹훅 로그 목록 조회 (admin)
  app.get("/api/admin/webhooks", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const { source, status, limit } = req.query;
      const parsedLimit = limit ? Math.min(Math.max(parseInt(limit as string) || 100, 1), 500) : 100;
      
      const logs = await storage.getAllWebhookLogs({
        source: source as string | undefined,
        status: status as string | undefined,
        limit: parsedLimit,
      });
      
      res.json(logs.map(log => ({
        webhook_log_id: String(log.id),
        source: log.source,
        event_type: log.eventType,
        webhook_id: log.webhookId,
        status: log.status?.toUpperCase(),
        processed_at: log.processedAt,
        error_message: log.errorMessage,
        retry_count: log.retryCount,
        related_entity_type: log.relatedEntityType,
        related_entity_id: log.relatedEntityId,
        created_at: log.createdAt,
      })));
    } catch (err) {
      console.error("Error fetching webhook logs:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 웹훅 로그 상세 조회 (admin)
  app.get("/api/admin/webhooks/:id", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const log = await storage.getWebhookLog(id);
      
      if (!log) {
        return res.status(404).json({ 
          error: { code: "NOT_FOUND", message: "웹훅 로그를 찾을 수 없습니다" } 
        });
      }
      
      res.json({
        webhook_log_id: String(log.id),
        source: log.source,
        event_type: log.eventType,
        webhook_id: log.webhookId,
        payload: log.payload ? JSON.parse(log.payload) : null,
        status: log.status?.toUpperCase(),
        processed_at: log.processedAt,
        error_message: log.errorMessage,
        retry_count: log.retryCount,
        related_entity_type: log.relatedEntityType,
        related_entity_id: log.relatedEntityId,
        idempotency_key: log.idempotencyKey,
        ip_address: log.ipAddress,
        created_at: log.createdAt,
      });
    } catch (err) {
      console.error("Error fetching webhook log:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 웹훅 재처리 (admin)
  app.post("/api/admin/webhooks/:id/retry", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const user = (req as any).user;
      const id = parseInt(req.params.id);
      const { reason } = req.body;

      const log = await storage.getWebhookLog(id);
      if (!log) {
        return res.status(404).json({ 
          error: { code: "NOT_FOUND", message: "웹훅 로그를 찾을 수 없습니다" } 
        });
      }

      // 이미 처리된 웹훅은 재처리 불필요
      if (log.status === "processed") {
        return res.status(400).json({ 
          error: { code: "ALREADY_PROCESSED", message: "이미 처리된 웹훅입니다" } 
        });
      }

      // 재처리 시도 (실제 처리 로직은 웹훅 타입에 따라 다름)
      const retryCount = (log.retryCount || 0) + 1;
      let result = "PROCESSING";
      
      try {
        const payload = log.payload ? JSON.parse(log.payload) : {};
        
        // 웹훅 타입별 실제 재처리 로직
        if (log.source === "portone" && log.eventType?.includes("payment")) {
          // PortOne 결제 웹훅 재처리
          const paymentId = payload.paymentId || payload.data?.paymentId;
          if (paymentId) {
            // 결제 상태 확인 및 DB 업데이트
            const payment = await storage.getPaymentByProviderPaymentId(paymentId);
            if (payment) {
              const newStatus = payload.data?.status || payload.status;
              if (newStatus && newStatus !== payment.status) {
                await storage.updatePayment(payment.id, { 
                  status: newStatus,
                  paidAt: newStatus === 'paid' || newStatus === 'captured' ? new Date() : payment.paidAt
                });
                
                // 오더 상태도 업데이트 (계약금 입금 완료 시)
                if ((newStatus === 'paid' || newStatus === 'captured') && payment.orderId) {
                  const order = await storage.getOrder(payment.orderId);
                  if (order && order.status === 'awaiting_deposit') {
                    await storage.updateOrder(payment.orderId, { status: 'open' });
                  }
                }
              }
            }
          }
          result = "PROCESSED";
        } else if (log.source === "settlement" || log.eventType?.includes("settlement")) {
          // 정산 관련 웹훅 재처리
          const settlementId = payload.settlementId || payload.data?.settlementId;
          if (settlementId) {
            const settlement = await storage.getSettlementRecord(parseInt(settlementId));
            if (settlement) {
              const newStatus = payload.data?.status || payload.status;
              if (newStatus && newStatus !== settlement.status) {
                await storage.updateSettlementRecord(settlement.id, { status: newStatus });
              }
            }
          }
          result = "PROCESSED";
        } else {
          // 기타 웹훅 - 상태만 업데이트
          result = "PROCESSED";
        }
        
        await storage.updateWebhookLog(id, {
          status: "processed",
          processedAt: new Date(),
          retryCount,
        });
      } catch (processingError: any) {
        result = "FAILED";
        await storage.updateWebhookLog(id, {
          status: "failed",
          errorMessage: processingError.message || "재처리 중 오류 발생",
          retryCount,
        });
      }

      // 감사 로그 기록
      await logAdminAction({
        userId: user.id,
        action: "webhook_retry",
        targetType: "webhook_log",
        targetId: String(id),
        reason: reason || "웹훅 재처리",
        metadata: { retry_count: retryCount, result },
      });

      res.json({
        webhook_log_id: String(id),
        status: "RETRIED",
        result,
        retry_count: retryCount,
      });
    } catch (err) {
      console.error("Error retrying webhook:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get audit logs (admin)
  app.get("/api/admin/audit-logs", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const { userId, action, targetType, targetId, limit } = req.query;
      const parsedLimit = limit ? Math.min(Math.max(parseInt(limit as string) || 100, 1), 1000) : 100;
      const logs = await storage.getAuditLogs({
        userId: userId as string | undefined,
        action: action as string | undefined,
        targetType: targetType as string | undefined,
        targetId: targetId as string | undefined,
        limit: parsedLimit,
      });
      res.json(logs);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // Admin Dispute Management API (분쟁 관리)
  // ============================================
  
  // GET /api/admin/disputes - 분쟁 목록 조회

  // GET /api/admin/disputes/:id - 분쟁 상세 조회

  // PATCH /api/admin/disputes/:id/start-review - 검토 시작
  app.patch("/api/admin/disputes/:id/start-review", adminAuth, requirePermission("disputes.review"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const adminUser = (req as any).adminUser;
      
      const incident = await storage.getIncidentReport(id);
      if (!incident) {
        return res.status(404).json({ message: "분쟁을 찾을 수 없습니다" });
      }
      
      if (incident.status !== "requested" && incident.status !== "submitted") {
        return res.status(400).json({ message: `검토 시작할 수 없는 상태입니다: ${incident.status}` });
      }
      
      // Update incident status
      const [updated] = await db.update(incidentReports)
        .set({
          status: "reviewing",
          reviewerId: adminUser?.id,
          reviewStartedAt: new Date(),
        })
        .where(eq(incidentReports.id, id))
        .returning();
      
      // Update order status
      await db.update(orders)
        .set({ status: "dispute_reviewing" })
        .where(eq(orders.id, incident.orderId));
      
      // Audit log
      await db.insert(auditLogs).values({
        actorRole: "ADMIN",
        userId: adminUser?.id,
        action: "DISPUTE_REVIEW_STARTED",
        orderId: incident.orderId,
          incidentId: incidentId,
          reasonCategory: "incident",
        incidentId: id,
        targetType: "incident",
        targetId: String(id),
        reason: "분쟁 검토 시작",
        oldValue: JSON.stringify({ status: incident.status }),
        newValue: JSON.stringify({ status: "reviewing" }),
      });
      
      // 차감 금액이 있으면 deductions 테이블에 추가
      if (deductionAmount && deductionAmount > 0 && incident.helperId) {
        await db.insert(deductions).values({
          orderId: incident.orderId,
          incidentId: incidentId,
          reasonCategory: "incident",
          incidentId: id,
          requesterId: incident.requesterId,
          targetType: "helper",
          targetId: incident.helperId,
          amount: deductionAmount,
          reason: deductionReason || adminMemo.trim(),
          category: incident.incidentType || "dispute",
          status: "pending",
          createdBy: adminUser?.id,
          memo: adminMemo.trim(),
        });
      }

      res.json({ success: true, incident: updated });
    } catch (err) {
      console.error("Start dispute review error:", err);
      res.status(500).json({ message: "검토 시작에 실패했습니다" });
    }
  });

  // PATCH /api/admin/disputes/:id/resolve - 분쟁 해결 (인정/부분인정)
  app.patch("/api/admin/disputes/:id/resolve", adminAuth, requirePermission("disputes.resolve"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const adminUser = (req as any).adminUser;
      const { adminMemo, deductionAmount, deductionReason, resolutionAmount } = req.body;
      
      if (!adminMemo || adminMemo.trim().length < 10) {
        return res.status(400).json({ message: "관리자 메모는 10자 이상 입력해주세요" });
      }
      
      const incident = await storage.getIncidentReport(id);
      if (!incident) {
        return res.status(404).json({ message: "분쟁을 찾을 수 없습니다" });
      }
      
      if (incident.status !== "reviewing") {
        return res.status(400).json({ message: `해결할 수 없는 상태입니다: ${incident.status}` });
      }
      
      // Update incident
      const [updated] = await db.update(incidentReports)
        .set({
          status: "resolved",
          adminMemo: adminMemo.trim(),
          deductionAmount: deductionAmount || 0,
          deductionReason: deductionReason || null,
          resolution: adminMemo.trim(),
          resolutionAmount: resolutionAmount || deductionAmount || 0,
          resolvedBy: adminUser?.id,
          resolvedAt: new Date(),
        })
        .where(eq(incidentReports.id, id))
        .returning();
      
      // Update order status
      await db.update(orders)
        .set({ status: "dispute_resolved" })
        .where(eq(orders.id, incident.orderId));
      
      // Audit log
      await db.insert(auditLogs).values({
        actorRole: "ADMIN",
        userId: adminUser?.id,
        action: "DISPUTE_RESOLVED",
        orderId: incident.orderId,
          incidentId: incidentId,
          reasonCategory: "incident",
        incidentId: id,
        targetType: "incident",
        targetId: String(id),
        reason: adminMemo.trim(),
        oldValue: JSON.stringify({ status: incident.status }),
        newValue: JSON.stringify({ 
          status: "resolved", 
          deductionAmount: deductionAmount || 0,
          deductionReason,
        }),
      });
      
      // 차감 금액이 있으면 deductions 테이블에 추가
      if (deductionAmount && deductionAmount > 0 && incident.helperId) {
        await db.insert(deductions).values({
          orderId: incident.orderId,
          incidentId: incidentId,
          reasonCategory: "incident",
          incidentId: id,
          requesterId: incident.requesterId,
          targetType: "helper",
          targetId: incident.helperId,
          amount: deductionAmount,
          reason: deductionReason || adminMemo.trim(),
          category: incident.incidentType || "dispute",
          status: "pending",
          createdBy: adminUser?.id,
          memo: adminMemo.trim(),
        });
      }

      res.json({ success: true, incident: updated });
    } catch (err) {
      console.error("Resolve dispute error:", err);
      res.status(500).json({ message: "분쟁 해결에 실패했습니다" });
    }
  });

  // PATCH /api/admin/disputes/:id/reject - 분쟁 기각
  app.patch("/api/admin/disputes/:id/reject", adminAuth, requirePermission("disputes.resolve"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const adminUser = (req as any).adminUser;
      const { adminMemo } = req.body;
      
      if (!adminMemo || adminMemo.trim().length < 10) {
        return res.status(400).json({ message: "기각 사유는 10자 이상 입력해주세요" });
      }
      
      const incident = await storage.getIncidentReport(id);
      if (!incident) {
        return res.status(404).json({ message: "분쟁을 찾을 수 없습니다" });
      }
      
      if (incident.status !== "reviewing") {
        return res.status(400).json({ message: `기각할 수 없는 상태입니다: ${incident.status}` });
      }
      
      // Update incident
      const [updated] = await db.update(incidentReports)
        .set({
          status: "rejected",
          adminMemo: adminMemo.trim(),
          resolution: adminMemo.trim(),
          resolvedBy: adminUser?.id,
          resolvedAt: new Date(),
        })
        .where(eq(incidentReports.id, id))
        .returning();
      
      // Update order status
      await db.update(orders)
        .set({ status: "dispute_rejected" })
        .where(eq(orders.id, incident.orderId));
      
      // Audit log
      await db.insert(auditLogs).values({
        actorRole: "ADMIN",
        userId: adminUser?.id,
        action: "DISPUTE_REJECTED",
        orderId: incident.orderId,
          incidentId: incidentId,
          reasonCategory: "incident",
        incidentId: id,
        targetType: "incident",
        targetId: String(id),
        reason: adminMemo.trim(),
        oldValue: JSON.stringify({ status: incident.status }),
        newValue: JSON.stringify({ status: "rejected" }),
      });
      
      // 차감 금액이 있으면 deductions 테이블에 추가
      if (deductionAmount && deductionAmount > 0 && incident.helperId) {
        await db.insert(deductions).values({
          orderId: incident.orderId,
          incidentId: incidentId,
          reasonCategory: "incident",
          incidentId: id,
          requesterId: incident.requesterId,
          targetType: "helper",
          targetId: incident.helperId,
          amount: deductionAmount,
          reason: deductionReason || adminMemo.trim(),
          category: incident.incidentType || "dispute",
          status: "pending",
          createdBy: adminUser?.id,
          memo: adminMemo.trim(),
        });
      }

      res.json({ success: true, incident: updated });
    } catch (err) {
      console.error("Reject dispute error:", err);
      res.status(500).json({ message: "분쟁 기각에 실패했습니다" });
    }
  });

  // POST /api/admin/disputes/:id/confirm-refund - 환불 확정 및 CS환불 생성
  app.post("/api/admin/disputes/:id/confirm-refund", adminAuth, requirePermission("disputes.resolve"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const adminUser = (req as any).adminUser;
      const { amount, reason } = req.body;
      
      if (!amount || amount <= 0) {
        return res.status(400).json({ message: "환불 금액을 입력해주세요" });
      }
      
      if (!reason || reason.trim().length < 5) {
        return res.status(400).json({ message: "환불 사유는 5자 이상 입력해주세요" });
      }
      
      // Get incident/dispute
      const incident = await storage.getIncidentReport(id);
      if (!incident) {
        return res.status(404).json({ message: "분쟁을 찾을 수 없습니다" });
      }
      
      // Get order to find payment
      const order = await storage.getOrder(incident.orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }
      
      // Get payment for this order
      const payment = await storage.getPaymentByOrderId(incident.orderId);
      if (!payment) {
        return res.status(404).json({ message: "결제 정보를 찾을 수 없습니다" });
      }
      
      // Create CS refund record
      const [refund] = await db.insert(refunds).values({
        paymentId: payment.id,
        orderId: incident.orderId,
          incidentId: incidentId,
          reasonCategory: "incident",
        amount,
        reason: reason.trim(),
        reasonCategory: "dispute",
        status: "pending",
        refundMethod: "bank_transfer",
        requestedBy: adminUser?.id,
      }).returning();
      
      // Update incident status to resolved
      await db.update(incidentReports)
        .set({
          status: "resolved",
          resolution: reason.trim(),
          resolutionAmount: amount,
          resolvedBy: adminUser?.id,
          resolvedAt: new Date(),
        })
        .where(eq(incidentReports.id, id));
      
      // Audit log
      await db.insert(auditLogs).values({
        actorRole: "ADMIN",
        userId: adminUser?.id,
        action: "REFUND_CONFIRMED",
        orderId: incident.orderId,
          incidentId: incidentId,
          reasonCategory: "incident",
        incidentId: id,
        targetType: "refund",
        targetId: String(refund.id),
        reason: reason.trim(),
        newValue: JSON.stringify({ refundId: refund.id, amount }),
      });
      
      console.log(`[CS Refund] Created refund ${refund.id} for dispute ${id}, amount: ${amount}`);
      
      res.json({ success: true, refund, message: "환불이 확정되어 CS환불로 이동되었습니다" });
    } catch (err) {
      console.error("Confirm refund error:", err);
      res.status(500).json({ message: "환불 확정에 실패했습니다" });
    }
  });

  // POST /api/admin/disputes/:id/resolve-without-refund - 환불 없이 분쟁 해결 (물건 발견, 합의 등)
  app.post("/api/admin/disputes/:id/resolve-without-refund", adminAuth, requirePermission("disputes.resolve"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const adminUser = (req as any).adminUser;
      const { reason, resolutionType } = req.body;
      
      if (!reason || reason.trim().length < 5) {
        return res.status(400).json({ message: "해결 사유는 5자 이상 입력해주세요" });
      }
      
      const incident = await storage.getIncidentReport(id);
      if (!incident) {
        return res.status(404).json({ message: "분쟁을 찾을 수 없습니다" });
      }
      
      const validTypes = ['item_found', 'mutual_agreement', 'misunderstanding', 'other'];
      const type = validTypes.includes(resolutionType) ? resolutionType : 'other';
      
      await db.update(incidentReports)
        .set({
          status: "resolved",
          resolution: "[" + type + "] " + reason.trim(),
          resolutionAmount: 0,
          resolvedBy: adminUser?.id,
          resolvedAt: new Date(),
        })
        .where(eq(incidentReports.id, id));
      
      await db.insert(auditLogs).values({
        actorRole: "ADMIN",
        userId: adminUser?.id,
        action: "DISPUTE_RESOLVED_NO_REFUND",
        orderId: incident.orderId,
          incidentId: incidentId,
          reasonCategory: "incident",
        incidentId: id,
        targetType: "incident",
        targetId: String(id),
        reason: reason.trim(),
        newValue: JSON.stringify({ resolutionType: type }),
      });
      
      console.log("[Dispute] Resolved without refund - dispute " + id + ", type: " + type);
      
      res.json({ success: true, message: "분쟁이 환불 없이 해결 처리되었습니다" });
    } catch (err) {
      console.error("Resolve without refund error:", err);
      res.status(500).json({ message: "분쟁 해결에 실패했습니다" });
    }
  });

  // POST /api/admin/disputes/:id/reply - 이의제기 답변 달기
  app.post("/api/admin/disputes/:id/reply", adminAuth, requirePermission("disputes.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const adminUser = (req as any).adminUser;
      const { reply } = req.body;
      
      if (!reply || reply.trim().length < 5) {
        return res.status(400).json({ message: "답변은 5자 이상 입력해주세요" });
      }
      
      // Check if it's a dispute (new system)
      const [dispute] = await db.select().from(disputes).where(eq(disputes.id, id));
      
      if (dispute) {
        // Update dispute with reply
        const [updated] = await db.update(disputes)
          .set({
            adminReply: reply.trim(),
            adminReplyAt: new Date(),
            adminReplyBy: adminUser?.id,
          })
          .where(eq(disputes.id, id))
          .returning();
        
      // 증빙사진 조회
      const evidenceRows = await db.select().from(incidentEvidence).where(eq(incidentEvidence.incidentId, id));
      const evidencePhotoUrls = evidenceRows.filter(e => e.evidenceType === "photo").map(e => e.fileUrl);

        // Get helper info for notification
        const [helper] = await db.select().from(users).where(eq(users.id, dispute.helperId));
        
        // Send notification to helper
        if (helper) {
          await storage.createNotification({
            type: "dispute_reply",
            title: "이의제기 답변",
            message: `이의제기에 대한 답변이 등록되었습니다: ${reply.trim().substring(0, 50)}...`,
            data: JSON.stringify({ disputeId: id }),
          });
          
          // Send push notification
          await sendPushNotification(dispute.helperId, {
            title: "이의제기 답변",
            body: `이의제기에 대한 답변이 등록되었습니다.`,
            data: { type: "dispute_reply", disputeId: String(id) },
          });
          
          // Send SMS notification (알림톡)
          if (helper.phone) {
            try {
              await sendSms(helper.phone, `[헬프미] 이의제기에 대한 답변이 등록되었습니다. 앱에서 확인해주세요.`);
            } catch (smsErr) {
              console.error("SMS send error:", smsErr);
            }
          }
        }
        
        // Audit log
        await db.insert(auditLogs).values({
          actorRole: "ADMIN",
          userId: adminUser?.id,
          action: "DISPUTE_REPLY_ADDED",
          targetType: "dispute",
          targetId: String(id),
          newValue: JSON.stringify({ reply: reply.trim() }),
        });
        
        return res.json({ success: true, dispute: updated });
      }
      
      // Fallback to incident reports (legacy system)
      const incident = await storage.getIncidentReport(id);
      if (!incident) {
        return res.status(404).json({ message: "이의제기를 찾을 수 없습니다" });
      }
      
      // Update incident with reply
      const [updated] = await db.update(incidentReports)
        .set({
          adminMemo: reply.trim(),
        })
        .where(eq(incidentReports.id, id))
        .returning();
      
      // Get requester info for notification
      if (incident.requesterId) {
        const [requester] = await db.select().from(users).where(eq(users.id, incident.requesterId));
        
        if (requester) {
          await storage.createNotification({
            userId: incident.requesterId,
            type: "dispute_reply",
            title: "분쟁 답변",
            message: `분쟁에 대한 답변이 등록되었습니다: ${reply.trim().substring(0, 50)}...`,
            data: JSON.stringify({ incidentId: id }),
          });
          
          // Send push notification
          await sendPushNotification(incident.requesterId, {
            title: "분쟁 답변",
            body: `분쟁에 대한 답변이 등록되었습니다.`,
            data: { type: "dispute_reply", incidentId: String(id) },
          });
          
          // Send SMS notification (알림톡)
          if (requester.phone) {
            try {
              await sendSms(requester.phone, `[헬프미] 분쟁에 대한 답변이 등록되었습니다. 앱에서 확인해주세요.`);
            } catch (smsErr) {
              console.error("SMS send error:", smsErr);
            }
          }
        }
      }
      
      // Audit log
      await db.insert(auditLogs).values({
        actorRole: "ADMIN",
        userId: adminUser?.id,
        action: "DISPUTE_REPLY_ADDED",
        orderId: incident.orderId,
          incidentId: incidentId,
          reasonCategory: "incident",
        incidentId: id,
        targetType: "incident",
        targetId: String(id),
        newValue: JSON.stringify({ reply: reply.trim() }),
      });
      
      // 차감 금액이 있으면 deductions 테이블에 추가
      if (deductionAmount && deductionAmount > 0 && incident.helperId) {
        await db.insert(deductions).values({
          orderId: incident.orderId,
          incidentId: incidentId,
          reasonCategory: "incident",
          incidentId: id,
          requesterId: incident.requesterId,
          targetType: "helper",
          targetId: incident.helperId,
          amount: deductionAmount,
          reason: deductionReason || adminMemo.trim(),
          category: incident.incidentType || "dispute",
          status: "pending",
          createdBy: adminUser?.id,
          memo: adminMemo.trim(),
        });
      }

      res.json({ success: true, incident: updated });
    } catch (err) {
      console.error("Dispute reply error:", err);
      res.status(500).json({ message: "답변 등록에 실패했습니다" });
    }
  });

  // POST /api/admin/disputes/:id/request-evidence - 추가 증빙 요청
  app.post("/api/admin/disputes/:id/request-evidence", adminAuth, requirePermission("disputes.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const adminUser = (req as any).adminUser;
      const { dueHours = 48 } = req.body;
      
      const incident = await storage.getIncidentReport(id);
      if (!incident) {
        return res.status(404).json({ message: "분쟁을 찾을 수 없습니다" });
      }
      
      const dueAt = new Date();
      dueAt.setHours(dueAt.getHours() + dueHours);
      
      // Update incident
      const [updated] = await db.update(incidentReports)
        .set({
          evidenceDueAt: dueAt,
        })
        .where(eq(incidentReports.id, id))
        .returning();
      
      // Audit log
      await db.insert(auditLogs).values({
        actorRole: "ADMIN",
        userId: adminUser?.id,
        action: "EVIDENCE_REQUESTED",
        orderId: incident.orderId,
          incidentId: incidentId,
          reasonCategory: "incident",
        incidentId: id,
        targetType: "incident",
        targetId: String(id),
        reason: `추가 증빙 요청 (${dueHours}시간 내)`,
      });
      
      // TODO: Send notification to reporter
      
      res.json({ success: true, incident: updated, evidenceDueAt: dueAt });
    } catch (err) {
      console.error("Request evidence error:", err);
      res.status(500).json({ message: "증빙 요청에 실패했습니다" });
    }
  });

  // GET /api/admin/orders/:orderId/closing-evidence - 마감 증빙 조회
  app.get("/api/admin/orders/:orderId/closing-evidence", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const orderId = Number(req.params.orderId);
      
      // Get closing report
      const [closingReport] = await db.select()
        .from(closingReports)
        .where(eq(closingReports.orderId, orderId))
        .limit(1);
      
      if (!closingReport) {
        return res.status(404).json({ message: "마감 보고서를 찾을 수 없습니다" });
      }
      
      const deliveryHistoryImages = closingReport.deliveryHistoryImagesJson 
        ? JSON.parse(closingReport.deliveryHistoryImagesJson) 
        : [];
      const etcImages = closingReport.etcImagesJson 
        ? JSON.parse(closingReport.etcImagesJson) 
        : [];
      
      res.json({
        closingReport: {
          id: closingReport.id,
          status: closingReport.status,
          memo: closingReport.memo,
          submittedAt: closingReport.createdAt,
        },
        deliveryHistoryImages,
        etcImages,
        hasDeliveryHistory: deliveryHistoryImages.length > 0,
      });
    } catch (err) {
      console.error("Get closing evidence error:", err);
      res.status(500).json({ message: "마감 증빙 조회에 실패했습니다" });
    }
  });

  // GET /api/admin/orders/:orderId/closing-report - 관리자 마감자료 상세 조회
  app.get("/api/admin/orders/:orderId/closing-report", adminAuth, requirePermission("orders.view"), async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = Number(req.params.orderId);
      
      const [closingReport] = await db.select()
        .from(closingReports)
        .where(eq(closingReports.orderId, orderId))
        .limit(1);
      
      if (!closingReport) {
        return res.status(404).json({ message: "마감 보고서를 찾을 수 없습니다", exists: false });
      }
      
      const helper = closingReport.helperId ? await storage.getUser(closingReport.helperId) : null;
      
      const extraCosts = closingReport.extraCostsJson 
        ? JSON.parse(closingReport.extraCostsJson) 
        : [];
      const deliveryHistoryImages = closingReport.deliveryHistoryImagesJson 
        ? JSON.parse(closingReport.deliveryHistoryImagesJson) 
        : [];
      const etcImages = closingReport.etcImagesJson 
        ? JSON.parse(closingReport.etcImagesJson) 
        : [];
      const dynamicFields = closingReport.dynamicFieldsJson
        ? JSON.parse(closingReport.dynamicFieldsJson)
        : {};
      
      res.json({
        exists: true,
        orderId,
        id: closingReport.id,
        helperName: helper?.name || "알 수 없음",
        status: closingReport.status,
        deliveredCount: closingReport.deliveredCount,
        returnedCount: closingReport.returnedCount,
        etcCount: closingReport.etcCount || 0,
        etcPricePerUnit: closingReport.etcPricePerUnit || 0,
        extraCosts,
        deliveryHistoryImages,
        etcImages,
        dynamicFields,
        memo: closingReport.memo,
        calculatedAmount: closingReport.calculatedAmount,
        submittedAt: closingReport.createdAt ? new Date(closingReport.createdAt).toISOString() : null,
        reviewedAt: closingReport.reviewedAt ? new Date(closingReport.reviewedAt).toISOString() : null,
        reviewedBy: closingReport.reviewedBy,
        rejectReason: closingReport.rejectReason,
      });
    } catch (err) {
      console.error("Admin get closing report error:", err);
      res.status(500).json({ message: "마감자료 조회에 실패했습니다" });
    }
  });

  // POST /api/admin/orders/:orderId/closing/approve - 관리자 마감 승인 (정산 자동화 + settlement_records 생성)
  app.post("/api/admin/orders/:orderId/closing/approve", adminAuth, requirePermission("settlements.approve"), async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = Number(req.params.orderId);
      const adminUser = req.user!;
      const { adjustedAmount, reason, damageDeduction = 0, damageReason } = req.body;

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      if (order.status !== "closing_submitted") {
        return res.status(400).json({ message: `현재 상태(${order.status})에서는 마감 승인을 할 수 없습니다` });
      }

      const [closingReport] = await db.select()
        .from(closingReports)
        .where(eq(closingReports.orderId, orderId))
        .limit(1);

      if (!closingReport) {
        return res.status(404).json({ message: "마감 보고서를 찾을 수 없습니다" });
      }

      // 마감자료 기반 정산 계산 (헬퍼/요청자와 동일한 계산식)
      // 통합 계산 모듈 사용 (Single Source of Truth)
      // ✅ 단가: 최저운임 적용된 finalPricePerBox 우선, 없으면 pricePerUnit
      const unitPrice = Number(order.finalPricePerBox ?? order.pricePerUnit ?? 0);
      
      const closingData = parseClosingReport(closingReport, { pricePerUnit: unitPrice });
      const settlement = calculateSettlement(closingData);
      
      const totalBoxCount = settlement.totalBillableCount;
      const etcCount = settlement.etcCount;
      const etcAmount = settlement.etcAmount;
      const extraCostsTotal = settlement.extraCostsTotal;
      const supplyTotal = settlement.supplyAmount;
      const vat = settlement.vatAmount;
      
      // 정답 금액: adjustedAmount가 있으면 그 값, 없으면 계산값
      const finalTotal = adjustedAmount !== undefined ? Number(adjustedAmount) : settlement.totalAmount;
      
      // 계약 정보 조회 (snapshotCommissionRate 사용)
      const orderContracts = await storage.getOrderContracts(orderId);
      const contract = orderContracts.find(c => c.helperId === closingReport.helperId);
      
      // 계약/지원 시점 스냅샷 수수료율 사용 (없으면 기본 10%)
      const application = await db.select().from(orderApplications)
        .where(and(
          eq(orderApplications.orderId, orderId),
          eq(orderApplications.helperId, closingReport.helperId)
        ))
        .limit(1);
      const platformFeeRate = application[0]?.snapshotCommissionRate ?? order.snapshotCommissionRate ?? 3;
      const platformFee = Math.round(finalTotal * (platformFeeRate / 100));
      
      // 헬퍼 지급액 = 최종금액 - 플랫폼수수료 - 화물사고차감
      const driverPayout = finalTotal - platformFee - (Number(damageDeduction) || 0);

      const downPaymentAmount = contract?.depositAmount || contract?.downPaymentAmount || 0;
      const balanceAmount = Math.max(0, finalTotal - downPaymentAmount);

      // 1. closing_reports 업데이트 (calculatedAmount = 정답 금액)
      await db.update(closingReports)
        .set({ 
          status: "approved", 
          calculatedAmount: finalTotal,
          reviewedAt: new Date(),
          reviewedBy: adminUser.id,
        })
        .where(eq(closingReports.id, closingReport.id));

      // 2. 오더 상태 업데이트
      await storage.updateOrder(orderId, { status: "final_amount_confirmed" });

      // 3. 계약 업데이트
      if (contract) {
        await storage.updateContract(contract.id, {
          finalAmount: finalTotal,
          calculatedBalanceAmount: balanceAmount,
        });
      }

      // 4. settlement_records 생성/업데이트 (Single Source of Truth)
      const existingSettlement = await db.select()
        .from(settlementRecords)
        .where(eq(settlementRecords.orderId, orderId))
        .limit(1);

      if (existingSettlement.length === 0) {
        await db.insert(settlementRecords).values({
          orderId,
          closingReportId: closingReport.id,
          contractId: contract?.id ?? null,
          baseSupply: totalBoxCount * unitPrice,
          urgentFeeSupply: 0,
          extraSupply: extraCostsTotal,
          finalSupply: supplyTotal,
          vat,
          finalTotal,
          platformFeeBaseOn: "TOTAL",
          platformFeeRate,
          platformFee,
          damageDeduction: Number(damageDeduction) || 0,
          damageReason: damageReason || null,
          driverPayout,
          status: "APPROVED",
          approvedBy: adminUser.id,
          approvedAt: new Date(),
        });
      } else {
        await db.update(settlementRecords)
          .set({
            finalTotal,
            platformFee,
            damageDeduction: Number(damageDeduction) || 0,
            damageReason: damageReason || null,
            driverPayout,
            status: "APPROVED",
            approvedBy: adminUser.id,
            approvedAt: new Date(),
          })
          .where(eq(settlementRecords.orderId, orderId));
      }

      // 5. 감사 로그
      await db.insert(auditLogs).values({
        actorRole: "ADMIN",
        userId: adminUser.id,
        action: "CLOSING_APPROVED",
        orderId,
        targetType: "closing_report",
        targetId: String(closingReport.id),
        reason: reason || `마감 승인 (청구금액: ${finalTotal.toLocaleString()}원, 헬퍼지급: ${driverPayout.toLocaleString()}원)`,
      });

      // 6. 요청자 알림
      if (order.requesterId) {
        await storage.createNotification({
          userId: order.requesterId,
          type: "closing_approved",
          title: "마감 승인",
          message: `오더 마감이 승인되었습니다. 잔금 ${balanceAmount.toLocaleString()}원을 결제해주세요.`,
          relatedId: orderId,
        });
      }

      res.json({
        success: true,
        closingReportId: closingReport.id,
        finalTotal,
        platformFee,
        damageDeduction: Number(damageDeduction) || 0,
        driverPayout,
        balanceAmount,
        status: "approved",
      });
    } catch (err) {
      console.error("Approve closing error:", err);
      res.status(500).json({ message: "마감 승인에 실패했습니다" });
    }
  });

  // POST /api/admin/orders/:orderId/settlement/execute - 정산 실행 (플랫폼 수수료 차감 후 기사 지급액 산출)
  app.post("/api/admin/orders/:orderId/settlement/execute", adminAuth, requirePermission("settlements.manage"), async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = Number(req.params.orderId);
      const adminUser = req.user!;

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      if (order.status !== "balance_paid") {
        return res.status(400).json({ message: `현재 상태(${order.status})에서는 정산을 실행할 수 없습니다. 잔금 결제 완료(balance_paid) 후 진행해주세요.` });
      }

      const [closingReport] = await db.select()
        .from(closingReports)
        .where(eq(closingReports.orderId, orderId))
        .limit(1);

      if (!closingReport) {
        return res.status(404).json({ message: "마감 보고서를 찾을 수 없습니다" });
      }

      const contracts = await storage.getOrderContracts(orderId);
      const contract = contracts.find(c => c.helperId === closingReport.helperId);

      // SSOT: 마감 시점 스냅샷이 있으면 우선 사용, 없으면 재계산
      let amounts: {
        baseSupply: number;
        urgentFeeSupply: number;
        extraSupply: number;
        finalSupply: number;
        vat: number;
        finalTotal: number;
        platformFee: number;
        driverPayout: number;
      };
      let policy: { platformBaseOn: "TOTAL" | "SUPPLY"; platformRatePercent: number };
      
      if (closingReport.supplyAmount && closingReport.totalAmount && closingReport.netAmount) {
        // 스냅샷 값 사용 (SSOT)
        console.log(`[Settlement Execute] Using snapshot values for order ${orderId}`);
        amounts = {
          baseSupply: closingReport.supplyAmount,
          urgentFeeSupply: 0,
          extraSupply: 0,
          finalSupply: closingReport.supplyAmount,
          vat: closingReport.vatAmount || 0,
          finalTotal: closingReport.totalAmount,
          platformFee: closingReport.platformFee || 0,
          driverPayout: closingReport.netAmount,
        };
        policy = {
          platformBaseOn: "SUPPLY",
          platformRatePercent: (closingReport.platformFeeRate || 300) / 100, // bps to percent
        };
      } else {
        // 스냅샷 없음 - 기존 방식으로 재계산 (레거시 호환)
        console.log(`[Settlement Execute] No snapshot, recalculating for order ${orderId}`);
        const { calculateAndSaveSettlement, getPolicySnapshotForOrder, calculateSettlementAmounts } = await import("./utils/settlement-calculator");
        
        const snapshot = await getPolicySnapshotForOrder(orderId);
        const extraCosts = closingReport.extraCostsJson ? JSON.parse(closingReport.extraCostsJson) : [];
        const extraCostItems = extraCosts.map((cost: any) => ({
          costCode: cost.costCode || "CUSTOM",
          qty: cost.qty || 1,
          unitPriceSupply: cost.amount || cost.unitPriceSupply || 0,
          memo: cost.memo,
        }));
        
        policy = {
          platformBaseOn: (snapshot?.platformFee?.baseOn as "TOTAL" | "SUPPLY") || "TOTAL",
          platformRatePercent: snapshot?.platformFee?.ratePercent || 10,
        };
        const fullPolicy = {
          unitPriceSupply: snapshot?.carrierPricing?.unitPriceSupply || order.pricePerUnit || 0,
          minChargeSupply: snapshot?.carrierPricing?.minChargeSupply,
          urgentApplyType: snapshot?.urgentFee?.applyType,
          urgentValue: snapshot?.urgentFee?.value,
          urgentMaxFee: snapshot?.urgentFee?.maxUrgentFeeSupply,
          platformBaseOn: policy.platformBaseOn,
          platformRatePercent: policy.platformRatePercent,
          platformMinFee: snapshot?.platformFee?.minFee,
          platformMaxFee: snapshot?.platformFee?.maxFee,
        };
        
        amounts = calculateSettlementAmounts({
          deliveredCount: closingReport.deliveredCount || 0,
          returnedCount: closingReport.returnedCount || 0,
          otherCount: 0,
          extraCostItems,
          isUrgent: order.isUrgent ?? false,
        }, fullPolicy);
      }
      
      // 중복 방지: 기존 settlement_records 있으면 업데이트, 없으면 생성
      const existingRecord = await db.select()
        .from(settlementRecords)
        .where(eq(settlementRecords.orderId, orderId))
        .limit(1);
      
      let record;
      if (existingRecord.length > 0) {
        // 기존 레코드 업데이트
        const [updated] = await db.update(settlementRecords)
          .set({
            baseSupply: amounts.baseSupply,
            urgentFeeSupply: amounts.urgentFeeSupply,
            extraSupply: amounts.extraSupply,
            finalSupply: amounts.finalSupply,
            vat: amounts.vat,
            finalTotal: amounts.finalTotal,
            platformFeeBaseOn: policy.platformBaseOn,
            platformFeeRate: policy.platformRatePercent,
            platformFee: amounts.platformFee,
            driverPayout: amounts.driverPayout,
            status: "APPROVED",
            updatedAt: new Date(),
          })
          .where(eq(settlementRecords.orderId, orderId))
          .returning();
        record = updated;
        console.log(`[Settlement Execute] Updated existing record for order ${orderId}`);
      } else {
        // 새 레코드 생성
        const [created] = await db.insert(settlementRecords).values({
          orderId,
          closingReportId: closingReport.id,
          contractId: contract?.id ?? null,
          baseSupply: amounts.baseSupply,
          urgentFeeSupply: amounts.urgentFeeSupply,
          extraSupply: amounts.extraSupply,
          finalSupply: amounts.finalSupply,
          vat: amounts.vat,
          finalTotal: amounts.finalTotal,
          platformFeeBaseOn: policy.platformBaseOn,
          platformFeeRate: policy.platformRatePercent,
          platformFee: amounts.platformFee,
          driverPayout: amounts.driverPayout,
          status: "APPROVED",
        }).returning();
        record = created;
      }
      
      await db.insert(settlementAuditLogs).values({
        settlementId: record.id,
        actionType: "approved",
        newValue: JSON.stringify({ status: "APPROVED", amounts }),
        changedFields: JSON.stringify(amounts.breakdown),
        reason: "정산 실행 승인",
        actorId: adminUser.id,
        actorRole: "admin",
      });

      await storage.updateOrder(orderId, { status: "settlement_paid" });
      
      if (closingReport.helperId) {
        await storage.createNotification({
          type: "settlement_complete",
          title: "정산 완료",
          message: `정산이 완료되었습니다. 지급액: ${amounts.driverPayout.toLocaleString()}원`,
          relatedId: orderId,
        });
      }

      res.json({
        success: true,
        settlement: {
          id: record.id,
          baseSupply: amounts.baseSupply,
          urgentFeeSupply: amounts.urgentFeeSupply,
          extraSupply: amounts.extraSupply,
          finalSupply: amounts.finalSupply,
          vat: amounts.vat,
          finalTotal: amounts.finalTotal,
          platformFee: amounts.platformFee,
          driverPayout: amounts.driverPayout,
          status: "APPROVED",
        },
        breakdown: amounts.breakdown,
      });
    } catch (err) {
      console.error("Execute settlement error:", err);
      res.status(500).json({ message: "정산 실행에 실패했습니다" });
    }
  });

  // GET /api/admin/orders/:orderId/evidence - 종합 증빙 조회 (관리자 탭용)
  app.get("/api/admin/orders/:orderId/evidence", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const orderId = Number(req.params.orderId);

      // Get closing report
      const [closingReport] = await db.select()
        .from(closingReports)
        .where(eq(closingReports.orderId, orderId))
        .limit(1);

      const deliveryHistoryImages = closingReport?.deliveryHistoryImagesJson 
        ? JSON.parse(closingReport.deliveryHistoryImagesJson) 
        : [];
      const etcImages = closingReport?.etcImagesJson 
        ? JSON.parse(closingReport.etcImagesJson) 
        : [];
      const closingMemo = closingReport?.memo || '';

      // Get QR events
      const qrEvents = await db.select({
        type: qrVerifications.status,
        timestamp: qrVerifications.verifiedAt,
      })
        .from(qrVerifications)
        .where(eq(qrVerifications.orderId, orderId))
        .orderBy(qrVerifications.verifiedAt);

      // Get helper names for QR events
      const qrEventsWithNames = await Promise.all(qrEvents.map(async (event) => {
        if (!event.helperId) return { ...event, helperName: '알 수 없음' };
        const helper = await storage.getUser(event.helperId);
        return {
          type: event.type === 'used' ? 'start' : event.type,
          timestamp: event.timestamp?.toISOString() || '',
          helperName: helper?.name || '알 수 없음',
        };
      }));

      // Get incident reports with evidence
      const incidents = await storage.getIncidentReportsByOrder(orderId);
      const incidentEvidence = incidents.flatMap(incident => {
        const evidence = [];
        if (incident.attachedImagesJson) {
          const images = JSON.parse(incident.attachedImagesJson);
          images.forEach((img: string, idx: number) => {
            evidence.push({
              id: incident.id * 100 + idx,
              type: incident.type,
              imageUrl: img,
              uploadedAt: incident.createdAt?.toISOString() || '',
            });
          });
        }
        return evidence;
      });

      res.json({
        deliveryHistoryImages,
        etcImages,
        closingMemo,
        qrEvents: qrEventsWithNames,
        incidentEvidence,
      });
    } catch (err) {
      console.error("Get order evidence error:", err);
      res.status(500).json({ message: "증빙 조회에 실패했습니다" });
    }
  });

  // POST /api/admin/settlements/:id/confirm - 정산 확정 (증빙 검증 필수)
  app.post("/api/admin/settlements/:id/confirm", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const adminUser = (req as any).adminUser;
      const { adminMemo } = req.body;
      
      // Idempotency check
      const idempotencyKey = getIdempotencyKeyFromRequest(req);
      if (idempotencyKey) {
        const { isDuplicate, isConflict, cachedResponse } = await checkIdempotency(
          adminUser?.id || "admin",
          `POST:/api/admin/settlements/${id}/confirm`,
          idempotencyKey,
          req.body
        );
        if (isConflict) {
          return res.status(409).json({
            error: { code: "IDEMPOTENCY_CONFLICT", message: "동일 Idempotency-Key에 다른 요청이 감지되었습니다." }
          });
        }
        if (isDuplicate && cachedResponse) {
          console.log(`[Idempotency] Returning cached settlement confirm for ${id}, key: ${idempotencyKey}`);
          return res.status(cachedResponse.status).json(cachedResponse.body);
        }
      }
      
      // Get settlement
      const settlement = await storage.getSettlementStatement(id);
      if (!settlement) {
        return res.status(404).json({ message: "정산을 찾을 수 없습니다" });
      }
      
      // Get order
      const order = await storage.getOrder(settlement.orderId!);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }
      
      // Check closing report has delivery history images (MANDATORY)
      const [closingReport] = await db.select()
        .from(closingReports)
        .where(eq(closingReports.orderId, settlement.orderId!))
        .limit(1);
      
      const deliveryHistoryImages = closingReport?.deliveryHistoryImagesJson 
        ? JSON.parse(closingReport.deliveryHistoryImagesJson) 
        : [];
      
      if (deliveryHistoryImages.length === 0) {
        return res.status(400).json({ 
          code: "MISSING_EVIDENCE",
          message: "집배송 이력 이미지가 없어 정산을 확정할 수 없습니다. 헬퍼에게 증빙 제출을 요청해주세요.",
        });
      }
      
      // Check if there are unresolved disputes
      const incidents = await storage.getIncidentReportsByOrder(settlement.orderId!);
      const unresolvedDisputes = incidents.filter(i => 
        i.status === "requested" || i.status === "submitted" || i.status === "reviewing"
      );
      
      if (unresolvedDisputes.length > 0) {
        return res.status(400).json({
          code: "UNRESOLVED_DISPUTES",
          message: `미해결 분쟁이 ${unresolvedDisputes.length}건 있습니다. 분쟁 해결 후 정산을 확정해주세요.`,
          disputes: unresolvedDisputes.map(d => ({ id: d.id, status: d.status, type: d.type })),
        });
      }
      
      // Update settlement status
      await db.update(settlementStatements)
        .set({
          status: "confirmed",
          confirmedAt: new Date(),
          confirmedBy: adminUser?.id,
        })
        .where(eq(settlementStatements.id, id));
      
      // Update order status to SETTLED
      await db.update(orders)
        .set({ status: "settled" })
        .where(eq(orders.id, settlement.orderId!));
      
      // Audit log
      await db.insert(auditLogs).values({
        actorRole: "ADMIN",
        userId: adminUser?.id,
        action: "SETTLEMENT_CONFIRMED",
        orderId: settlement.orderId,
        settlementId: id,
        targetType: "settlement",
        targetId: String(id),
        reason: adminMemo || "정산 확정",
        oldValue: JSON.stringify({ status: settlement.status }),
        newValue: JSON.stringify({ status: "confirmed" }),
      });
      
      const confirmResponse = { 
        success: true, 
        message: "정산이 확정되었습니다",
        settlementId: id,
        orderStatus: "settled",
      };
      
      // Store idempotency response
      if (idempotencyKey) {
        await storeIdempotencyResponse(adminUser?.id || "admin", `POST:/api/admin/settlements/${id}/confirm`, idempotencyKey, 200, confirmResponse, req.body);
      }
      
      res.json(confirmResponse);
    } catch (err) {
      console.error("Confirm settlement error:", err);
      res.status(500).json({ message: "정산 확정에 실패했습니다" });
    }
  });

  // GET /api/admin/settlements/:id/validation - 정산 확정 조건 검증
  app.get("/api/admin/settlements/:id/validation", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      
      const settlement = await storage.getSettlementStatement(id);
      if (!settlement) {
        return res.status(404).json({ message: "정산을 찾을 수 없습니다" });
      }
      
      const order = await storage.getOrder(settlement.orderId!);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }
      
      // Check closing report
      const [closingReport] = await db.select()
        .from(closingReports)
        .where(eq(closingReports.orderId, settlement.orderId!))
        .limit(1);
      
      const deliveryHistoryImages = closingReport?.deliveryHistoryImagesJson 
        ? JSON.parse(closingReport.deliveryHistoryImagesJson) 
        : [];
      
      // Check disputes
      const incidents = await storage.getIncidentReportsByOrder(settlement.orderId!);
      const unresolvedDisputes = incidents.filter(i => 
        i.status === "requested" || i.status === "submitted" || i.status === "reviewing"
      );
      
      const canConfirm = deliveryHistoryImages.length > 0 && unresolvedDisputes.length === 0;
      
      res.json({
        settlementId: id,
        orderId: settlement.orderId,
        canConfirm,
        validations: {
          hasDeliveryHistoryImages: deliveryHistoryImages.length > 0,
          deliveryHistoryImageCount: deliveryHistoryImages.length,
          hasUnresolvedDisputes: unresolvedDisputes.length > 0,
          unresolvedDisputeCount: unresolvedDisputes.length,
          unresolvedDisputes: unresolvedDisputes.map(d => ({ id: d.id, status: d.status, type: d.type })),
        },
        closingReport: closingReport ? {
          id: closingReport.id,
          status: closingReport.status,
          submittedAt: closingReport.createdAt,
        } : null,
      });
    } catch (err) {
      console.error("Validate settlement error:", err);
      res.status(500).json({ message: "정산 검증에 실패했습니다" });
    }
  });

  // Get all client errors (admin)
  app.get("/api/admin/client-errors", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const { severity, isResolved, limit } = req.query;
      const parsedLimit = limit ? Math.min(Math.max(parseInt(limit as string) || 100, 1), 500) : 100;
      const errors = await storage.getAllClientErrors({
        severity: severity as string | undefined,
        isResolved: isResolved === 'true' ? true : isResolved === 'false' ? false : undefined,
        limit: parsedLimit,
      });
      res.json(errors);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Resolve client error (admin)
  app.patch("/api/admin/client-errors/:id/resolve", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const user = (req as any).user;
      
      const error = await storage.getClientError(id);
      if (!error) {
        return res.status(404).json({ message: "에러를 찾을 수 없습니다" });
      }
      
      const updated = await storage.updateClientError(id, {
        isResolved: true,
        resolvedBy: user.id,
      });
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });


  // Daily settlement list (일일 정산 목록)
  app.get("/api/admin/settlements/daily", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const { startDate, endDate } = req.query;
      
      const closingReportsList = await db.select().from(closingReports)
        .where(
          startDate && endDate
            ? and(
                gte(closingReports.createdAt, new Date(startDate as string)),
                lte(closingReports.createdAt, new Date(endDate as string + "T23:59:59"))
              )
            : undefined
        )
        .orderBy(desc(closingReports.createdAt));
      
      const users = await storage.getAllUsers();
      const orders = await storage.getOrders();
      const userMap = new Map(users.map(u => [u.id, u]));
      const orderMap = new Map(orders.map(o => [o.id, o]));
      
      const result = closingReportsList.map(cr => {
        const order = orderMap.get(cr.orderId);
        const helper = order?.matchedHelperId ? userMap.get(order.matchedHelperId) : null;
        const requester = order?.requesterId ? userMap.get(order.requesterId) : null;
        
        const deliveredCount = cr.deliveredCount || 0;
        const returnedCount = cr.returnedCount || 0;
        const etcCount = cr.etcCount || 0;
        const pricePerBox = order?.pricePerUnit || 0;
        
        const extraCostsJson = cr.extraCostsJson ? (typeof cr.extraCostsJson === "string" ? JSON.parse(cr.extraCostsJson) : cr.extraCostsJson) : null;
        const extraTotal = extraCostsJson?.reduce((sum: number, item: any) => sum + (item.amount || item.unitPrice * item.quantity || 0), 0) || 0;
        
        // 스냅샷 값이 있으면 사용 (월간 정산과 동일)
        let supplyPrice, vat, finalTotal, platformFee, driverPayout;
        if (cr.supplyAmount) {
          supplyPrice = Number(cr.supplyAmount) || 0;
          vat = Number(cr.vatAmount) || 0;
          finalTotal = Number(cr.totalAmount) || 0;
          platformFee = Number(cr.platformFee) || 0;
          driverPayout = Number(cr.netAmount) || 0;
        } else {
          const baseAmount = (deliveredCount + returnedCount) * pricePerBox;
          supplyPrice = baseAmount + extraTotal;
          vat = Math.round(supplyPrice * 0.1);
          finalTotal = supplyPrice + vat;
          // 운임설정에서 설정된 수수료만 사용 (설정 없으면 0)
          const platformFeeRate = cr.platformFeeRate ? Number(cr.platformFeeRate) / 10000 : 0;
          platformFee = Math.round(finalTotal * platformFeeRate);
          driverPayout = finalTotal - platformFee;
        }
        
        return {
          id: cr.id,
          orderId: cr.orderId,
          helperId: order?.matchedHelperId || 0,
          helperName: helper?.name || "Unknown",
          helperPhone: helper?.phoneNumber || null,
          requesterName: requester?.name || null,
          category: "parcel",
          courierCompany: order?.courierCompany || order?.companyName || null,
          deliveredCount,
          returnedCount,
          etcCount,
          etcPricePerUnit: cr.etcPricePerUnit || 0,
          extraCostsJson,
          closingMemo: cr.memo || "",
          createdAt: cr.createdAt,
          pricePerBox,
          driverPayout,
          platformFee,
          finalTotal,
        };
      });
      
      res.json(result);
    } catch (err) {
      console.error("Daily settlement error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper monthly settlement (헬퍼별 월간 정산)
  app.get("/api/admin/settlements/helper", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const { startDate, endDate } = req.query;
      
      // closingReports 테이블에서 마감 데이터 조회
      const closingReportsList = await db.select().from(closingReports)
        .where(
          startDate && endDate
            ? and(
                gte(closingReports.createdAt, new Date(startDate as string)),
                lte(closingReports.createdAt, new Date(endDate as string + "T23:59:59"))
              )
            : undefined
        );
      
      const users = await storage.getAllUsers();
      const orders = await storage.getOrders();
      const userMap = new Map(users.map(u => [u.id, u]));
      const orderMap = new Map(orders.map(o => [o.id, o]));
      
      const helperMap = new Map<string | number, any>();
      
      for (const cr of closingReportsList) {
        const order = orderMap.get(cr.orderId);
        const helperId = cr.helperId || order?.matchedHelperId;
        if (!helperId) continue;
        
        const existing = helperMap.get(helperId) || {
          helperName: "",
          helperPhone: "",
          orderCount: 0,
          supplyPrice: 0,
          vat: 0,
          totalAmount: 0,
          platformFee: 0,
          deductedAmount: 0,
          deductions: 0,
          cargoIncident: 0,
          driverPayout: 0,
        };
        
        const helper = userMap.get(helperId);
        existing.helperName = helper?.name || "Unknown";
        existing.helperPhone = helper?.phoneNumber || "";
        existing.orderCount += 1;
        
        // 정산 스냅샷이 있으면 사용, 없으면 일정산과 동일한 방식으로 계산
        if (cr.supplyAmount) {
          existing.supplyPrice += Number(cr.supplyAmount) || 0;
          existing.vat += Number(cr.vatAmount) || 0;
          existing.totalAmount += Number(cr.totalAmount) || 0;
          existing.platformFee += Number(cr.platformFee) || 0;
          existing.driverPayout += Number(cr.netAmount) || 0;
        } else {
          // 일정산과 동일한 계산 방식 적용
          const deliveredCount = cr.deliveredCount || 0;
          const returnedCount = cr.returnedCount || 0;
          const pricePerBox = order?.pricePerUnit || 0;
          
          // extraCosts 계산
          const extraCostsJson = cr.extraCostsJson ? (typeof cr.extraCostsJson === "string" ? JSON.parse(cr.extraCostsJson) : cr.extraCostsJson) : null;
          const extraTotal = extraCostsJson?.reduce((sum: number, item: any) => sum + (item.amount || item.unitPrice * item.quantity || 0), 0) || 0;
          
          const baseAmount = (deliveredCount + returnedCount) * pricePerBox;
          const supplyPrice = baseAmount + extraTotal;
          const vat = Math.round(supplyPrice * 0.1);
          const totalAmount = supplyPrice + vat;
          // 운임설정에서 설정된 수수료만 사용 (설정 없으면 0)
          const platformFeeRate = cr.platformFeeRate ? Number(cr.platformFeeRate) / 10000 : 0;
          const platformFee = Math.round(totalAmount * platformFeeRate);
          const driverPayout = totalAmount - platformFee;
          
          existing.supplyPrice += supplyPrice;
          existing.vat += vat;
          existing.totalAmount += totalAmount;
          existing.platformFee += platformFee;
          existing.driverPayout += driverPayout;
        }
        
        helperMap.set(helperId, existing);
      }
      
      res.json(Array.from(helperMap.values()));
    } catch (err) {
      console.error("Helper settlement error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 헬퍼별 상세 이용내역 API (거래명세서 스타일)
  app.get("/api/admin/settlements/helper/:helperId/orders", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const helperId = req.params.helperId;
      const { startDate, endDate } = req.query;
      
      const closingReportsList = await db.select().from(closingReports)
        .where(
          and(
            eq(closingReports.helperId, helperId),
            startDate && endDate
              ? and(
                  gte(closingReports.createdAt, new Date(startDate as string)),
                  lte(closingReports.createdAt, new Date(endDate as string + "T23:59:59"))
                )
              : undefined
          )
        )
        .orderBy(desc(closingReports.createdAt));
      
      const orders = await storage.getOrders();
      const orderMap = new Map(orders.map(o => [o.id, o]));
      const allCourierSettings = await storage.getAllCourierSettings();
      
      let totalSupply = 0, totalVat = 0, totalAmount = 0, totalDeduction = 0, totalPayout = 0;
      
      const orderDetails = closingReportsList.map(cr => {
        const order = orderMap.get(cr.orderId);
        const deliveredCount = cr.deliveredCount || 0;
        const returnedCount = cr.returnedCount || 0;
        const etcCount = cr.etcCount || 0;
        const pricePerBox = order?.pricePerUnit || 0;
        const etcPricePerUnit = cr.etcPricePerUnit || 0;
        
        // 카테고리 결정
        const courierSetting = allCourierSettings.find(c => c.courierName === order?.companyName);
        let category = "택배";
        if (courierSetting?.category === "freight") category = "냉탑전용";
        else if (courierSetting?.category === "etc") category = "기타택배";
        
        // 금액 계산 (스냅샷 우선)
        let supplyAmount, vatAmount, total, platformFee, netAmount;
        if (cr.supplyAmount) {
          supplyAmount = Number(cr.supplyAmount) || 0;
          vatAmount = Number(cr.vatAmount) || 0;
          total = Number(cr.totalAmount) || 0;
          platformFee = Number(cr.platformFee) || 0;
          netAmount = Number(cr.netAmount) || 0;
        } else {
          const baseAmount = (deliveredCount + returnedCount) * pricePerBox + etcCount * etcPricePerUnit;
          supplyAmount = baseAmount;
          vatAmount = Math.round(baseAmount * 0.1);
          total = supplyAmount + vatAmount;
          const feeRate = cr.platformFeeRate ? Number(cr.platformFeeRate) / 10000 : 0;
          platformFee = Math.round(total * feeRate);
          netAmount = total - platformFee;
        }
        
        totalSupply += supplyAmount;
        totalVat += vatAmount;
        totalAmount += total;
        totalDeduction += platformFee;
        totalPayout += netAmount;
        
        // 차감 상세 내역
        const deductionDetails: string[] = [];
        if (platformFee > 0) {
          const feeRate = cr.platformFeeRate ? Number(cr.platformFeeRate) / 100 : 0;
          deductionDetails.push(`플랫폼 수수료 ${feeRate}%: ${platformFee.toLocaleString()}원`);
        }
        
        return {
          orderId: cr.orderId,
          date: cr.createdAt,
          category,
          courierCompany: order?.companyName || order?.courierCompany || "-",
          deliveredCount,
          returnedCount,
          pricePerBox,
          etcCount,
          etcPricePerUnit,
          supplyAmount,
          vatAmount,
          totalAmount: total,
          deduction: platformFee,
          payout: netAmount,
          deductionDetails,
          memo: cr.memo || "",
        };
      });
      
      res.json({
        orders: orderDetails,
        summary: {
          totalSupply,
          totalVat,
          totalAmount,
          totalDeduction,
          totalPayout,
        }
      });
    } catch (err) {
      console.error("Helper orders detail error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 요청자별 상세 이용내역 API
  app.get("/api/admin/settlements/requester/:requesterId/orders", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const requesterId = req.params.requesterId;
      const { startDate, endDate } = req.query;
      
      const ordersData = await storage.getOrders();
      const closingReportsList = await db.select().from(closingReports);
      const closingMap = new Map(closingReportsList.map(cr => [cr.orderId, cr]));
      
      const requesterOrders = ordersData.filter(o => {
        if (o.requesterId !== requesterId) return false;
        if (!startDate || !endDate) return true;
        const orderDate = new Date(o.createdAt);
        return orderDate >= new Date(startDate as string) && orderDate <= new Date(endDate as string + "T23:59:59");
      });
      
      const result = await Promise.all(requesterOrders.map(async order => {
        const closing = closingMap.get(order.id);
        const deliveredCount = closing?.deliveredCount || 0;
        const returnedCount = closing?.returnedCount || 0;
        const etcCount = closing?.etcCount || 0;
        const pricePerBox = order.pricePerUnit || 0;
        const etcPricePerUnit = closing?.etcPricePerUnit || 0;
        
        let totalAmount = 0;
        if (closing?.totalAmount) {
          totalAmount = Number(closing.totalAmount) || 0;
        } else if (closing) {
          const baseAmount = (deliveredCount + returnedCount) * pricePerBox + etcCount * etcPricePerUnit;
          totalAmount = Math.round(baseAmount * 1.1);
        }
        
        // 계약금 정보 조회
        const depositInfo = await getOrderDepositInfo(order.id);
        const depositAmount = depositInfo.paymentStatus === 'paid' ? depositInfo.depositAmount : 0;
        const balanceAmount = Math.max(0, totalAmount - depositAmount);
        
        return {
          orderId: order.id,
          orderDate: order.scheduledDate || order.createdAt,
          courierCompany: order.courierCompany || order.companyName || '-',
          deliveredCount,
          returnedCount,
          etcCount,
          pricePerBox,
          totalAmount,
          depositAmount,
          balanceAmount,
          depositPaid: depositInfo.paymentStatus === 'paid',
          status: order.status,
          paymentStatus: order.paymentStatus,
        };
      }));
      
      // 총합계 정보 추가
      const summary = {
        totalAmount: result.reduce((sum, o) => sum + o.totalAmount, 0),
        totalDeposit: result.reduce((sum, o) => sum + o.depositAmount, 0),
        totalBalance: result.reduce((sum, o) => sum + o.balanceAmount, 0),
      };
      
      res.json({ orders: result, summary });
    } catch (err) {
      console.error("Requester orders error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

    // Requester monthly settlement (요청자별 월간 정산)
  app.get("/api/admin/settlements/requester", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const { startDate, endDate } = req.query;
      
      const ordersData = await storage.getOrders();
      const users = await storage.getAllUsers();
      const userMap = new Map(users.map(u => [u.id, u]));
      
      // closing_reports에서 정산 금액 조회
      const closingReportsList = await db.select().from(closingReports);
      const closingMap = new Map(closingReportsList.map(cr => [cr.orderId, cr]));
      
      const filteredOrders = ordersData.filter(o => {
        if (!startDate || !endDate) return true;
        const orderDate = new Date(o.createdAt);
        return orderDate >= new Date(startDate as string) && orderDate <= new Date(endDate as string + "T23:59:59");
      });
      
      const requesterMap = new Map<string | number, any>();
      
      for (const order of filteredOrders) {
        const requesterId = order.requesterId;
        if (!requesterId) continue;
        
        const existing = requesterMap.get(requesterId) || {
          requesterId: requesterId.toString(),
          requesterName: "",
          requesterPhone: "",
          businessName: "",
          orderCount: 0,
          billedAmount: 0,
          unpaidAmount: 0,
          paymentDate: null,
        };
        
        const requester = userMap.get(requesterId);
        existing.requesterName = requester?.name || "Unknown";
        existing.requesterPhone = requester?.phoneNumber || "";
        existing.businessName = order.companyName || "";
        existing.orderCount += 1;
        
        // closing_reports에서 정산 금액 가져오기
        const closingReport = closingMap.get(order.id);
        let totalAmount = 0;
        if (closingReport) {
          if (closingReport.totalAmount) {
            totalAmount = Number(closingReport.totalAmount) || 0;
          } else {
            const deliveredCount = closingReport.deliveredCount || 0;
            const returnedCount = closingReport.returnedCount || 0;
            const etcCount = closingReport.etcCount || 0;
            const pricePerBox = order.pricePerUnit || 0;
            const etcPricePerUnit = closingReport.etcPricePerUnit || 0;
            const baseAmount = (deliveredCount + returnedCount) * pricePerBox + etcCount * etcPricePerUnit;
            totalAmount = Math.round(baseAmount * 1.1);
          }
        }
        
        existing.billedAmount += totalAmount;
        
        // 미정산: 잔금 = 총액 - 계약금
        const depositInfo = await getOrderDepositInfo(order.id);
        const depositPaid = depositInfo.paymentStatus === 'paid' ? depositInfo.depositAmount : 0;
        const balanceAmount = Math.max(0, totalAmount - depositPaid);
        
        if (order.status !== "closed" && order.status !== "completed" && order.status !== "balance_paid" && order.status !== "settlement_paid") {
          existing.unpaidAmount += balanceAmount;
        }
        
        requesterMap.set(requesterId, existing);
      }
      
      res.json(Array.from(requesterMap.values()));
    } catch (err) {
      console.error("Requester settlement error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get all settlements (admin) - settlementRecords 기반

  app.get("/api/admin/settlements", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      // 새 settlementRecords 테이블에서 조회
      const records = await db.select().from(settlementRecords).orderBy(desc(settlementRecords.createdAt));
      const users = await storage.getAllUsers();
      const orders = await storage.getOrders();
      const courierSettings = await db.select().from(courierSettings as any).execute();
      
      const userMap = new Map(users.map(u => [u.id, u]));
      const orderMap = new Map(orders.map(o => [o.id, o]));
      
      const enrichedSettlements = records.map(r => {
        const helper = r.helperId ? userMap.get(r.helperId) : null;
        const order = r.orderId ? orderMap.get(r.orderId) : null;
        
        return {
          id: r.id,
          orderId: r.orderId,
          helperName: helper?.name || "Unknown",
            helperNickname: (helper as any)?.nickname || null,
          helperPhone: helper?.phoneNumber || null,
          orderTitle: order?.companyName || null,
          workDate: order?.scheduledDate || null,
          // 새 정산 필드
          baseSupply: r.baseSupply,
          urgentFeeSupply: r.urgentFeeSupply || 0,
          extraSupply: r.extraSupply || 0,
          finalSupply: r.finalSupply,
          vat: r.vat,
          finalTotal: r.finalTotal,
          platformFeeRate: r.platformFeeRate || 0,
          platformFee: r.platformFee,
          driverPayout: r.driverPayout,
          status: r.status,
          createdAt: r.createdAt,
          calculatedAt: r.calculatedAt,
          // 레거시 호환용 (기존 UI 지원)
          totalAmount: r.finalTotal,
          netAmount: r.driverPayout,
          commissionAmount: r.platformFee,
          deliveryCount: null, // 별도 조회 필요
          returnCount: null,
        };
      });
      
      res.json(enrichedSettlements);
    } catch (err) {
      console.error("Get settlements error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create settlement (admin)
  app.post("/api/admin/settlements", adminAuth, requirePermission("settlements.create"), async (req, res) => {
    try {
      const { helperId, workDate, deliveryCount, basePay, additionalPay, penalty, deduction, notes } = req.body;
      
      if (!helperId || !workDate) {
        return res.status(400).json({ message: "기사 ID와 작업일은 필수입니다" });
      }
      
      // Check if user exists (any registered user can receive settlements)
      const helper = await storage.getUser(helperId);
      if (!helper) {
        return res.status(404).json({ message: "사용자를 찾을 수 없습니다" });
      }
      
      // Safely parse numeric values with defaults
      const safeDeliveryCount = Number(deliveryCount) || 0;
      const safeBasePay = Number(basePay) || 0;
      const safeAdditionalPay = Number(additionalPay) || 0;
      const safePenalty = Number(penalty) || 0;
      const safeDeduction = Number(deduction) || 0;
      
      const totalAmount = safeBasePay + safeAdditionalPay - safePenalty - safeDeduction;
      
      // 시스템 설정에서 수수료율 조회 (기본 12%)
      const commissionRateSetting = await storage.getSystemSetting("default_commission_rate");
      const commissionRate = commissionRateSetting?.value ? parseFloat(commissionRateSetting.value) : 12;
      const commissionAmount = Math.round(totalAmount * commissionRate / 100);
      const netAmount = totalAmount - commissionAmount;
      
      const settlement = await storage.createSettlementStatement({
        workDate,
        deliveryCount: safeDeliveryCount,
        basePay: safeBasePay,
        additionalPay: safeAdditionalPay,
        penalty: safePenalty,
        deduction: safeDeduction,
        commissionRate,
        commissionAmount,
        totalAmount,
        netAmount,
        status: "pending",
      });
      
      res.status(201).json(settlement);
    } catch (err) {
      console.error("Create settlement error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // Admin 정산 생성 API (스펙 4-1)
  // 스펙: POST /admin/settlements/generate
  // ============================================
  app.post("/api/admin/settlements/generate", adminAuth, requirePermission("settlements.create"), async (req, res) => {
    try {
      const user = (req as any).user;
      const { period_start, period_end, helper_user_id } = req.body;

      if (!period_start || !period_end || !helper_user_id) {
        return res.status(400).json({ 
          error: { code: "INVALID_INPUT", message: "period_start, period_end, helper_user_id는 필수입니다" } 
        });
      }

      // 헬퍼 확인
      const helper = await storage.getUser(helper_user_id);
      if (!helper) {
        return res.status(404).json({ 
          error: { code: "HELPER_NOT_FOUND", message: "헬퍼를 찾을 수 없습니다" } 
        });
      }

      // 기간 내 완료된 오더 조회 (job_status == CLOSED + balance_invoices.status == PAID)
      const orders = await storage.getOrders();
      const courierSettings = await db.select().from(courierSettings as any).execute();
      const completedStatuses = ["closed", "balance_paid", "settlement_paid"];
      const closedOrders = orders.filter(o => {
        if (o.helperId !== helper_user_id) return false;
        if (!completedStatuses.includes(o.status || "")) return false;
        
        const orderDate = o.endDate || o.createdAt;
        if (!orderDate) return false;
        
        const date = new Date(orderDate);
        return date >= new Date(period_start) && date <= new Date(period_end);
      });

      if (closedOrders.length === 0) {
        return res.status(400).json({ 
          error: { code: "NO_ORDERS", message: "정산 대상 오더가 없습니다" } 
        });
      }

      // 오더별 정산 데이터 계산
      let grossAmount = 0;
      let feeAmount = 0;
      let deductionAmount = 0;
      const settlementLines: any[] = [];

      for (const order of closedOrders) {
        const snapshot = await storage.getOrderPricingSnapshot(order.id);
        const costItems = await storage.getOrderCostItems(order.id);
        
        const baseAmount = snapshot ? Number(snapshot.baseAmountKrw) : 0;
        grossAmount += baseAmount;

        // 비용 라인 추가
        for (const item of costItems) {
          settlementLines.push({
            type: item.sign === "plus" ? "COST_PLUS" : "COST_MINUS",
            orderId: order.id,
            amount: Number(item.amount),
            label: item.label,
          });
          
          if (item.sign === "plus") {
            grossAmount += Number(item.amount);
          } else {
            deductionAmount += Number(item.amount);
          }
        }

        settlementLines.push({
          type: "ORDER_BASE",
          orderId: order.id,
          amount: baseAmount,
          label: order.companyName || `Order #${order.id}`,
        });
      }

      // 시스템 설정에서 수수료율 조회 (기본 12%)
      const commissionRateSetting = await storage.getSystemSetting("default_commission_rate");
      const commissionRate = commissionRateSetting?.value ? parseFloat(commissionRateSetting.value) : 12;
      feeAmount = Math.round(grossAmount * commissionRate / 100);
      const netAmount = grossAmount - feeAmount - deductionAmount;

      // 정산 생성 (DRAFT 상태)
      const settlement = await storage.createSettlementStatement({
        helperId: helper_user_id,
        workDate: period_start, // 기간 시작일
        deliveryCount: closedOrders.length,
        basePay: grossAmount,
        commissionRate,
        commissionAmount: feeAmount,
        totalAmount: grossAmount,
        netAmount,
        status: "pending", // DRAFT 역할
        periodStart: new Date(period_start),
        periodEnd: new Date(period_end),
      });

      // 감사 로그 기록
      await logAdminAction({
        userId: user.id,
        action: "settlement.generate",
        targetType: "settlement",
        targetId: String(settlement.id),
        reason: `정산 생성: ${helper.name || helper_user_id} (${period_start} ~ ${period_end})`,
        metadata: { period_start, period_end, helper_user_id, order_count: closedOrders.length },
      });

      res.json({
        settlement_id: String(settlement.id),
        status: "DRAFT",
        locked: false,
        summary: {
          gross_amount: grossAmount,
          fee_amount: feeAmount,
          deduction_amount: deductionAmount,
          net_amount: netAmount,
        },
      });
    } catch (err) {
      console.error("Generate settlement error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // Admin 정산 검증 완료 → READY (스펙 4-2)
  // 스펙: POST /admin/settlements/{settlementId}/mark-ready
  // ============================================
  app.post("/api/admin/settlements/:id/mark-ready", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const user = (req as any).user;
      const id = Number(req.params.id);
      const { reason } = req.body;

      const settlement = await storage.getSettlementStatement(id);
      if (!settlement) {
        return res.status(404).json({ 
          error: { code: "NOT_FOUND", message: "정산을 찾을 수 없습니다" } 
        });
      }

      // pending(DRAFT) → confirmed(READY) 전환
      if (settlement.status !== "pending") {
        return res.status(400).json({ 
          error: { code: "INVALID_STATUS", message: `현재 상태(${settlement.status})에서 READY 처리할 수 없습니다` } 
        });
      }

      const updated = await storage.updateSettlementStatement(id, {
        status: "confirmed", // READY 역할
      });

      // 감사 로그 기록
      await logAdminAction({
        userId: user.id,
        action: "settlement.mark_ready",
        targetType: "settlement",
        targetId: String(id),
        reason: reason || "라인 검증 완료",
        metadata: { previous_status: settlement.status },
      });

      res.json({
        settlement_id: String(id),
        status: "READY",
      });
    } catch (err) {
      console.error("Mark ready error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get single settlement with details (admin)
  app.get("/api/admin/settlements/:id", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const settlement = await storage.getSettlementStatement(id);
      
      if (!settlement) {
        return res.status(404).json({ message: "정산 내역을 찾을 수 없습니다" });
      }
      
      const lineItems = await storage.getSettlementLineItems(id);
      const helper = settlement.helperId ? await storage.getUser(settlement.helperId) : null;
      const order = settlement.orderId ? await storage.getOrder(settlement.orderId) : null;
      
      res.json({
        ...settlement,
        lineItems,
        helperName: helper?.name || null,
        trackingNumber: incident.trackingNumber || null,
        evidencePhotoUrls,
        helperPhone: helper?.phoneNumber || null,
        orderTitle: order?.companyName || null,
      });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Confirm settlement (admin)
  app.patch("/api/admin/settlements/:id/confirm", adminAuth, requirePermission("settlements.confirm"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const settlement = await storage.getSettlementStatement(id);
      
      if (!settlement) {
        return res.status(404).json({ message: "정산 내역을 찾을 수 없습니다" });
      }
      
      // 상태 머신 검증: pending → confirmed 전이만 허용
      if (!canTransitionSettlementStatus(settlement.status || "pending", SETTLEMENT_STATUS.CONFIRMED)) {
        return res.status(400).json({ 
          message: `현재 상태(${settlement.status})에서 확정 처리할 수 없습니다`,
          allowedFrom: ["pending"]
        });
      }
      
      const updated = await storage.updateSettlementStatement(id, {
        status: "confirmed",
      });
      
      // 감사 로그 기록
      await logAdminAction({
        req,
        action: "settlement.confirm",
        targetType: "settlement",
        targetId: id,
        oldValue: { status: settlement.status },
        newValue: { status: "confirmed" },
      });
      
      // 기사에게 알림
      if (settlement.helperId) {
        await storage.createNotification({
          type: "settlement_completed",
          title: "정산 확정",
          message: `정산이 확정되었습니다. 지급 예정 금액: ${(settlement.netAmount || 0).toLocaleString()}원`,
          payload: JSON.stringify({ settlementId: id }),
        });
        
        // Notify helper via WebSocket
        notificationWS.sendDataRefresh(settlement.helperId, {
          type: "settlement",
          action: "updated",
          entityId: id,
        });
      }
      
      // Broadcast to all admins for real-time updates
      broadcastToAllAdmins("settlement", "confirmed", id, { status: "confirmed" });
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Process settlement payment (admin)
  app.patch("/api/admin/settlements/:id/pay", adminAuth, requirePermission("settlements.pay"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { paymentMethod, transactionRef, notes } = req.body;
      
      const settlement = await storage.getSettlementStatement(id);
      
      if (!settlement) {
        return res.status(404).json({ message: "정산 내역을 찾을 수 없습니다" });
      }
      
      // 상태 머신 검증: confirmed → payable → paid 전이만 허용
      // 중간 단계(payable)를 건너뛰거나 직접 paid로 전환 허용 (운영 편의성)
      if (!canTransitionSettlementStatus(settlement.status || "pending", SETTLEMENT_STATUS.PAID) &&
          !canTransitionSettlementStatus(settlement.status || "pending", SETTLEMENT_STATUS.PAYABLE)) {
        return res.status(400).json({ 
          message: `현재 상태(${settlement.status})에서 지급 처리할 수 없습니다`,
          allowedFrom: ["confirmed", "payable"]
        });
      }
      
      const updated = await storage.updateSettlementStatement(id, {
        status: "paid",
      });
      
      // 감사 로그 기록 - 금전 액션이므로 상세 기록
      await logAdminAction({
        req,
        action: "settlement.pay",
        targetType: "settlement",
        targetId: id,
        oldValue: { status: settlement.status, netAmount: settlement.netAmount },
        newValue: { status: "paid", paymentMethod, netAmount: settlement.netAmount },
      });
      
      // Payment 기록 생성
      await storage.createPayment({
        orderId: settlement.orderId,
        payerId: settlement.helperId || "system",
        provider: paymentMethod || "bank_transfer",
        amount: settlement.netAmount || 0,
        paymentType: "helper_settlement",
        status: "captured",
      });
      
      // 기사에게 알림
      if (settlement.helperId) {
        await storage.createNotification({
          type: "settlement_completed",
          title: "정산금 지급 완료",
          message: `${(settlement.netAmount || 0).toLocaleString()}원이 지급 완료되었습니다.`,
          payload: JSON.stringify({ settlementId: id }),
        });
        
        // Notify helper via WebSocket
        notificationWS.sendDataRefresh(settlement.helperId, {
          type: "settlement",
          action: "updated",
          entityId: id,
        });
      }
      
      // Broadcast to all admins for real-time updates
      broadcastToAllAdmins("settlement", "paid", id, { status: "paid" });
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Hold settlement (admin)
  app.patch("/api/admin/settlements/:id/hold", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { reason, incidentId } = req.body;
      
      const settlement = await storage.getSettlementStatement(id);
      
      if (!settlement) {
        return res.status(404).json({ message: "정산 내역을 찾을 수 없습니다" });
      }
      
      // 상태 머신 검증: PAID 상태에서는 보류 불가
      if (!canTransitionSettlementStatus(settlement.status || "pending", SETTLEMENT_STATUS.ON_HOLD)) {
        return res.status(400).json({ 
          message: `현재 상태(${settlement.status})에서 보류 처리할 수 없습니다`,
          reason: settlement.status === "paid" ? "이미 지급된 정산은 보류할 수 없습니다" : "허용되지 않는 상태 전이입니다"
        });
      }
      
      const updated = await storage.updateSettlementStatement(id, {
        status: "on_hold",
        holdReason: reason || "보류 처리됨",
        holdIncidentId: incidentId,
      });
      
      // 감사 로그 기록
      await logAdminAction({
        req,
        action: "settlement.hold",
        targetType: "settlement",
        targetId: id,
        oldValue: { status: settlement.status },
        newValue: { status: "on_hold", holdReason: reason },
      });
      
      // 기사에게 알림
      if (settlement.helperId) {
        await storage.createNotification({
          type: "dispute_submitted",
          title: "정산 보류",
          message: `정산이 보류 처리되었습니다. 사유: ${reason || "확인 필요"}`,
          payload: JSON.stringify({ settlementId: id }),
        });
        
        // Notify helper via WebSocket
        notificationWS.sendDataRefresh(settlement.helperId, {
          type: "settlement",
          action: "updated",
          entityId: id,
        });
      }
      
      // Broadcast to all admins for real-time updates
      broadcastToAllAdmins("settlement", "held", id, { status: "on_hold" });
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // POST /api/admin/settlements/:id/deductions - 차감 추가 (T-08 스펙)
  app.post("/api/admin/settlements/:id/deductions", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const user = (req as any).adminUser || (req as any).user;
      const { type, amount, reason, evidenceUrl } = req.body;

      // 필수 필드 검증
      if (!type || !amount || !reason) {
        return res.status(400).json({ 
          code: "INVALID_INPUT", 
          message: "차감 유형, 금액, 사유는 필수입니다" 
        });
      }

      // 차감 유형 검증
      const validTypes = ["DAMAGE", "LOSS", "CLAIM", "ETC"];
      if (!validTypes.includes(type)) {
        return res.status(400).json({ 
          code: "INVALID_TYPE", 
          message: `차감 유형은 ${validTypes.join(", ")} 중 하나여야 합니다` 
        });
      }

      const settlement = await storage.getSettlementStatement(id);
      if (!settlement) {
        return res.status(404).json({ code: "NOT_FOUND", message: "정산 내역을 찾을 수 없습니다" });
      }

      // 이미 지급된 정산은 차감 불가
      if (settlement.status === "paid") {
        return res.status(400).json({ 
          code: "ALREADY_PAID", 
          message: "이미 지급된 정산에는 차감을 추가할 수 없습니다" 
        });
      }

      // 기존 차감 금액에 추가
      const currentDeduction = settlement.deductionAmount || 0;
      const newDeductionTotal = currentDeduction + amount;

      // 차감 내역 저장 (기존 deductions JSON에 추가)
      const existingDeductions = settlement.deductions ? 
        (typeof settlement.deductions === "string" ? JSON.parse(settlement.deductions) : settlement.deductions) : [];
      
      const newDeduction = {
        id: `ded_${Date.now()}`,
        type,
        amount,
        reason,
        evidenceUrl: evidenceUrl || null,
        createdAt: new Date().toISOString(),
        createdBy: user.id,
      };
      
      existingDeductions.push(newDeduction);

      // 정산 업데이트
      const updated = await storage.updateSettlementStatement(id, {
        deductionAmount: newDeductionTotal,
        deductions: JSON.stringify(existingDeductions),
        netAmount: (settlement.totalAmount || 0) - (settlement.feeAmount || 0) - newDeductionTotal,
      });

      // 감사 로그 기록
      await logAdminAction({
        userId: user.id,
        action: "settlement.add_deduction",
        targetType: "settlement",
        targetId: id,
        oldValue: { deductionAmount: currentDeduction },
        newValue: { 
          deductionAmount: newDeductionTotal, 
          newDeduction: { type, amount, reason } 
        },
        reason: reason,
      });

      res.status(201).json({
        ok: true,
        deduction: newDeduction,
        settlement: updated,
      });
    } catch (err) {
      console.error("Add settlement deduction error:", err);
      res.status(500).json({ code: "SERVER_ERROR", message: "차감 추가에 실패했습니다" });
    }
  });

  // Release settlement hold (admin)
  app.patch("/api/admin/settlements/:id/release", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      
      const settlement = await storage.getSettlementStatement(id);
      
      if (!settlement) {
        return res.status(404).json({ message: "정산 내역을 찾을 수 없습니다" });
      }
      
      // 상태 머신 검증: on_hold → confirmed/payable로 전이 (pending은 초기 상태라 release시 confirmed로)
      if (!canTransitionSettlementStatus(settlement.status || "pending", SETTLEMENT_STATUS.CONFIRMED)) {
        return res.status(400).json({ 
          message: `현재 상태(${settlement.status})에서 보류 해제할 수 없습니다`,
          allowedFrom: ["on_hold"]
        });
      }
      
      const updated = await storage.updateSettlementStatement(id, {
        status: "confirmed",
        holdReason: null,
        holdIncidentId: null,
      });
      
      // 감사 로그 기록
      await logAdminAction({
        req,
        action: "settlement.release",
        targetType: "settlement",
        targetId: id,
        oldValue: { status: settlement.status, holdReason: settlement.holdReason },
        newValue: { status: "confirmed" },
      });
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update settlement counts (for dispute resolution)
  app.patch("/api/admin/settlements/:id/counts", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { deliveryCount, returnCount, pickupCount, otherCount, unitPrice: requestedUnitPrice, notes } = req.body;
      
      const settlement = await storage.getSettlementStatement(id);
      
      if (!settlement) {
        return res.status(404).json({ message: "정산 내역을 찾을 수 없습니다" });
      }
      
      if (settlement.status === "paid") {
        return res.status(400).json({ message: "지급 완료된 정산은 수정할 수 없습니다" });
      }
      
      // Recalculate amounts with updated counts
      const newDeliveryCount = deliveryCount ?? settlement.deliveryCount ?? 0;
      const newReturnCount = returnCount ?? settlement.returnCount ?? 0;
      const newPickupCount = pickupCount ?? settlement.pickupCount ?? 0;
      const newOtherCount = otherCount ?? settlement.otherCount ?? 0;
      
      // Derive unitPrice from existing settlement or use provided value
      const existingBoxCount = (settlement.deliveryCount || 0) + (settlement.returnCount || 0) + 
                               (settlement.pickupCount || 0) + (settlement.otherCount || 0);
      const existingUnitPrice = existingBoxCount > 0 && settlement.supplyAmount
        ? Math.round((settlement.supplyAmount || 0) / existingBoxCount)
        : (settlement as any).unitPrice || 0;
      const newUnitPrice = requestedUnitPrice ?? existingUnitPrice;
      
      // Allow zero unitPrice only when counts are also zero
      if (newUnitPrice < 0) {
        return res.status(400).json({ message: "단가는 0 이상이어야 합니다." });
      }
      
      const totalBoxCount = newDeliveryCount + newReturnCount + newPickupCount + newOtherCount;
      
      // Require explicit unitPrice when modifying counts but have no reference
      if (totalBoxCount > 0 && newUnitPrice === 0) {
        return res.status(400).json({ message: "수량이 있을 경우 단가를 입력해주세요." });
      }
      
      const supplyAmount = totalBoxCount * newUnitPrice;
      const vatAmount = Math.round(supplyAmount * 0.1);
      const totalAmount = supplyAmount + vatAmount;
      
      // Get commission rate from the existing settlement
      const commissionRate = settlement.commissionRate ?? 10;
      const platformRate = settlement.platformCommission && settlement.totalAmount 
        ? Math.round((settlement.platformCommission / settlement.totalAmount) * 100 * 10) / 10 
        : 8;
      
      const commissionAmount = Math.round(totalAmount * (commissionRate / 100));
      const platformCommission = Math.round(totalAmount * (platformRate / 100));
      const teamLeaderIncentive = commissionAmount - platformCommission;
      const netAmount = totalAmount - commissionAmount;
      
      // Build audit note with previous values
      const timestamp = new Date().toISOString().slice(0, 16).replace('T', ' ');
      const auditEntry = notes 
        ? `[${timestamp}] ${notes} (이전: 배송 ${settlement.deliveryCount || 0}, 반품 ${settlement.returnCount || 0}, 픽업 ${settlement.pickupCount || 0}, 기타 ${settlement.otherCount || 0})`
        : `[${timestamp}] 수량 수정 (이전: 배송 ${settlement.deliveryCount || 0}, 반품 ${settlement.returnCount || 0}, 픽업 ${settlement.pickupCount || 0}, 기타 ${settlement.otherCount || 0})`;
      const existingContent = settlement.statementContent || "";
      const updatedContent = existingContent 
        ? `${existingContent}\n${auditEntry}`
        : auditEntry;
      
      const updated = await storage.updateSettlementStatement(id, {
        deliveryCount: newDeliveryCount,
        returnCount: newReturnCount,
        pickupCount: newPickupCount,
        otherCount: newOtherCount,
        supplyAmount,
        vatAmount,
        totalAmount,
        commissionAmount,
        platformCommission,
        teamLeaderIncentive,
        netAmount,
        statementContent: updatedContent,
      });
      
      res.json({ message: "정산 수정 완료", settlement: updated });
    } catch (err) {
      console.error("Settlement update error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Generate monthly settlements for all helpers (admin)
  app.post("/api/admin/settlements/generate-monthly", adminAuth, requirePermission("settlements.create"), async (req, res) => {
    try {
      const { year, month } = req.body;
      
      if (!year || !month) {
        return res.status(400).json({ message: "년도와 월을 입력해주세요" });
      }
      
      const startDate = new Date(year, month - 1, 1);
      const endDate = new Date(year, month, 0, 23, 59, 59);
      
      // Get all orders that are closed/completed in the specified month
      const allOrders = await storage.getOrders();
      const completedStatuses = ["closed", "balance_paid", "settlement_paid"];
      const closedOrders = allOrders.filter(o => {
        const status = o.status?.toLowerCase();
        if (!completedStatuses.includes(status || "")) return false;
        // Check if order was completed in the target month
        const orderDate = o.closedAt ? new Date(o.closedAt) : (o.createdAt ? new Date(o.createdAt) : null);
        if (!orderDate) return false;
        return orderDate >= startDate && orderDate <= endDate;
      });
      
      if (closedOrders.length === 0) {
        return res.json({ message: "해당 월에 완료된 주문이 없습니다", created: 0, skipped: 0 });
      }
      
      // Get existing settlements to avoid duplicates
      const existingSettlements = await storage.getAllSettlementStatements();
      const existingOrderIds = new Set(existingSettlements.map(s => s.orderId).filter(Boolean));
      
      // Group orders by helper through applications
      const helperOrders: Map<string, typeof closedOrders> = new Map();
      
      for (const order of closedOrders) {
        if (existingOrderIds.has(order.id)) continue;
        
        const applications = await storage.getOrderApplications(order.id);
        const completedApp = applications.find(a => a.status === "completed");
        
        if (completedApp) {
          const helperId = completedApp.helperId;
          if (!helperOrders.has(helperId)) {
            helperOrders.set(helperId, []);
          }
          helperOrders.get(helperId)!.push(order);
        }
      }
      
      let created = 0;
      let skipped = 0;
      
      for (const [helperId, orders] of Array.from(helperOrders.entries())) {
        for (const order of orders) {
          try {
            // 수수료율 조회 (우선순위: 신청 스냅샷 > 오더 스냅샷 > 현재 정책)
            let commissionRate: number;
            let platformRate: number;
            let teamLeaderRate: number;
            let teamLeaderId: string | null = null;
            
            // 1. 헬퍼 신청(application) 스냅샷이 있으면 우선 사용
            const application = await storage.getOrderApplication(order.id, helperId);
            if (application?.snapshotCommissionRate != null && 
                application?.snapshotPlatformRate != null && 
                application?.snapshotTeamLeaderRate != null) {
              commissionRate = application.snapshotCommissionRate;
              platformRate = application.snapshotPlatformRate;
              teamLeaderRate = application.snapshotTeamLeaderRate;
              teamLeaderId = application.snapshotTeamLeaderId;
            // 2. 오더 스냅샷이 있으면 사용
            } else if (order.snapshotCommissionRate != null && 
                       order.snapshotPlatformRate != null && 
                       order.snapshotTeamLeaderRate != null) {
              commissionRate = order.snapshotCommissionRate;
              platformRate = order.snapshotPlatformRate;
              teamLeaderRate = order.snapshotTeamLeaderRate;
              const teamMember = await storage.getTeamMemberByUserId(helperId);
              if (teamMember) {
                const team = await storage.getTeamById(teamMember.teamId);
                teamLeaderId = team?.leaderId || null;
              }
            // 3. 스냅샷이 없으면 (레거시) 현재 정책으로 폴백
            } else {
              const effectiveRate = await storage.getEffectiveCommissionRate(helperId);
              commissionRate = effectiveRate.rate;
              platformRate = effectiveRate.platformRate;
              teamLeaderRate = effectiveRate.teamLeaderRate;
              teamLeaderId = effectiveRate.teamLeaderId;
            }
            
            const totalAmount = Number(order.pricePerUnit) || 0;
            const commissionAmount = Math.round(totalAmount * commissionRate / 100);
            const platformCommission = Math.round(totalAmount * platformRate / 100);
            const teamLeaderIncentive = Math.round(totalAmount * teamLeaderRate / 100);
            const netAmountBeforeVAT = totalAmount - commissionAmount;
            // VAT calculation: (total - commission) / 1.1
            const supplyAmount = Math.round(netAmountBeforeVAT / 1.1);
            const vatAmount = netAmountBeforeVAT - supplyAmount;
            
            await storage.createSettlementStatement({
              orderId: order.id,
              workDate: order.scheduledDate || `${year}-${String(month).padStart(2, '0')}-01`,
              basePay: totalAmount,
              additionalPay: 0,
              penalty: 0,
              deduction: 0,
              commissionRate,
              commissionAmount,
              platformCommission,
              teamLeaderIncentive,
              teamLeaderId,
              supplyAmount,
              vatAmount,
              totalAmount,
              netAmount: netAmountBeforeVAT,
              status: "pending",
            });
            created++;
          } catch (err) {
            console.error(`Settlement creation error for order ${order.id}:`, err);
            skipped++;
          }
        }
      }
      
      res.json({ 
        message: `${year}년 ${month}월 정산 생성 완료`,
        created,
        skipped,
        total: closedOrders.length
      });
    } catch (err) {
      console.error("Generate monthly settlements error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Batch confirm settlements (admin)
  app.post("/api/admin/settlements/batch-confirm", adminAuth, requirePermission("settlements.confirm"), async (req, res) => {
    try {
      const { ids } = req.body;
      
      if (!ids || !Array.isArray(ids) || ids.length === 0) {
        return res.status(400).json({ message: "정산 ID 목록이 필요합니다" });
      }
      
      const results = await Promise.all(
        ids.map(async (id: number) => {
          const settlement = await storage.getSettlementStatement(id);
          if (!settlement || settlement.status !== "pending") {
            return { id, success: false, reason: "대기 상태가 아님" };
          }
          
          await storage.updateSettlementStatement(id, {
            status: "confirmed",
          });
          
          return { id, success: true };
        })
      );
      
      const successCount = results.filter(r => r.success).length;
      res.json({ message: `${successCount}건 확정 완료`, results });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Batch pay settlements (admin)
  app.post("/api/admin/settlements/batch-pay", adminAuth, requirePermission("settlements.pay"), async (req, res) => {
    try {
      const { ids, paymentMethod } = req.body;
      
      if (!ids || !Array.isArray(ids) || ids.length === 0) {
        return res.status(400).json({ message: "정산 ID 목록이 필요합니다" });
      }
      
      const results = await Promise.all(
        ids.map(async (id: number) => {
          const settlement = await storage.getSettlementStatement(id);
          if (!settlement || settlement.status !== "confirmed") {
            return { id, success: false, reason: "확정 상태가 아님" };
          }
          
          await storage.updateSettlementStatement(id, {
            status: "paid",
          });
          
          // Payment 기록 생성
          await storage.createPayment({
            orderId: settlement.orderId,
            payerId: settlement.helperId || "system",
            provider: paymentMethod || "bank_transfer",
            amount: settlement.netAmount || 0,
            paymentType: "helper_settlement",
            status: "captured",
          });
          
          return { id, success: true };
        })
      );
      
      const successCount = results.filter(r => r.success).length;
      res.json({ message: `${successCount}건 지급 완료`, results });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get all disputes/incidents (admin) - combines legacy incidents and new disputes
  app.get("/api/admin/disputes", adminAuth, requirePermission("disputes.view"), async (req, res) => {
    try {
      const incidents = await storage.getAllIncidentReports();
      const helperDisputes = await storage.getAllDisputes();
      const users = await storage.getAllUsers();
      const contracts = await storage.getAllContracts();
      
      const userMap = new Map(users.map(u => [u.id, u]));
      const contractMap = new Map(contracts.map(c => [c.id, c]));
      
      // Legacy incident reports
      const enrichedIncidents = incidents.map(i => {
        const reporter = i.reporterId ? userMap.get(i.reporterId) : null;
        const contract = i.jobContractId ? contractMap.get(i.jobContractId) : null;
        return {
          ...i,
          source: "incident" as const,
          reporterName: reporter?.name || null,
          reporterPhone: reporter?.phoneNumber || null,
          contractInfo: contract ? {
            orderId: contract.orderId,
            totalAmount: contract.totalAmount,
          } : null,
        };
      });
      
      // New disputes (이의제기 - helper and requester)
      const ordersData = await storage.getAllOrders();
      const orderMap = new Map(ordersData.map(o => [o.id, o]));
      
      const enrichedDisputes = helperDisputes.map(d => {
        const helper = d.helperId ? userMap.get(d.helperId) : null;
        const order = d.orderId ? orderMap.get(d.orderId) : null;
        const requester = order?.requesterId ? userMap.get(order.requesterId) : null;
        return {
          id: d.id,
          source: "dispute" as const,
          submitterRole: d.submitterRole || "helper",
          disputeType: d.disputeType,
          status: d.status,
          description: d.description,
          workDate: d.workDate,
          createdAt: d.createdAt,
          resolvedAt: d.resolvedAt,
          resolution: d.resolution,
          helperName: helper?.name || null,
          helperPhone: helper?.phoneNumber || null,
          requesterName: requester?.name || null,
          requesterPhone: requester?.phoneNumber || null,
          settlementId: d.settlementId,
          orderId: d.orderId,
          requestedDeliveryCount: d.requestedDeliveryCount,
          requestedReturnCount: d.requestedReturnCount,
          requestedPickupCount: d.requestedPickupCount,
          requestedOtherCount: d.requestedOtherCount,
        };
      });
      
      
      res.json({ incidents: enrichedIncidents, helperDisputes: enrichedDisputes });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get single dispute (admin)
  app.get("/api/admin/disputes/:id", adminAuth, requirePermission("disputes.view"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const incident = await storage.getIncidentReport(id);
      
      if (!incident) {
        return res.status(404).json({ message: "분쟁을 찾을 수 없습니다" });
      }
      
      const reporter = incident.reporterId ? await storage.getUser(incident.reporterId) : null;
      const contract = incident.jobContractId ? await storage.getContract(incident.jobContractId) : null;
      
      res.json({
        ...incident,
        reporterName: reporter?.name || null,
        reporterPhone: reporter?.phoneNumber || null,
        contractInfo: contract,
      });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update dispute status (admin) - 분쟁 상태 변경 시 정산 차감 자동 연동
  app.patch("/api/admin/disputes/:id/status", adminAuth, requirePermission("disputes.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { status, resolution, notes, deductionAmount } = req.body;
      
      const incident = await storage.getIncidentReport(id);
      if (!incident) {
        return res.status(404).json({ message: "분쟁을 찾을 수 없습니다" });
      }
      
      const updateData: any = { status };
      if (resolution) updateData.resolution = resolution;
      if (adminReply) { updateData.adminReply = adminReply; updateData.adminReplyAt = new Date(); updateData.adminReplyBy = decoded?.userId || null; }
      if (deductionAmount !== undefined) updateData.resolutionAmount = deductionAmount;
      if (status === "resolved" || status === "closed") {
        updateData.resolvedAt = new Date();
      }
      
      const updated = await storage.updateIncidentReport(id, updateData);
      
      // 분쟁 해결 시 정산 차감 자동 반영
      if (status === "resolved" && (deductionAmount || incident.resolutionAmount)) {
        const amount = deductionAmount || incident.resolutionAmount || 0;
        
        // 정산 찾기: settlementId가 있으면 사용, 없으면 orderId/jobContractId로 검색
        let settlement = null;
        if (incident.settlementId) {
          settlement = await storage.getSettlementStatement(incident.settlementId);
        } else if (incident.orderId) {
          settlement = await storage.getSettlementStatementByOrder(incident.orderId);
        } else if (incident.jobContractId) {
          const contract = await storage.getContract(incident.jobContractId);
          if (contract?.orderId) {
            settlement = await storage.getSettlementStatementByOrder(contract.orderId);
          }
        }
        
        if (settlement && amount > 0) {
          // 멱등성 체크: 같은 분쟁 ID로 이미 차감이 있는지 확인
          const existingLineItem = await storage.getSettlementLineItemByIncident(settlement.id, id);
          
          if (!existingLineItem) {
            // 차감 라인아이템 생성
            await storage.createSettlementLineItem({
              statementId: settlement.id,
              itemType: "deduction",
              itemName: `분쟁 차감 #${id}`,
              quantity: 1,
              unitPrice: -amount,
              amount: -amount,
              notes: JSON.stringify({ 
                incidentId: id, 
                reason: resolution || incident.description,
                status: "approved"
              }),
            });
            
            // 정산 차감 금액 업데이트 및 순지급액 재계산 (델타 기반)
            const currentDeduction = settlement.deduction || 0;
            const newDeduction = currentDeduction + amount;
            // 기존 netAmount에서 차감 금액만큼 빼기 (penalty/additionalPay 등 다른 필드 영향 없음)
            const currentNetAmount = settlement.netAmount || 0;
            const newNetAmount = currentNetAmount - amount;
            
            await storage.updateSettlementStatement(settlement.id, {
              deduction: newDeduction,
              netAmount: newNetAmount,
            });
            
            // 분쟁에 정산 ID 연결
            await storage.updateIncidentReport(id, { settlementId: settlement.id });
            
            console.log(`[Dispute→Settlement] Incident #${id} deduction ${amount}원 applied to settlement #${settlement.id}`);
          } else {
            console.log(`[Dispute→Settlement] Incident #${id} deduction already exists, skipping (idempotent)`);
          }
        }
      }
      
      // 분쟁 취소 시 차감 복구 (reversed)
      if (status === "closed" && incident.status === "resolved" && incident.settlementId) {
        const settlement = await storage.getSettlementStatement(incident.settlementId);
        if (settlement) {
          const existingLineItem = await storage.getSettlementLineItemByIncident(settlement.id, id);
          
          if (existingLineItem) {
            const reversedAmount = Math.abs(existingLineItem.amount || 0);
            
            // 라인아이템 상태를 reversed로 변경
            await storage.updateSettlementLineItem(existingLineItem.id, {
              notes: JSON.stringify({
                ...JSON.parse(existingLineItem.notes || "{}"),
                status: "reversed",
                reversedAt: new Date().toISOString()
              }),
            });
            
            // 정산 차감 금액 복구 (델타 기반)
            const currentDeduction = settlement.deduction || 0;
            const newDeduction = Math.max(0, currentDeduction - reversedAmount);
            // 기존 netAmount에 복구 금액만큼 더하기 (penalty/additionalPay 등 다른 필드 영향 없음)
            const currentNetAmount = settlement.netAmount || 0;
            const newNetAmount = currentNetAmount + reversedAmount;
            
            await storage.updateSettlementStatement(settlement.id, {
              deduction: newDeduction,
              netAmount: newNetAmount,
            });
            
            console.log(`[Dispute→Settlement] Incident #${id} deduction ${reversedAmount}원 reversed from settlement #${settlement.id}`);
          }
        }
      }
      
      // 신고자에게 알림
      if (incident.reporterId) {
        const statusLabel = status === "resolved" ? "해결됨" : 
                           status === "closed" ? "종료됨" : 
                           status === "investigating" ? "조사중" : status;
        await storage.createNotification({
          userId: incident.reporterId,
          type: "announcement",
          title: "분쟁 상태 변경",
          message: `분쟁 #${id} 상태가 "${statusLabel}"으로 변경되었습니다.${resolution ? ` 결과: ${resolution}` : ""}`,
        });
      }
      
      res.json(updated);
    } catch (err) {
      console.error("Dispute status update error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create dispute (admin)
  app.post("/api/admin/disputes", adminAuth, requirePermission("disputes.edit"), async (req, res) => {
    try {
      const { jobContractId, reporterId, category, description, severity } = req.body;
      
      const incident = await storage.createIncidentReport({
        jobContractId,
        reporterId,
        incidentType: category || "complaint",
        description,
        status: "awaiting_deposit",
      });
      
      res.json(incident);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update helper dispute status (admin)

  // Get single helper dispute (admin) - 이의제기 상세 조회

  // Get all helper disputes for app admin (admin) - 앱 관리자용 이의제기 목록
  app.get("/api/admin/helper-disputes", adminAuth, requirePermission("disputes.view"), async (req, res) => {
    try {
      const disputes = await storage.getAllDisputes();
      const users = await storage.getAllUsers();
      const ordersData = await storage.getAllOrders();
      
      const userMap = new Map(users.map(u => [u.id, u]));
      const orderMap = new Map(ordersData.map(o => [o.id, o]));
      
      const enrichedDisputes = disputes.map(d => {
        const helper = d.helperId ? userMap.get(d.helperId) : null;
        const order = d.orderId ? orderMap.get(d.orderId) : null;
        const requester = order?.requesterId ? userMap.get(order.requesterId) : null;
        return {
          id: d.id,
          orderId: d.orderId,
          helperId: d.helperId,
          submitterRole: d.submitterRole || "helper",
          submitterName: d.submitterRole === "requester" ? (requester?.name || "요청자") : (helper?.name || "헬퍼"),
          disputeType: d.disputeType,
          status: d.status,
          description: d.description,
          createdAt: d.createdAt,
          resolvedAt: d.resolvedAt,
          helperName: helper?.name || null,
          requesterName: requester?.name || null,
        };
      });
      
      res.json(enrichedDisputes);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app.get("/api/admin/helper-disputes/:id", adminAuth, requirePermission("disputes.view"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const dispute = await storage.getDispute(id);
      
      if (!dispute) {
        return res.status(404).json({ message: "이의제기를 찾을 수 없습니다" });
      }
      
      const helper = dispute.helperId ? await storage.getUser(dispute.helperId) : null;
      const order = dispute.orderId ? await storage.getOrder(dispute.orderId) : null;
      const requester = order?.requesterId ? await storage.getUser(order.requesterId) : null;
      
      res.json({
        id: dispute.id,
        orderId: dispute.orderId,
        helperId: dispute.helperId,
        submitterRole: dispute.submitterRole || "helper",
        submitterName: dispute.submitterRole === "requester" ? (requester?.name || "요청자") : (helper?.name || "헬퍼"),
        disputeType: dispute.disputeType,
        status: dispute.status,
        description: dispute.description,
        adminNote: dispute.adminReply,
        adminReplyAt: dispute.adminReplyAt,
        adminReplyBy: dispute.adminReplyBy,
        createdAt: dispute.createdAt,
        resolvedAt: dispute.resolvedAt,
        resolution: dispute.resolution,
        order: order ? {
          id: order.id,
          carrierName: order.carrierName || "",
          pickupLocation: order.pickupLocation || "",
          deliveryLocation: order.deliveryLocation || "",
        } : null,
        helperName: helper?.name || null,
        helperPhone: helper?.phoneNumber || null,
        requesterName: requester?.name || null,
        requesterPhone: requester?.phoneNumber || null,
      });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get all incident reports for admin (화물사고접수)
  app.get("/api/admin/incident-reports", adminAuth, requirePermission("disputes.view"), async (req, res) => {
    try {
      const incidents = await storage.getAllIncidentReports();
      const users = await storage.getAllUsers();
      
      const userMap = new Map(users.map(u => [u.id, u]));
      
      const enrichedIncidents = incidents.map(i => {
        const helper = i.helperId ? userMap.get(i.helperId) : null;
        const requester = i.requesterId ? userMap.get(i.requesterId) : null;
        return {
          id: i.id,
          orderId: i.orderId,
          incidentType: i.incidentType,
          status: i.status,
          description: i.description,
          damageAmount: i.damageAmount,
          helperName: helper?.name || null,
          requesterName: requester?.name || null,
          helperStatus: i.helperStatus,
          createdAt: i.createdAt,
        };
      });
      
      res.json(enrichedIncidents);
    } catch (err) {
      console.error("Error fetching incident reports:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get incidents with pending deductions (화물사고차감)
  app.get("/api/admin/incident-deductions", adminAuth, requirePermission("disputes.view"), async (req, res) => {
    try {
      const incidents = await storage.getAllIncidentReports();
      const users = await storage.getAllUsers();
      
      const userMap = new Map(users.map(u => [u.id, u]));
      
      // Filter incidents that have deduction amount and resolved status
      const deductionIncidents = incidents
        .filter(i => i.status === "resolved" && i.deductionAmount && i.deductionAmount > 0)
        .map(i => {
          const helper = i.helperId ? userMap.get(i.helperId) : null;
          return {
            id: i.id,
            orderId: i.orderId,
            incidentType: i.incidentType,
            helperName: helper?.name || null,
            helperId: i.helperId,
            deductionAmount: i.deductionAmount,
            deductionReason: i.deductionReason,
            helperDeductionApplied: i.helperDeductionApplied || false,
            deductionConfirmedAt: i.deductionConfirmedAt,
            createdAt: i.createdAt,
          };
        });
      
      res.json(deductionIncidents);
    } catch (err) {
      console.error("Error fetching deduction incidents:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get incidents with pending refunds (화물사고환불)
  app.get("/api/admin/incident-refunds", adminAuth, requirePermission("disputes.view"), async (req, res) => {
    try {
      const incidents = await storage.getAllIncidentReports();
      const users = await storage.getAllUsers();
      
      const userMap = new Map(users.map(u => [u.id, u]));
      
      // Filter incidents that have deduction amount and resolved status
      const refundIncidents = incidents
        .filter(i => i.status === "resolved" && i.deductionAmount && i.deductionAmount > 0)
        .map(i => {
          const requester = i.requesterId ? userMap.get(i.requesterId) : null;
          return {
            id: i.id,
            orderId: i.orderId,
            incidentType: i.incidentType,
            requesterName: requester?.name || null,
            requesterId: i.requesterId,
            deductionAmount: i.deductionAmount,
            deductionReason: i.deductionReason,
            requesterRefundApplied: i.requesterRefundApplied || false,
            deductionConfirmedAt: i.deductionConfirmedAt,
            createdAt: i.createdAt,
          };
        });
      
      res.json(refundIncidents);
    } catch (err) {
      console.error("Error fetching refund incidents:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Confirm helper deduction (차감 확정)
  app.patch("/api/admin/incident-reports/:id/confirm-deduction", adminAuth, requirePermission("disputes.edit"), async (req, res) => {
    try {
      const incidentId = parseInt(req.params.id);
      const incident = await storage.getIncidentReport(incidentId);
      
      if (!incident) {
        return res.status(404).json({ message: "사고 접수를 찾을 수 없습니다." });
      }
      
      if (incident.helperDeductionApplied) {
        return res.status(400).json({ message: "이미 차감이 확정되었습니다." });
      }

      const deductionAmount = incident.deductionAmount || 0;
      const orderId = incident.orderId;

      // Update settlement_records with damage deduction
      if (orderId && deductionAmount > 0) {
        const existingRecord = await db.select().from(settlementRecords).where(eq(settlementRecords.orderId, orderId)).limit(1);
        
        if (existingRecord.length > 0) {
          const currentDeduction = existingRecord[0].damageDeduction || 0;
          await db.update(settlementRecords)
            .set({ 
              damageDeduction: currentDeduction + deductionAmount,
              updatedAt: new Date()
            })
            .where(eq(settlementRecords.orderId, orderId));
          
          console.log(`[Incident Deduction] Order ${orderId}: Applied deduction ${deductionAmount}원 to settlement`);
        } else {
          console.log(`[Incident Deduction] Order ${orderId}: No settlement record found, deduction noted for future settlement`);
        }
      }
      
      await storage.updateIncidentReport(incidentId, {
        helperDeductionApplied: true,
        deductionConfirmedAt: new Date(),
      });
      
      res.json({ 
        message: "헬퍼 차감이 확정되었습니다.",
        deductionAmount,
        orderId
      });
    } catch (err) {
      console.error("Error confirming deduction:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Confirm requester refund (환불 확정)
  app.patch("/api/admin/incident-reports/:id/confirm-refund", adminAuth, requirePermission("disputes.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const incidentId = parseInt(req.params.id);
      const incident = await storage.getIncidentReport(incidentId);
      
      if (!incident) {
        return res.status(404).json({ message: "사고 접수를 찾을 수 없습니다." });
      }
      
      if (incident.requesterRefundApplied) {
        return res.status(400).json({ message: "이미 환불이 확정되었습니다." });
      }

      const refundAmount = incident.refundAmount || 0;
      const orderId = incident.orderId;
      const requesterId = incident.requesterId;
      const adminUserId = req.user?.id;

      // Create refund record if there's a refund amount
      if (refundAmount > 0 && requesterId) {
        await db.insert(refunds).values({
          orderId: orderId || null,
          incidentId: incidentId,
          requesterId: requesterId,
          amount: refundAmount,
          reason: `화물사고 환불 - ${incident.incidentType || '사고'}: ${incident.description || ''}`.substring(0, 500),
          reasonCategory: 'incident',
          status: 'completed',
          refundMethod: 'bank_transfer',
          requestedBy: adminUserId || null,
          requestedAt: new Date(),
          approvedBy: adminUserId || null,
          approvedAt: new Date(),
          completedAt: new Date(),
        });
        
        console.log(`[Incident Refund] Incident ${incidentId}: Created refund of ${refundAmount}원 for requester ${requesterId}`);
      }
      
      await storage.updateIncidentReport(incidentId, {
        requesterRefundApplied: true,
        refundConfirmedAt: new Date(),
      });
      
      res.json({ 
        message: "요청자 환불이 확정되었습니다.",
        refundAmount,
        requesterId
      });
    } catch (err) {
      console.error("Error confirming refund:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  app.patch("/api/admin/helper-disputes/:id/status", adminAuth, requirePermission("disputes.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { status, resolution, adminReply } = req.body;
      const decoded = (req as any).user;
      
      const dispute = await storage.getDispute(id);
      if (!dispute) {
        return res.status(404).json({ message: "이의제기를 찾을 수 없습니다" });
      }
      
      const updateData: any = { status };
      if (resolution) updateData.resolution = resolution;
      if (adminReply) { updateData.adminReply = adminReply; updateData.adminReplyAt = new Date(); updateData.adminReplyBy = decoded?.userId || null; }
      if (status === "resolved" || status === "rejected") {
        updateData.resolvedAt = new Date();
        updateData.resolvedBy = decoded?.userId || null;
      }
      
      const updated = await storage.updateDispute(id, updateData);
      
      // 헬퍼에게 알림
      if (dispute.helperId) {
        const statusLabel = status === "resolved" ? "해결됨" : 
                           status === "rejected" ? "반려됨" : 
                           status === "reviewing" ? "검토중" : status;
        await storage.createNotification({
          type: "announcement",
          title: "이의제기 상태 변경",
          message: `${dispute.workDate} 작업건 이의제기가 "${statusLabel}"으로 변경되었습니다.${resolution ? ` 결과: ${resolution}` : ""}`,
        });
        
        sendPushToUser(dispute.helperId, {
          title: "이의제기 상태 변경",
          body: `${dispute.workDate} 작업건 이의제기: ${statusLabel}`,
          url: "/work-history",
          tag: `dispute-${id}`,
        });
      }
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Dashboard Charts API - 대시보드 그래프 데이터
  app.get("/api/admin/dashboard/charts", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const [orders, courierSettingsList, users, incidents] = await Promise.all([
        storage.getOrders(),
        storage.getAllCourierSettings(),
        storage.getAllUsers(),
        storage.getAllIncidentReports(),
      ]);
      const today = new Date();
      const dailyOrders: { date: string; count: number }[] = [];
      for (let i = 13; i >= 0; i--) {
        const d = new Date(today);
        d.setDate(d.getDate() - i);
        const dateStr = d.toISOString().split("T")[0];
        const count = orders.filter(o => o.scheduledDate === dateStr).length;
        dailyOrders.push({ date: dateStr.slice(5), count });
      }
      const monthlyOrders: { month: string; count: number }[] = [];
      for (let i = 5; i >= 0; i--) {
        const d = new Date(today.getFullYear(), today.getMonth() - i, 1);
        const year = d.getFullYear();
        const month = d.getMonth() + 1;
        const count = orders.filter(o => {
          if (!o.scheduledDate) return false;
          const orderDate = new Date(o.scheduledDate);
          return orderDate.getFullYear() === year && orderDate.getMonth() + 1 === month;
        }).length;
        monthlyOrders.push({ month: `${year}.${String(month).padStart(2, "0")}`, count });
      }
      const categoryMap: Record<string, string> = {};
      courierSettingsList.forEach((c: any) => {
        categoryMap[c.courierName] = c.category || "parcel";
      });
      const categoryCounts = { parcel: 0, other: 0, cold: 0 };
      orders.forEach(o => {
        const category = categoryMap[o.courierName || ""] || "parcel";
        if (category === "parcel") categoryCounts.parcel++;
        else if (category === "other") categoryCounts.other++;
        else if (category === "cold") categoryCounts.cold++;
      });
      const categoryData = [
        { name: "택배사", value: categoryCounts.parcel, color: "#3b82f6" },
        { name: "기타택배", value: categoryCounts.other, color: "#10b981" },
        { name: "냉탑전용", value: categoryCounts.cold, color: "#8b5cf6" },
      ];
      const courierCounts: Record<string, number> = {};
      orders.forEach(o => {
        if (o.courierName) {
          courierCounts[o.courierName] = (courierCounts[o.courierName] || 0) + 1;
        }
      });
      const courierData = Object.entries(courierCounts)
        .map(([name, count]) => ({ name, count }))
        .sort((a, b) => b.count - a.count)
        .slice(0, 10);
      const sevenDaysAgo = new Date(today);
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
      const realtimeOrders = orders.filter(o => 
        ["open", "awaiting_deposit", "scheduled", "in_progress"].includes(o.status || "")
      ).length;
      const newHelpers = users.filter(u => {
        if (u.role !== "helper" || !u.createdAt) return false;
        return new Date(u.createdAt) >= sevenDaysAgo;
      }).length;
      const newMembers = users.filter(u => {
        if (!u.createdAt) return false;
        return new Date(u.createdAt) >= sevenDaysAgo;
      }).length;
      const openDisputes = incidents.filter(i => 
        !["closed", "resolved"].includes(i.status || "")
      ).length;
      res.json({
        dailyOrders,
        monthlyOrders,
        categoryData,
        courierData,
        realtime: {
          activeOrders: realtimeOrders,
          newHelpers,
          newMembers,
          openDisputes,
        },
      });
    } catch (err) {
      console.error("Dashboard charts error:", err);
      res.status(500).json({ message: "대시보드 차트 데이터 조회에 실패했습니다." });
    }
  });


  // Dashboard KPI (admin)
  app.get("/api/admin/dashboard/kpi", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const [orders, contracts, payments, settlements, incidents] = await Promise.all([
        storage.getOrders(),
        storage.getAllContracts(),
        storage.getAllPayments(),
        storage.getAllSettlementStatements(),
        storage.getAllIncidentReports(),
      ]);
      
      const today = new Date().toISOString().split("T")[0];
      const todayOrders = orders.filter(o => o.scheduledDate === today);
      const matchedOrders = orders.filter(o => o.status === "matched" || o.status === "closed");
      const matchRate = orders.length > 0 ? Math.round((matchedOrders.length / orders.length) * 100) : 0;
      
      const completedContracts = contracts.filter(c => c.status === "completed");
      const totalRevenue = completedContracts.reduce((sum, c) => sum + (c.totalAmount || 0), 0);
      
      const depositUnpaid = contracts.filter(c => !c.depositPaidAt);
      const balanceOverdue = contracts.filter(c => {
        if (!c.balanceDueDate || c.balancePaidAt) return false;
        return new Date(c.balanceDueDate) < new Date();
      });
      const balanceDueSoon = contracts.filter(c => {
        if (!c.balanceDueDate || c.balancePaidAt) return false;
        const dueDate = new Date(c.balanceDueDate);
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        return dueDate <= tomorrow && dueDate >= new Date();
      });
      
      const openDisputes = incidents.filter(i => i.status !== "closed" && i.status !== "resolved");
      
      res.json({
        ordersToday: todayOrders.length,
        matchRate,
        completedCount: completedContracts.length,
        totalRevenue,
        depositUnpaidCount: depositUnpaid.length,
        balanceOverdueCount: balanceOverdue.length,
        balanceDueSoonCount: balanceDueSoon.length,
        disputeOpenCount: openDisputes.length,
      });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Dashboard alerts - 대시보드 알림/경고 (분쟁, 연체, 직거래 의심 등)
  app.get("/api/admin/dashboard/alerts", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const [contracts, incidents, orders] = await Promise.all([
        storage.getAllContracts(),
        storage.getAllIncidentReports(),
        storage.getOrders(),
      ]);
      
      const alerts: Array<{
        id: number;
        type: "overdue" | "dispute" | "direct_trade" | "no_show";
        title: string;
        description: string;
        createdAt: string;
        priority: "high" | "medium" | "low";
      }> = [];
      
      let alertId = 1;
      
      // 연체 결제 알림 (잔금 미결제)
      const overdueContracts = contracts.filter(c => {
        if (!c.balanceDueDate || c.balancePaid) return false;
        return new Date(c.balanceDueDate) < new Date();
      });
      
      for (const c of overdueContracts) {
        const order = orders.find(o => o.id === c.orderId);
        alerts.push({
          id: alertId++,
          type: "overdue",
          title: "잔금 결제 연체",
          description: `오더 #${c.orderId} (${order?.companyName || "회사명 없음"}) - 잔금 ₩${c.balanceAmount?.toLocaleString()} 연체`,
          createdAt: c.balanceDueDate || new Date().toISOString(),
          priority: "high",
        });
      }
      
      // 미처리 분쟁 알림
      const openDisputes = incidents.filter(i => i.status !== "closed" && i.status !== "resolved");
      for (const d of openDisputes) {
        alerts.push({
          id: alertId++,
          type: "dispute",
          title: "분쟁 처리 필요",
          description: `분쟁 #${d.id} - ${d.incidentType || "유형 미정"} (${d.status})`,
          createdAt: d.createdAt?.toISOString() || new Date().toISOString(),
          priority: d.status === "open" || d.status === "received" ? "high" : "medium",
        });
      }
      
      // 노쇼 알림 (당일 예정 오더 중 매칭 안된 것)
      const today = new Date().toISOString().split("T")[0];
      const unmatchedToday = orders.filter(o => 
        o.scheduledDate === today && 
        (o.status === "open" || o.status === "pending")
      );
      
      for (const o of unmatchedToday) {
        alerts.push({
          id: alertId++,
          type: "no_show",
          title: "당일 미매칭 오더",
          description: `오더 #${o.id} - ${o.companyName || "회사명 없음"} (당일 매칭 필요)`,
          createdAt: o.createdAt?.toISOString() || new Date().toISOString(),
          priority: "high",
        });
      }
      
      // 정렬: priority high > medium > low, then by createdAt desc
      const priorityOrder = { high: 0, medium: 1, low: 2 };
      alerts.sort((a, b) => {
        if (priorityOrder[a.priority] !== priorityOrder[b.priority]) {
          return priorityOrder[a.priority] - priorityOrder[b.priority];
        }
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
      });
      
      // 최대 50개까지만 반환 (페이지네이션)
      const limitedAlerts = alerts.slice(0, 50);
      res.json(limitedAlerts);
    } catch (err) {
      console.error("dashboard alerts error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Tiered pricing CRUD - 택배사별 구간 요금 관리
  app.get("/api/admin/tiered-pricing", adminAuth, requirePermission("pricing.view"), async (req, res) => {
    try {
      const tiers = await storage.getAllCourierTieredPricing();
      res.json(tiers);
    } catch (err) {
      console.error("tiered pricing list error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/tiered-pricing", adminAuth, requirePermission("pricing.edit"), async (req, res) => {
    try {
      const { courierId, minBoxCount, maxBoxCount, minTotalVatInclusive, description } = req.body;
      if (!courierId || minBoxCount == null || minTotalVatInclusive == null) {
        return res.status(400).json({ message: "필수 필드가 누락되었습니다 (courierId, minBoxCount, minTotalVatInclusive)" });
      }
      
      // Calculate pricePerBox from VAT-inclusive total
      // VAT rate: 10% (divide by 1.1 to get net)
      const netTotal = Math.round(minTotalVatInclusive / 1.1);
      const boxCount = minBoxCount || 1;
      // Round up to nearest 100 won
      const calculatedPricePerBox = Math.ceil(netTotal / boxCount / 100) * 100;
      const calculatedIncrement = 100; // Fixed at ₩100
      
      const tier = await storage.createCourierTieredPricing({
        courierId,
        minBoxCount,
        maxBoxCount: maxBoxCount || null,
        minTotalVatInclusive,
        pricePerBox: calculatedPricePerBox,
        belowMinIncrementPerBox: calculatedIncrement,
        description: description || null,
        isActive: true,
      });
      res.status(201).json(tier);
    } catch (err) {
      console.error("tiered pricing create error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/admin/tiered-pricing/:id", adminAuth, requirePermission("pricing.edit"), async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "유효하지 않은 ID입니다" });
      }
      
      const { minBoxCount, maxBoxCount, minTotalVatInclusive, description } = req.body;
      
      // Calculate pricePerBox from VAT-inclusive total if provided
      let calculatedPricePerBox: number | undefined;
      let calculatedIncrement: number | undefined;
      
      if (minTotalVatInclusive != null && minBoxCount != null) {
        const netTotal = Math.round(minTotalVatInclusive / 1.1);
        const boxCount = minBoxCount || 1;
        calculatedPricePerBox = Math.ceil(netTotal / boxCount / 100) * 100;
        calculatedIncrement = 100;
      }
      
      const tier = await storage.updateCourierTieredPricing(id, {
        minBoxCount,
        maxBoxCount,
        minTotalVatInclusive,
        pricePerBox: calculatedPricePerBox,
        belowMinIncrementPerBox: calculatedIncrement,
        description,
      });
      res.json(tier);
    } catch (err) {
      console.error("tiered pricing update error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/admin/tiered-pricing/:id", adminAuth, requirePermission("pricing.edit"), async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.deleteCourierTieredPricing(id);
      res.json({ success: true });
    } catch (err) {
      console.error("tiered pricing delete error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Send notification (admin push notification)
  app.post("/api/admin/send-notification", adminAuth, requirePermission("notifications.send"), async (req, res) => {
    try {
      const { message, target, userIds } = req.body;
      
      let targetUsers: any[] = [];
      
      if (userIds && userIds.length > 0) {
        targetUsers = await Promise.all(userIds.map((id: string) => storage.getUser(id)));
        targetUsers = targetUsers.filter(Boolean);
      } else {
        const allUsers = await storage.getAllUsers();
        if (target === "helpers") {
          targetUsers = allUsers.filter(u => u.role === "helper");
        } else if (target === "requesters") {
          targetUsers = allUsers.filter(u => u.role === "requester");
        } else {
          targetUsers = allUsers;
        }
      }
      
      const notifications = await Promise.all(
        targetUsers.map((user) =>
          storage.createNotification({
            userId: user.id,
            type: "announcement",
            title: "관리자 알림",
            message,
          })
        )
      );
      
      res.json({ sent: notifications.length, message: "Notifications sent" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Send settlement email to helper
  app.post("/api/admin/helpers/:helperId/settlement-email", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const { helperId } = req.params;
      const { month, year, isRevised } = req.body;
      
      if (!month || !year || typeof month !== 'number' || typeof year !== 'number' || 
          month < 1 || month > 12 || year < 2020 || year > 2100) {
        return res.status(400).json({ message: "Invalid month or year" });
      }
      
      const helper = await storage.getUser(helperId);
      if (!helper) {
        return res.status(404).json({ message: "Helper not found" });
      }
      
      if (!helper.email) {
        return res.status(400).json({ message: "Helper has no email address" });
      }
      
      const allSettlements = await storage.getAllSettlementStatements();
      const monthSettlements = allSettlements.filter((s: SettlementStatement) => {
        if (s.helperId !== helperId) return false;
        if (!s.workDate) return false;
        const workDate = new Date(s.workDate as string | Date);
        if (isNaN(workDate.getTime())) return false;
        return workDate.getMonth() + 1 === month && workDate.getFullYear() === year;
      });
      
      if (monthSettlements.length === 0) {
        return res.status(400).json({ message: "해당 월에 정산 내역이 없습니다." });
      }
      
      const allOrders = await storage.getAllHelpPosts();
      
      const settlementDetails = monthSettlements.map((s: SettlementStatement) => {
        const order = s.orderId ? allOrders.find(o => o.id === s.orderId) : null;
        const workDate = new Date(s.workDate as string | Date);
        return {
          workDate: `${workDate.getMonth() + 1}/${workDate.getDate()}`,
          orderTitle: order?.title || s.orderId?.toString() || '-',
          deliveryCount: s.deliveryCount || 0,
          returnCount: s.returnCount || 0,
          pickupCount: s.pickupCount || 0,
          otherCount: s.otherCount || 0,
          supplyAmount: s.supplyAmount || 0,
          vatAmount: s.vatAmount || 0,
          totalAmount: s.totalAmount || 0,
          commissionAmount: s.commissionAmount || 0,
          netAmount: s.netAmount || 0,
        };
      });
      
      const summary = {
        totalDeliveryCount: monthSettlements.reduce((sum: number, s: SettlementStatement) => sum + (s.deliveryCount || 0), 0),
        totalReturnCount: monthSettlements.reduce((sum: number, s: SettlementStatement) => sum + (s.returnCount || 0), 0),
        totalPickupCount: monthSettlements.reduce((sum: number, s: SettlementStatement) => sum + (s.pickupCount || 0), 0),
        totalOtherCount: monthSettlements.reduce((sum: number, s: SettlementStatement) => sum + (s.otherCount || 0), 0),
        totalSupplyAmount: monthSettlements.reduce((sum: number, s: SettlementStatement) => sum + (s.supplyAmount || 0), 0),
        totalVatAmount: monthSettlements.reduce((sum: number, s: SettlementStatement) => sum + (s.vatAmount || 0), 0),
        grandTotalAmount: monthSettlements.reduce((sum: number, s: SettlementStatement) => sum + (s.totalAmount || 0), 0),
        totalCommission: monthSettlements.reduce((sum: number, s: SettlementStatement) => sum + (s.commissionAmount || 0), 0),
        totalNetAmount: monthSettlements.reduce((sum: number, s: SettlementStatement) => sum + (s.netAmount || 0), 0),
        commissionRate: monthSettlements[0]?.commissionRate || 10,
      };
      
      const { generateSettlementEmailHtml, generateSettlementEmailSubject } = await import("./templates/settlement-email");
      
      const emailHtml = generateSettlementEmailHtml({
        year,
        month,
        settlements: settlementDetails,
        summary,
        isRevised: isRevised || false,
      });
      
      const revisionSuffix = isRevised ? ' (수정본)' : ' (1차)';
      const subject = `[헬프미] ${year}년 ${month}월 정산서${revisionSuffix}`;
      
      const smtpHostSetting = await storage.getSystemSetting("smtp_host");
      const smtpPortSetting = await storage.getSystemSetting("smtp_port");
      const smtpUserSetting = await storage.getSystemSetting("smtp_user");
      const smtpPassSetting = await storage.getSystemSetting("smtp_password");
      const smtpFromSetting = await storage.getSystemSetting("smtp_from_email");
      
      const smtpHost = smtpHostSetting?.settingValue;
      const smtpPort = smtpPortSetting?.settingValue;
      const smtpUser = smtpUserSetting?.settingValue;
      const smtpPass = smtpPassSetting?.settingValue;
      const smtpFrom = smtpFromSetting?.settingValue;
      
      if (smtpHost && smtpUser && smtpPass) {
        const nodemailer = await import("nodemailer");
        const transporter = nodemailer.createTransport({
          host: smtpHost,
          port: parseInt(smtpPort || "587"),
          secure: smtpPort === "465",
          auth: {
            user: smtpUser,
            pass: smtpPass,
          },
        });
        
        await transporter.sendMail({
          from: smtpFrom || smtpUser,
          to: helper.email,
          subject,
          html: emailHtml,
        });
        
        console.log(`[Settlement Email] Sent to ${helper.email}`);
        res.json({ 
          success: true, 
          message: "정산서가 이메일로 발송되었습니다.",
          data: {
            email: helper.email,
            period: `${year}년 ${month}월`,
            settlementCount: monthSettlements.length,
            totalNetAmount: summary.totalNetAmount,
          }
        });
      } else {
        console.log(`[Settlement Email] SMTP not configured, logging email content`);
        console.log(`  To: ${helper.email}`);
        console.log(`  Subject: ${subject}`);
        console.log(`  Period: ${year}년 ${month}월`);
        console.log(`  Settlements: ${monthSettlements.length}건`);
        console.log(`  Total Net: ${summary.totalNetAmount}원`);
        
        res.json({ 
          success: true, 
          message: "SMTP 설정이 없어 이메일 발송을 시뮬레이션했습니다. 관리자 설정에서 SMTP를 구성해주세요.",
          data: {
            email: helper.email,
            period: `${year}년 ${month}월`,
            settlementCount: monthSettlements.length,
            totalNetAmount: summary.totalNetAmount,
            smtpConfigured: false,
          }
        });
      }
    } catch (err) {
      console.error("Settlement email error:", err);
      res.status(500).json({ message: "정산서 이메일 발송에 실패했습니다." });
    }
  });

  // Batch send settlement emails to all helpers with settlements in a month
  app.post("/api/admin/settlements/batch-send-emails", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const { month, year, isRevised } = req.body;
      
      if (!month || !year || typeof month !== 'number' || typeof year !== 'number' || 
          month < 1 || month > 12 || year < 2020 || year > 2100) {
        return res.status(400).json({ message: "Invalid month or year" });
      }
      
      const allSettlements = await storage.getAllSettlementStatements();
      const monthSettlements = allSettlements.filter((s: SettlementStatement) => {
        if (!s.workDate) return false;
        const workDate = new Date(s.workDate as string | Date);
        if (isNaN(workDate.getTime())) return false;
        return workDate.getMonth() + 1 === month && workDate.getFullYear() === year;
      });
      
      if (monthSettlements.length === 0) {
        return res.status(400).json({ message: "해당 월에 정산 내역이 없습니다." });
      }
      
      // Group settlements by helperId
      const helperSettlements = new Map<string, SettlementStatement[]>();
      for (const s of monthSettlements) {
        if (!s.helperId) continue;
        const existing = helperSettlements.get(s.helperId) || [];
        existing.push(s);
        helperSettlements.set(s.helperId, existing);
      }
      
      const allOrders = await storage.getAllHelpPosts();
      const { generateSettlementEmailHtml } = await import("./templates/settlement-email");
      
      // Get SMTP settings
      const smtpHostSetting = await storage.getSystemSetting("smtp_host");
      const smtpPortSetting = await storage.getSystemSetting("smtp_port");
      const smtpUserSetting = await storage.getSystemSetting("smtp_user");
      const smtpPassSetting = await storage.getSystemSetting("smtp_password");
      const smtpFromSetting = await storage.getSystemSetting("smtp_from_email");
      
      const smtpHost = smtpHostSetting?.settingValue;
      const smtpPort = smtpPortSetting?.settingValue;
      const smtpUser = smtpUserSetting?.settingValue;
      const smtpPass = smtpPassSetting?.settingValue;
      const smtpFrom = smtpFromSetting?.settingValue;
      
      let transporter: any = null;
      if (smtpHost && smtpUser && smtpPass) {
        const nodemailer = await import("nodemailer");
        transporter = nodemailer.createTransport({
          host: smtpHost,
          port: parseInt(smtpPort || "587"),
          secure: smtpPort === "465",
          auth: { user: smtpUser, pass: smtpPass },
        });
      }
      
      const results: Array<{ helperId: string; helperName: string; email: string; success: boolean; error?: string }> = [];
      
      for (const [helperId, settlements] of Array.from(helperSettlements)) {
        const helper = await storage.getUser(helperId);
        if (!helper) {
          results.push({ helperId, helperName: "-", email: "-", success: false, error: "Helper not found" });
          continue;
        }
        if (!helper.email) {
          results.push({ helperId, helperName: helper.name || helperId, email: "-", success: false, error: "No email address" });
          continue;
        }
        
        const settlementDetails = settlements.map((s: SettlementStatement) => {
          const order = s.orderId ? allOrders.find(o => o.id === s.orderId) : null;
          const workDate = new Date(s.workDate as string | Date);
          return {
            workDate: `${workDate.getMonth() + 1}/${workDate.getDate()}`,
            orderTitle: order?.title || s.orderId?.toString() || '-',
            deliveryCount: s.deliveryCount || 0,
            returnCount: s.returnCount || 0,
            pickupCount: s.pickupCount || 0,
            otherCount: s.otherCount || 0,
            supplyAmount: s.supplyAmount || 0,
            vatAmount: s.vatAmount || 0,
            totalAmount: s.totalAmount || 0,
            commissionAmount: s.commissionAmount || 0,
            netAmount: s.netAmount || 0,
          };
        });
        
        const summary = {
          totalDeliveryCount: settlements.reduce((sum: number, s: SettlementStatement) => sum + (s.deliveryCount || 0), 0),
          totalReturnCount: settlements.reduce((sum: number, s: SettlementStatement) => sum + (s.returnCount || 0), 0),
          totalPickupCount: settlements.reduce((sum: number, s: SettlementStatement) => sum + (s.pickupCount || 0), 0),
          totalOtherCount: settlements.reduce((sum: number, s: SettlementStatement) => sum + (s.otherCount || 0), 0),
          totalSupplyAmount: settlements.reduce((sum: number, s: SettlementStatement) => sum + (s.supplyAmount || 0), 0),
          totalVatAmount: settlements.reduce((sum: number, s: SettlementStatement) => sum + (s.vatAmount || 0), 0),
          grandTotalAmount: settlements.reduce((sum: number, s: SettlementStatement) => sum + (s.totalAmount || 0), 0),
          totalCommission: settlements.reduce((sum: number, s: SettlementStatement) => sum + (s.commissionAmount || 0), 0),
          totalNetAmount: settlements.reduce((sum: number, s: SettlementStatement) => sum + (s.netAmount || 0), 0),
          commissionRate: settlements[0]?.commissionRate || 10,
        };
        
        const emailHtml = generateSettlementEmailHtml({
          year,
          month,
          settlements: settlementDetails,
          summary,
          isRevised: isRevised || false,
        });
        
        const revisionSuffix = isRevised ? ' (수정본)' : ' (1차)';
        const subject = `[헬프미] ${year}년 ${month}월 정산서${revisionSuffix}`;
        
        try {
          if (transporter) {
            await transporter.sendMail({
              from: smtpFrom || smtpUser,
              to: helper.email,
              subject,
              html: emailHtml,
            });
            console.log(`[Batch Settlement Email] Sent to ${helper.email}`);
            results.push({ helperId, helperName: helper.name || helperId, email: helper.email, success: true });
          } else {
            console.log(`[Batch Settlement Email] SMTP not configured, skipped for ${helper.email}`);
            results.push({ helperId, helperName: helper.name || helperId, email: helper.email, success: false, error: "SMTP 미설정 - 이메일 발송 불가" });
          }
        } catch (emailErr: any) {
          console.error(`[Batch Settlement Email] Failed for ${helper.email}:`, emailErr);
          results.push({ helperId, helperName: helper.name || helperId, email: helper.email, success: false, error: emailErr.message });
        }
      }
      
      const successCount = results.filter(r => r.success).length;
      const failCount = results.filter(r => !r.success).length;
      
      res.json({
        success: true,
        message: `${successCount}명에게 정산서 발송 완료, ${failCount}명 실패`,
        data: {
          period: `${year}년 ${month}월`,
          totalHelpers: results.length,
          successCount,
          failCount,
          results,
        }
      });
    } catch (err) {
      console.error("Batch settlement email error:", err);
      res.status(500).json({ message: "일괄 정산서 발송에 실패했습니다." });
    }
  });

  // ===== Settlement Excel Download (CSV) =====
  app.get("/api/admin/settlements/export", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const { month, year, status } = req.query;
      
      let settlements = await storage.getAllSettlementStatements();
      
      if (month && year) {
        const m = parseInt(month as string);
        const y = parseInt(year as string);
        settlements = settlements.filter((s: SettlementStatement) => {
          if (!s.workDate) return false;
          const workDate = new Date(s.workDate as string | Date);
          if (isNaN(workDate.getTime())) return false;
          return workDate.getMonth() + 1 === m && workDate.getFullYear() === y;
        });
      }
      
      if (status && status !== "all") {
        settlements = settlements.filter((s: SettlementStatement) => s.status === status);
      }
      
      const allOrders = await storage.getAllHelpPosts();
      const allUsers = await storage.getAllUsers();
      
      const csvHeader = [
        "정산ID", "작업일", "헬퍼ID", "헬퍼명", "오더ID", "배송수", "반품수", "픽업수", "기타",
        "공급가액", "부가세", "총액", "수수료율(%)", "수수료", "본사수수료", "팀장인센티브",
        "차감액", "정산금액", "상태", "확정일", "지급일"
      ].join(",");
      
      const csvRows = settlements.map((s: SettlementStatement) => {
        const helper = allUsers.find(u => u.id === s.helperId);
        const order = allOrders.find(o => o.id === s.orderId);
        const workDateStr = s.workDate ? new Date(s.workDate as string | Date).toISOString().split("T")[0] : "";
        const confirmedAtStr = s.helperConfirmedAt ? new Date(s.helperConfirmedAt).toISOString().split("T")[0] : "";
        
        return [
          s.id,
          workDateStr,
          (helper?.name || "").replace(/,/g, " "),
          s.orderId || "",
          s.deliveryCount || 0,
          s.returnCount || 0,
          s.pickupCount || 0,
          s.otherCount || 0,
          s.supplyAmount || 0,
          s.vatAmount || 0,
          s.totalAmount || 0,
          s.commissionRate || 0,
          s.commissionAmount || 0,
          s.platformCommission || 0,
          s.teamLeaderIncentive || 0,
          s.deduction || 0,
          s.netAmount || 0,
          s.status || "",
          confirmedAtStr,
          s.status === "paid" ? confirmedAtStr : ""
        ].join(",");
      });
      
      const csvContent = [csvHeader, ...csvRows].join("\n");
      const BOM = "\uFEFF";
      
      res.setHeader("Content-Type", "text/csv; charset=utf-8");
      res.setHeader("Content-Disposition", `attachment; filename="settlements_${year || 'all'}_${month || 'all'}.csv"`);
      res.send(BOM + csvContent);
    } catch (err) {
      console.error("Settlement export error:", err);
      res.status(500).json({ message: "정산 내역 내보내기에 실패했습니다." });
    }
  });

  // ===== Enhanced KPI Dashboard Stats =====
  app.get("/api/admin/dashboard/stats", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const [orders, contracts, payments, settlements, users, incidents] = await Promise.all([
        storage.getOrders(),
        storage.getAllContracts(),
        storage.getAllPayments(),
        storage.getAllSettlementStatements(),
        storage.getAllUsers(),
        storage.getAllIncidentReports(),
      ]);
      
      const today = new Date();
      const todayStr = today.toISOString().split("T")[0];
      const thisMonth = today.getMonth() + 1;
      const thisYear = today.getFullYear();
      const lastMonth = thisMonth === 1 ? 12 : thisMonth - 1;
      const lastMonthYear = thisMonth === 1 ? thisYear - 1 : thisYear;
      
      // 오더 통계
      const todayOrders = orders.filter(o => o.scheduledDate === todayStr);
      const thisMonthOrders = orders.filter(o => {
        if (!o.scheduledDate) return false;
        const d = new Date(o.scheduledDate);
        return d.getMonth() + 1 === thisMonth && d.getFullYear() === thisYear;
      });
      const matchedOrders = orders.filter(o => ["matched", "in_progress", "closing_submitted", "final_amount_confirmed", "balance_paid", "settlement_paid", "closed"].includes(o.status || ""));
      const matchRate = orders.length > 0 ? Math.round((matchedOrders.length / orders.length) * 100) : 0;
      
      // 결제 통계
      const successfulPayments = payments.filter(p => p.status === "completed" || p.status === "paid");
      const failedPayments = payments.filter(p => p.status === "failed");
      const paymentSuccessRate = payments.length > 0 ? Math.round((successfulPayments.length / payments.length) * 100) : 0;
      
      const thisMonthPayments = successfulPayments.filter(p => {
        if (!p.createdAt) return false;
        const d = new Date(p.createdAt);
        return d.getMonth() + 1 === thisMonth && d.getFullYear() === thisYear;
      });
      const thisMonthRevenue = thisMonthPayments.reduce((sum, p) => sum + (p.amount || 0), 0);
      
      const lastMonthPayments = successfulPayments.filter(p => {
        if (!p.createdAt) return false;
        const d = new Date(p.createdAt);
        return d.getMonth() + 1 === lastMonth && d.getFullYear() === lastMonthYear;
      });
      const lastMonthRevenue = lastMonthPayments.reduce((sum, p) => sum + (p.amount || 0), 0);
      const revenueGrowth = lastMonthRevenue > 0 ? Math.round(((thisMonthRevenue - lastMonthRevenue) / lastMonthRevenue) * 100) : 0;
      
      // 정산 통계
      const confirmedSettlements = settlements.filter((s: SettlementStatement) => s.status === "confirmed" || s.status === "paid");
      const pendingSettlements = settlements.filter((s: SettlementStatement) => s.status === "pending");
      const holdSettlements = settlements.filter((s: SettlementStatement) => s.isOnHold);
      const settlementCompletionRate = settlements.length > 0 ? Math.round((confirmedSettlements.length / settlements.length) * 100) : 0;
      
      // 사용자 통계
      const helpers = users.filter(u => u.role === "helper");
      const requesters = users.filter(u => u.role === "requester");
      const activeHelpers = helpers.filter(h => {
        const hasRecentOrder = orders.some(o => {
          if (!o.scheduledDate) return false;
          const orderDate = new Date(o.scheduledDate);
          const thirtyDaysAgo = new Date();
          thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
          return orderDate >= thirtyDaysAgo;
        });
        return hasRecentOrder;
      });
      
      // 분쟁 통계
      const openDisputes = incidents.filter(i => !["closed", "resolved"].includes(i.status || ""));
      const resolvedDisputes = incidents.filter(i => ["closed", "resolved"].includes(i.status || ""));
      const disputeResolutionRate = incidents.length > 0 ? Math.round((resolvedDisputes.length / incidents.length) * 100) : 0;
      
      // 연체 통계
      const overdueContracts = contracts.filter(c => {
        if (!c.balanceDueDate || c.balancePaid) return false;
        return new Date(c.balanceDueDate) < today;
      });
      const overdueAmount = overdueContracts.reduce((sum, c) => sum + (c.balanceAmount || 0), 0);
      
      res.json({
        orders: {
          today: todayOrders.length,
          thisMonth: thisMonthOrders.length,
          total: orders.length,
          matchRate,
        },
        payments: {
          successRate: paymentSuccessRate,
          thisMonthRevenue,
          lastMonthRevenue,
          revenueGrowth,
          failedCount: failedPayments.length,
        },
        settlements: {
          pending: pendingSettlements.length,
          confirmed: confirmedSettlements.length,
          onHold: holdSettlements.length,
          completionRate: settlementCompletionRate,
        },
        users: {
          totalHelpers: helpers.length,
          totalRequesters: requesters.length,
          activeHelpers: activeHelpers.length,
        },
        disputes: {
          open: openDisputes.length,
          resolved: resolvedDisputes.length,
          resolutionRate: disputeResolutionRate,
        },
        overdue: {
          contractCount: overdueContracts.length,
          totalAmount: overdueAmount,
        },
        generatedAt: new Date().toISOString(),
      });
    } catch (err) {
      console.error("Dashboard stats error:", err);
      res.status(500).json({ message: "대시보드 통계 조회에 실패했습니다." });
    }
  });

  // ===== Payment Intent APIs =====
  app.post("/api/admin/payment-intents", adminAuth, requirePermission("payments.create"), async (req, res) => {
    try {
      const { orderId, contractId, payerId, payerRole, paymentType, amount } = req.body;
      
      if (!payerId || !paymentType || !amount) {
        return res.status(400).json({ message: "필수 정보가 누락되었습니다." });
      }
      
      const idempotencyKey = `${orderId || 'no-order'}-${paymentType}-${Date.now()}`;
      
      res.json({
        id: Date.now(),
        orderId,
        contractId,
        payerId,
        payerRole: payerRole || "requester",
        paymentType,
        amount,
        status: "created",
        idempotencyKey,
        createdAt: new Date().toISOString(),
      });
    } catch (err) {
      res.status(500).json({ message: "결제 Intent 생성에 실패했습니다." });
    }
  });
  
  app.get("/api/admin/payment-intents", adminAuth, requirePermission("payments.view"), async (req, res) => {
    try {
      res.json([]);
    } catch (err) {
      res.status(500).json({ message: "결제 Intent 조회에 실패했습니다." });
    }
  });

  // ===== Missing Admin API Endpoints (T-44) =====
  
  // Customer inquiries (CS tickets)
  app.get("/api/admin/customer-inquiries", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const { status, priority, category, limit = "50", offset = "0" } = req.query;
      let query = db.select().from(customerInquiries).orderBy(desc(customerInquiries.createdAt));
      
      const conditions: any[] = [];
      if (status && status !== 'all') conditions.push(eq(customerInquiries.status, status as string));
      if (priority) conditions.push(eq(customerInquiries.priority, priority as string));
      if (category) conditions.push(eq(customerInquiries.category, category as string));
      
      if (conditions.length > 0) {
        query = query.where(and(...conditions)) as any;
      }
      
      const inquiries = await query.limit(parseInt(limit as string)).offset(parseInt(offset as string));
      res.json(inquiries);
    } catch (err) {
      console.error("Get customer inquiries error:", err);
      res.status(500).json({ message: "Failed to fetch customer inquiries" });
    }
  });

  // Ticket escalations
  app.get("/api/admin/ticket-escalations", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const { status, limit = "50" } = req.query;
      let query = db.select().from(ticketEscalations).orderBy(desc(ticketEscalations.createdAt));
      
      if (status && status !== 'all') {
        query = query.where(eq(ticketEscalations.status, status as string)) as any;
      }
      
      const escalations = await query.limit(parseInt(limit as string));
      res.json(escalations);
    } catch (err) {
      console.error("Get ticket escalations error:", err);
      res.status(500).json({ message: "Failed to fetch ticket escalations" });
    }
  });

  // Minimum guarantee applications
  app.get("/api/admin/minimum-guarantee-applications", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const apps = await db.select().from(minimumGuaranteeApplications).orderBy(desc(minimumGuaranteeApplications.createdAt));
      res.json(apps);
    } catch (err) {
      console.error("Get MG applications error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Minimum guarantee rules
  app.get("/api/admin/minimum-guarantee-rules", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const rules = await db.select().from(minimumGuaranteeRules).orderBy(desc(minimumGuaranteeRules.createdAt));
      res.json(rules);
    } catch (err) {
      console.error("Get MG rules error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/minimum-guarantee-rules", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const actorId = (req as any).adminUser?.id;
      const [rule] = await db.insert(minimumGuaranteeRules).values({
        ...req.body,
        createdBy: actorId,
      }).returning();
      res.json(rule);
    } catch (err) {
      console.error("Create MG rule error:", err);
      res.status(500).json({ message: "Failed to create MG rule" });
    }
  });

  app.patch("/api/admin/minimum-guarantee-rules/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const [rule] = await db.update(minimumGuaranteeRules)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(minimumGuaranteeRules.id, parseInt(req.params.id)))
        .returning();
      res.json(rule);
    } catch (err) {
      console.error("Update MG rule error:", err);
      res.status(500).json({ message: "Failed to update MG rule" });
    }
  });

  app.delete("/api/admin/minimum-guarantee-rules/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await db.delete(minimumGuaranteeRules).where(eq(minimumGuaranteeRules.id, parseInt(req.params.id)));
      res.json({ success: true });
    } catch (err) {
      console.error("Delete MG rule error:", err);
      res.status(500).json({ message: "Failed to delete MG rule" });
    }
  });
  // Push messages (notification history)
  app.get("/api/admin/push-messages", adminAuth, requirePermission("notifications.view"), async (req, res) => {
    try {
      const { status, category, limit = "100" } = req.query;
      let query = db.select().from(pushNotificationLogs).orderBy(desc(pushNotificationLogs.createdAt));
      
      const conditions: any[] = [];
      if (status && status !== 'all') conditions.push(eq(pushNotificationLogs.status, status as string));
      if (category) conditions.push(eq(pushNotificationLogs.category, category as string));
      
      if (conditions.length > 0) {
        query = query.where(and(...conditions)) as any;
      }
      
      const messages = await query.limit(parseInt(limit as string));
      res.json(messages);
    } catch (err) {
      console.error("Get push messages error:", err);
      res.status(500).json({ message: "Failed to fetch push messages" });
    }
  });

  // Region pricing rules
  app.get("/api/admin/region-pricing-rules", adminAuth, requirePermission("pricing.view"), async (req, res) => {
    try {
      const rules = await db.select().from(regionPricingRules).orderBy(regionPricingRules.regionName);
      res.json(rules);
    } catch (err) {
      console.error("Get region pricing rules error:", err);
      res.status(500).json({ message: "Failed to fetch region pricing rules" });
    }
  });

  // SMS templates

  // SMS logs
  app.get("/api/admin/sms-logs", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const { status, limit = "100" } = req.query;
      let query = db.select().from(smsLogs).orderBy(desc(smsLogs.createdAt));
      
      if (status && status !== 'all') {
        query = query.where(eq(smsLogs.status, status as string)) as any;
      }
      
      const logs = await query.limit(parseInt(limit as string));
      res.json(logs);
    } catch (err) {
      console.error("Get SMS logs error:", err);
      res.status(500).json({ message: "Failed to fetch SMS logs" });
    }
  });

  // Refunds

  // Integration health - dynamic status check

  // Webhook logs

  // Carrier min rates
  app.get("/api/admin/carrier-min-rates", adminAuth, requirePermission("pricing.view"), async (req, res) => {
    try {
      const rates = await db.select().from(carrierMinRates).orderBy(carrierMinRates.courierCode);
      res.json(rates);
    } catch (err) {
      console.error("Get carrier min rates error:", err);
      res.status(500).json({ message: "Failed to fetch carrier min rates" });
    }
  });

  // Pricing tables
  app.get("/api/admin/pricing-tables", adminAuth, requirePermission("pricing.view"), async (req, res) => {
    try {
      const tables = await db.select().from(pricingTables).orderBy(pricingTables.name);
      res.json(tables);
    } catch (err) {
      console.error("Get pricing tables error:", err);
      res.status(500).json({ message: "Failed to fetch pricing tables" });
    }
  });

  // Document review tasks
  app.get("/api/admin/document-review-tasks", adminAuth, requirePermission("helpers.view"), async (req, res) => {
    try {
      const { status, limit = "50" } = req.query;
      let query = db.select().from(documentReviewTasks).orderBy(desc(documentReviewTasks.createdAt));
      
      if (status && status !== 'all') {
        query = query.where(eq(documentReviewTasks.status, status as string)) as any;
      }
      
      const tasks = await query.limit(parseInt(limit as string));
      res.json(tasks);
    } catch (err) {
      console.error("Get document review tasks error:", err);
      res.status(500).json({ message: "Failed to fetch document review tasks" });
    }
  });

  // Identity verifications
  app.get("/api/admin/identity-verifications", adminAuth, requirePermission("helpers.view"), async (req, res) => {
    try {
      const { status, limit = "50" } = req.query;
      let query = db.select().from(identityVerifications).orderBy(desc(identityVerifications.createdAt));
      
      if (status && status !== 'all') {
        query = query.where(eq(identityVerifications.status, status as string)) as any;
      }
      
      const verifications = await query.limit(parseInt(limit as string));
      res.json(verifications);
    } catch (err) {
      console.error("Get identity verifications error:", err);
      res.status(500).json({ message: "Failed to fetch identity verifications" });
    }
  });

  // Process document review task
  app.post("/api/admin/document-review-tasks/:taskId", adminAuth, requirePermission("helpers.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { taskId } = req.params;
      const { status, reviewedBy, rejectReason } = req.body;
      
      const [updated] = await db.update(documentReviewTasks)
        .set({ 
          status, 
          reviewedBy: req.adminUser?.id,
          reviewedAt: new Date(),
          rejectReason,
          updatedAt: new Date()
        })
        .where(eq(documentReviewTasks.id, parseInt(taskId)))
        .returning();
      
      if (!updated) {
        return res.status(404).json({ message: "Task not found" });
      }
      res.json(updated);
    } catch (err) {
      console.error("Process document review task error:", err);
      res.status(500).json({ message: "Failed to process task" });
    }
  });

  // Process refund
  app.post("/api/admin/refunds/:refundId", adminAuth, requirePermission("payments.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { refundId } = req.params;
      const { status, processedNote } = req.body;
      
      const [updated] = await db.update(refunds)
        .set({ 
          status, 
          processedBy: req.adminUser?.id,
          processedAt: new Date(),
          adminNotes: processedNote,
          updatedAt: new Date()
        })
        .where(eq(refunds.id, parseInt(refundId)))
        .returning();
      
      if (!updated) {
        return res.status(404).json({ message: "Refund not found" });
      }
      res.json(updated);
    } catch (err) {
      console.error("Process refund error:", err);
      res.status(500).json({ message: "Failed to process refund" });
    }
  });

  // Deductions list
  app.get("/api/admin/deductions", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const { startDate, endDate, limit = "100" } = req.query;
      let query = db.select().from(settlementRecords)
        .where(and(
          not(isNull(settlementRecords.damageDeduction)),
          gte(settlementRecords.damageDeduction, 1)
        ))
        .orderBy(desc(settlementRecords.createdAt));
      
      const deductions = await query.limit(parseInt(limit as string));
      res.json(deductions.map(d => ({
        id: d.id,
        orderId: d.orderId,
        amount: d.damageDeduction,
        reason: d.damageReason,
        settlementApplied: d.status === 'PAID',
        createdAt: d.createdAt
      })));
    } catch (err) {
      console.error("Get deductions error:", err);
      res.status(500).json({ message: "Failed to fetch deductions" });
    }
  });

  // Admin roles
  app.get("/api/admin/roles", adminAuth, requirePermission("staff.view"), async (req, res) => {
    try {
      // Return basic roles list
      const roles = await storage.getAllRoles();
      res.json(roles || []);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ===== Team Management Routes =====
  
  // Admin: Assign/remove team leader role
  app.patch("/api/admin/users/:userId/team-leader", adminAuth, requirePermission("helpers.edit"), async (req, res) => {
    try {
      const { userId } = req.params;
      const { isTeamLeader } = req.body;
      
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "사용자를 찾을 수 없습니다" });
      }
      
      if (user.role !== "helper") {
        return res.status(400).json({ message: "헬퍼만 팀장이 될 수 있습니다" });
      }
      
      const updated = await storage.updateUserRoles(userId, { isTeamLeader });
      
      // If becoming team leader, create a team for them
      if (isTeamLeader) {
        const existingTeam = await storage.getTeamByLeader(userId);
        if (!existingTeam) {
          const { randomUUID } = await import("crypto");
          await storage.createTeam({
            leaderId: userId,
            name: `${user.name}팀`,
            qrCodeToken: randomUUID(),
            isActive: true,
          });
        }
      }
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: Assign/remove HQ staff role
  app.patch("/api/admin/users/:userId/hq-staff", adminAuth, requirePermission("staff.roles"), async (req, res) => {
    try {
      const { userId } = req.params;
      const { isHqStaff } = req.body;
      
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "사용자를 찾을 수 없습니다" });
      }
      
      const updated = await storage.updateUserRoles(userId, { isHqStaff });
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: Change user role (helper <-> requester) - 고객센터용
  const adminRoleChangeSchema = z.object({
    role: z.enum(["helper", "requester"]),
  });
  
  app.patch("/api/admin/users/:userId/role", adminAuth, requirePermission("helpers.manage"), async (req, res) => {
    try {
      const { userId } = req.params;
      
      const parseResult = adminRoleChangeSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({ message: "유효하지 않은 역할입니다" });
      }
      
      const { role } = parseResult.data;
      
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "사용자를 찾을 수 없습니다" });
      }
      
      if (user.isHqStaff) {
        return res.status(400).json({ message: "관리자의 역할은 변경할 수 없습니다" });
      }
      
      // Generate checkInToken for requesters if needed
      const checkInToken = role === "requester" && !user.checkInToken
        ? randomBytes(32).toString("hex") 
        : user.checkInToken;

      // onboardingStatus 로직:
      // - 요청자로 전환/유지: approved (요청자는 온보딩 불필요)
      // - 헬퍼로 전환 (요청자→헬퍼): pending (헬퍼 온보딩 필요)
      // - 헬퍼 유지 (헬퍼→헬퍼): 기존 상태 유지
      let onboardingStatus: string;
      if (role === "requester") {
        onboardingStatus = "approved";
      } else if (user.role === "helper") {
        onboardingStatus = user.onboardingStatus || "pending";
      } else {
        onboardingStatus = "pending";
      }

      const updated = await storage.updateUser(userId, { 
        role,
        checkInToken,
        onboardingStatus,
      });
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: Get all teams
  app.get("/api/admin/teams", adminAuth, requirePermission("teams.view"), async (req, res) => {
    try {
      const allTeams = await storage.getAllTeams();
      const teamsWithMembers = await Promise.all(
        allTeams.map(async (team) => {
          const members = await storage.getTeamMembers(team.id);
          const leader = await storage.getUser(team.leaderId);
          const commissionOverride = await storage.getTeamCommissionOverride(team.id);
          const memberUsers = await Promise.all(
            members.map(async (m) => {
              const user = await storage.getUser(m.helperId);
              return { ...m, user };
            })
          );
          return { ...team, leader, members: memberUsers, commissionRate: commissionOverride?.commissionRate || 0 };
        })
      );
      res.json(teamsWithMembers);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: Create team
  app.post("/api/admin/teams", adminAuth, requirePermission("teams.create"), async (req, res) => {
    try {
      const { name, leaderId, commissionRate, businessType, emergencyPhone } = req.body;
      
      if (!name || !leaderId) {
        return res.status(400).json({ message: "팀 이름과 팀장을 선택해주세요" });
      }
      
      if (commissionRate === undefined || commissionRate === null || isNaN(Number(commissionRate))) {
        return res.status(400).json({ message: "팀 수수료율을 입력해주세요" });
      }
      
      const rate = Number(commissionRate);
      if (rate < 0 || rate > 15) {
        return res.status(400).json({ message: "수수료율은 0~15% 사이로 입력해주세요" });
      }
      
      // Check if leader exists and is a helper
      const leader = await storage.getUser(leaderId);
      if (!leader || leader.role !== "helper") {
        return res.status(400).json({ message: "유효한 헬퍼를 팀장으로 선택해주세요" });
      }
      
      // Check if leader already has a team
      const existingTeam = await storage.getTeamByLeader(leaderId);
      if (existingTeam) {
        return res.status(400).json({ message: "이미 팀장으로 등록된 헬퍼입니다" });
      }
      
      // Generate QR token
      const qrCodeToken = `TEAM-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      
      // Create team
      const team = await storage.createTeam({
        name,
        leaderId,
        qrCodeToken,
        isActive: true,
        businessType,
        emergencyPhone,
      });
      
      // Set user as team leader
      await storage.updateUserRoles(leaderId, { isTeamLeader: true });
      
      // Always create commission override (validated above)
      await storage.createTeamCommissionOverride({
        teamId: team.id,
        commissionRate: rate,
        notes: `팀 생성 시 설정된 수수료율: ${rate}%`,
      });
      
      res.json({ ...team, leader, commissionRate: commissionRate || 0 });
    } catch (err) {
      console.error("Create team error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: Update team
  app.patch("/api/admin/teams/:teamId", adminAuth, requirePermission("teams.edit"), async (req, res) => {
    try {
      const teamId = Number(req.params.teamId);
      const { name, isActive, commissionRate, businessType, emergencyPhone } = req.body;
      
      const team = await storage.getTeam(teamId);
      if (!team) {
        return res.status(404).json({ message: "팀을 찾을 수 없습니다" });
      }
      
      // Validate commission rate if provided
      if (commissionRate !== undefined) {
        if (commissionRate === null || isNaN(Number(commissionRate))) {
          return res.status(400).json({ message: "유효한 수수료율을 입력해주세요" });
        }
        const rate = Number(commissionRate);
        if (rate < 0 || rate > 15) {
          return res.status(400).json({ message: "수수료율은 0~15% 사이로 입력해주세요" });
        }
      }
      
      // Update team basic info including new fields
      const updatedTeam = await storage.updateTeam(teamId, { 
        name, 
        isActive,
        businessType,
        emergencyPhone,
        commissionRate: commissionRate !== undefined ? Number(commissionRate) : undefined,
      });
      
      // Update commission rate (always update if provided)
      if (commissionRate !== undefined) {
        const rate = Number(commissionRate);
        const existingOverride = await storage.getTeamCommissionOverride(teamId);
        if (existingOverride) {
          await storage.updateTeamCommissionOverride(existingOverride.id, { 
            commissionRate: rate,
            notes: `수수료율 수정: ${rate}%` 
          });
        } else {
          await storage.createTeamCommissionOverride({
            teamId,
            commissionRate: rate,
            notes: `수수료율 설정: ${rate}%`,
          });
        }
      }
      
      const leader = await storage.getUser(updatedTeam.leaderId);
      const finalOverride = await storage.getTeamCommissionOverride(teamId);
      res.json({ ...updatedTeam, leader, commissionRate: finalOverride?.commissionRate || 0 });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== SYSTEM SETTINGS API ====================
  
  // Admin: Get system settings
  app.get("/api/admin/system-settings", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const settings = await storage.getAllSystemSettings();
      const result: Record<string, string> = {};
      for (const s of settings) {
        result[s.settingKey] = s.settingValue;
      }
      res.json(result);
    } catch (err) {
      console.error("Get system settings error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: Update system setting
  app.post("/api/admin/system-settings", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { key, value, description } = req.body;
      if (!key || value === undefined) {
        return res.status(400).json({ message: "key와 value가 필요합니다" });
      }
      const setting = await storage.upsertSystemSetting(key, String(value), description);
      res.json({ success: true, setting });
    } catch (err) {
      console.error("Update system setting error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== COMMISSION POLICIES API ====================
  
  // Admin: Get all commission policies
  app.get("/api/admin/commission-policies", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const policies = await storage.getAllCommissionPolicies();
      res.json(policies);
    } catch (err) {
      console.error("Get commission policies error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: Create or update commission policy (본사/팀장 수수료율 분리)
  app.post("/api/admin/commission-policies", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { policyType, defaultRate, platformRate, teamLeaderRate, description } = req.body;
      
      if (!policyType || !["helper", "team_leader"].includes(policyType)) {
        return res.status(400).json({ message: "정책 유형은 'helper' 또는 'team_leader'여야 합니다" });
      }
      
      // 본사/팀장 수수료율이 제공된 경우 총 수수료율 자동 계산
      let totalRate = Number(defaultRate) || 0;
      let platform = Number(platformRate) || 8;
      let teamLeader = Number(teamLeaderRate) || 2;
      
      // 총 수수료율이 없으면 본사 + 팀장으로 계산
      if (!defaultRate && (platformRate !== undefined || teamLeaderRate !== undefined)) {
        totalRate = platform + teamLeader;
      }
      
      if (totalRate < 0 || totalRate > 100) {
        return res.status(400).json({ message: "총 수수료율은 0~100% 사이여야 합니다" });
      }
      
      if (platform + teamLeader !== totalRate) {
        return res.status(400).json({ message: `본사(${platform}%) + 팀장(${teamLeader}%)가 총 수수료율(${totalRate}%)과 일치해야 합니다` });
      }
      
      const existing = await storage.getCommissionPolicy(policyType);
      const adminUser = (req as any).user;
      
      if (existing) {
        const oldValue = {
          defaultRate: existing.defaultRate,
          platformRate: existing.platformRate,
          teamLeaderRate: existing.teamLeaderRate,
        };
        
        const updated = await storage.updateCommissionPolicy(existing.id, {
          defaultRate: totalRate,
          platformRate: platform,
          teamLeaderRate: teamLeader,
          description,
          modifiedBy: adminUser?.id || null,
        });
        
        // 감사 로그 기록
        await storage.createAuditLog({
          userId: adminUser?.id,
          action: "commission_policy.update",
          targetType: "commission_policy",
          targetId: String(existing.id),
          oldValue: JSON.stringify(oldValue),
          newValue: JSON.stringify({ defaultRate: totalRate, platformRate: platform, teamLeaderRate: teamLeader }),
          ipAddress: req.ip || req.headers["x-forwarded-for"]?.toString() || null,
          userAgent: req.headers["user-agent"] || null,
        });
        
        res.json({ success: true, policy: updated, action: "updated" });
      } else {
        const created = await storage.createCommissionPolicy({
          policyType,
          defaultRate: totalRate,
          platformRate: platform,
          teamLeaderRate: teamLeader,
          description,
          isActive: true,
          modifiedBy: adminUser?.id || null,
        });
        
        // 감사 로그 기록
        await storage.createAuditLog({
          userId: adminUser?.id,
          action: "commission_policy.create",
          targetType: "commission_policy",
          targetId: String(created.id),
          oldValue: null,
          newValue: JSON.stringify({ policyType, defaultRate: totalRate, platformRate: platform, teamLeaderRate: teamLeader }),
          ipAddress: req.ip || req.headers["x-forwarded-for"]?.toString() || null,
          userAgent: req.headers["user-agent"] || null,
        });
        
        res.json({ success: true, policy: created, action: "created" });
      }
    } catch (err) {
      console.error("Create/update commission policy error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: Get all helper commission overrides
  app.get("/api/admin/helper-commission-overrides", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const overrides = await storage.getAllHelperCommissionOverrides();
      const users = await storage.getAllUsers();
      const userMap = new Map(users.map(u => [u.id, u]));
      
      const result = overrides.map(o => ({
        ...o,
        helperName: userMap.get(o.helperId)?.name || "Unknown",
        helperPhone: userMap.get(o.helperId)?.phoneNumber,
      }));
      
      res.json(result);
    } catch (err) {
      console.error("Get helper commission overrides error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: Create or update helper commission override
  app.post("/api/admin/helper-commission-overrides", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { helperId, commissionRate, notes } = req.body;
      
      if (!helperId) {
        return res.status(400).json({ message: "헬퍼 ID를 입력해주세요" });
      }
      
      const rate = Number(commissionRate);
      if (isNaN(rate) || rate < 0 || rate > 100) {
        return res.status(400).json({ message: "수수료율은 0~100% 사이여야 합니다" });
      }
      
      const helper = await storage.getUser(helperId);
      if (!helper) {
        return res.status(404).json({ message: "헬퍼를 찾을 수 없습니다" });
      }
      
      const existing = await storage.getHelperCommissionOverride(helperId);
      if (existing) {
        const updated = await storage.updateHelperCommissionOverride(existing.id, {
          commissionRate: rate,
          notes,
          modifiedBy: (req as any).adminUser?.id || null,
        });
        res.json({ success: true, override: updated, action: "updated" });
      } else {
        const created = await storage.createHelperCommissionOverride({
          commissionRate: rate,
          notes,
          modifiedBy: (req as any).adminUser?.id || null,
        });
        res.json({ success: true, override: created, action: "created" });
      }
    } catch (err) {
      console.error("Create/update helper commission override error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: Delete helper commission override
  app.delete("/api/admin/helper-commission-overrides/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      await storage.deleteHelperCommissionOverride(id);
      res.json({ success: true, message: "헬퍼 수수료 설정이 삭제되었습니다" });
    } catch (err) {
      console.error("Delete helper commission override error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: Get effective commission rate for a helper
  app.get("/api/admin/helpers/:helperId/commission-rate", adminAuth, requirePermission("helpers.view"), async (req, res) => {
    try {
      const { helperId } = req.params;
      const helper = await storage.getUser(helperId);
      if (!helper) {
        return res.status(404).json({ message: "헬퍼를 찾을 수 없습니다" });
      }
      
      const { rate, source } = await storage.getEffectiveCommissionRate(helperId);
      
      res.json({
        helperName: helper.name,
        commissionRate: rate,
        source,
        description: source === "helper" ? "헬퍼 개별 설정" : 
                     source === "team" ? "팀 수수료율" : 
                     source === "global" ? "기본 정책" : "시스템 기본값",
      });
    } catch (err) {
      console.error("Get helper commission rate error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: Delete team
  app.delete("/api/admin/teams/:teamId", adminAuth, requirePermission("teams.delete"), async (req, res) => {
    try {
      const teamId = Number(req.params.teamId);
      const team = await storage.getTeam(teamId);
      if (!team) {
        return res.status(404).json({ message: "팀을 찾을 수 없습니다" });
      }
      
      // Remove team leader role from user
      await storage.updateUserRoles(team.leaderId, { isTeamLeader: false });
      
      await storage.deleteTeam(teamId);
      res.json({ message: "팀이 삭제되었습니다" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: Get team details
  app.get("/api/admin/teams/:teamId", adminAuth, requirePermission("teams.view"), async (req, res) => {
    try {
      const team = await storage.getTeam(Number(req.params.teamId));
      if (!team) {
        return res.status(404).json({ message: "팀을 찾을 수 없습니다" });
      }
      const members = await storage.getTeamMembers(team.id);
      const leader = await storage.getUser(team.leaderId);
      const memberUsers = await Promise.all(
        members.map(async (m) => {
          const user = await storage.getUser(m.helperId);
          return { ...m, user };
        })
      );
      res.json({ ...team, leader, members: memberUsers });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: Get team members (explicit endpoint)
  app.get("/api/admin/teams/:teamId/members", adminAuth, requirePermission("teams.view"), async (req, res) => {
    try {
      const teamId = Number(req.params.teamId);
      const team = await storage.getTeam(teamId);
      if (!team) {
        return res.status(404).json({ message: "팀을 찾을 수 없습니다" });
      }
      const members = await storage.getTeamMembers(teamId);
      const memberUsers = await Promise.all(
        members.map(async (m) => {
          const user = await storage.getUser(m.helperId);
          return {
            id: m.id,
            name: user?.name || "Unknown",
            phoneNumber: user?.phoneNumber,
            email: user?.email,
            dailyStatus: user?.dailyStatus,
            isActive: m.isActive,
            joinedAt: m.joinedAt,
          };
        })
      );
      res.json(memberUsers);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: Regenerate team QR token
  app.post("/api/admin/teams/:teamId/regenerate-qr", adminAuth, requirePermission("teams.qr"), async (req, res) => {
    try {
      const team = await storage.regenerateTeamQrToken(Number(req.params.teamId));
      res.json(team);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Team leader: Get my team (authenticated helper)
  app.get("/api/teams/my-team", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근할 수 있습니다" });
      }
      
      // Check if user is team leader
      if (user.isTeamLeader) {
        const team = await storage.getTeamByLeader(user.id);
        if (team) {
          const members = await storage.getTeamMembers(team.id);
          const commissionOverride = await storage.getTeamCommissionOverride(team.id);
          const memberUsers = await Promise.all(
            members.map(async (m) => {
              const memberUser = await storage.getUser(m.helperId);
              return { ...m, user: memberUser };
            })
          );
          return res.json({ 
            isLeader: true, 
            team: { 
              ...team, 
              members: memberUsers,
              commissionRate: commissionOverride?.commissionRate || 0 
            } 
          });
        }
      }
      
      // Check if user is member of a team
      const teamInfo = await storage.getHelperTeam(user.id);
      if (teamInfo) {
        const leader = await storage.getUser(teamInfo.team.leaderId);
        const commissionOverride = await storage.getTeamCommissionOverride(teamInfo.team.id);
        return res.json({ 
          isLeader: false, 
          team: { 
            ...teamInfo.team, 
            leader,
            commissionRate: commissionOverride?.commissionRate || 0
          }, 
          membership: teamInfo.membership 
        });
      }
      
      res.json({ isLeader: false, team: null });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper: Join team via QR token
  app.post("/api/teams/join", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const { qrToken } = req.body;
      if (!qrToken) {
        return res.status(400).json({ message: "QR 토큰이 필요합니다" });
      }
      
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 팀에 가입할 수 있습니다" });
      }
      
      // Team leaders cannot join other teams
      if (user.isTeamLeader) {
        return res.status(400).json({ message: "팀장은 다른 팀에 가입할 수 없습니다" });
      }
      
      // Check if already in a team
      const existingTeam = await storage.getHelperTeam(user.id);
      if (existingTeam) {
        return res.status(400).json({ message: "이미 팀에 가입되어 있습니다. 먼저 현재 팀에서 탈퇴해주세요" });
      }
      
      const team = await storage.getTeamByToken(qrToken);
      if (!team) {
        return res.status(404).json({ message: "유효하지 않은 QR 코드입니다" });
      }
      
      if (!team.isActive) {
        return res.status(400).json({ message: "이 팀은 현재 활성화되어 있지 않습니다" });
      }
      
      // Add to team
      const membership = await storage.addTeamMember({
        teamId: team.id,
        helperId: user.id,
        isActive: true,
      });
      
      const leader = await storage.getUser(team.leaderId);
      
      res.json({ message: "팀에 가입되었습니다", team: { ...team, leader }, membership });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper: Leave team
  app.post("/api/teams/leave", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근할 수 있습니다" });
      }
      
      const teamInfo = await storage.getHelperTeam(user.id);
      if (!teamInfo) {
        return res.status(400).json({ message: "가입된 팀이 없습니다" });
      }
      
      await storage.removeTeamMember(teamInfo.team.id, user.id);
      res.json({ message: "팀에서 탈퇴했습니다" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get team by QR token (for validation before joining)
  app.get("/api/teams/by-token/:token", async (req, res) => {
    try {
      const authToken = req.headers.authorization?.split(" ")[1];
      if (!authToken) return res.status(401).json({ message: "Unauthorized" });
      jwt.verify(authToken, JWT_SECRET);
      
      const team = await storage.getTeamByToken(req.params.token);
      if (!team) {
        return res.status(404).json({ message: "팀을 찾을 수 없습니다" });
      }
      
      const leader = await storage.getUser(team.leaderId);
      res.json({ team: { ...team, leader } });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== ADMIN SETTINGS ROUTES ====================
  
  // Get all courier settings
  app.get("/api/admin/settings/couriers", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const settings = await storage.getAllCourierSettings();
      res.json(settings);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create courier setting
  app.post("/api/admin/settings/couriers", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { 
        courierName, category, basePricePerBox, minDeliveryFee, minTotal,
        commissionRate, urgentCommissionRate, urgentSurchargeRate, isDefault 
      } = req.body;
      
      if (!courierName || !courierName.trim()) {
        return res.status(400).json({ message: "택배사 이름을 입력해주세요" });
      }
      
      const existing = await storage.getCourierSettingByName(courierName);
      if (existing) {
        return res.status(400).json({ message: "이미 존재하는 택배사입니다" });
      }
      const setting = await storage.createCourierSetting({
        courierName: courierName.trim(),
        category: category || 'parcel',
        basePricePerBox: Number(basePricePerBox) || 0,
        minDeliveryFee: Number(minDeliveryFee) || 0,
        minTotal: Number(minTotal) || 0,
        commissionRate: Number(commissionRate) || 0,
        urgentCommissionRate: Number(urgentCommissionRate) || 0,
        urgentSurchargeRate: Number(urgentSurchargeRate) || 0,
        isDefault: isDefault || false,
        isActive: true,
      });
      res.json(setting);
    } catch (err) {
      console.error("Create courier error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update courier setting
  app.patch("/api/admin/settings/couriers/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { 
        category, basePricePerBox, minDeliveryFee, minTotal, 
        commissionRate, urgentCommissionRate, urgentSurchargeRate, 
        isDefault, isActive, sortOrder, applyToCategory 
      } = req.body;
      const updates: Record<string, any> = {};
      if (category !== undefined) updates.category = category;
      if (basePricePerBox !== undefined) updates.basePricePerBox = Number(basePricePerBox);
      if (req.body.etcPricePerBox !== undefined) updates.etcPricePerBox = Number(req.body.etcPricePerBox);
      if (minDeliveryFee !== undefined) updates.minDeliveryFee = Number(minDeliveryFee);
      if (minTotal !== undefined) updates.minTotal = Number(minTotal);
      if (commissionRate !== undefined) updates.commissionRate = Number(commissionRate);
      if (urgentCommissionRate !== undefined) updates.urgentCommissionRate = Number(urgentCommissionRate);
      if (urgentSurchargeRate !== undefined) updates.urgentSurchargeRate = Number(urgentSurchargeRate);
      if (isDefault !== undefined) updates.isDefault = isDefault;
      if (isActive !== undefined) updates.isActive = isActive;
      if (sortOrder !== undefined) updates.sortOrder = Number(sortOrder);
      
      // 카테고리 기본값 변경 시 해당 카테고리 전체 택배사에 적용
      const currentSetting = await storage.getCourierSettingById(Number(req.params.id));
      if (currentSetting?.courierName.startsWith('(DEFAULT)') || applyToCategory) {
        const targetCategory = currentSetting?.category || category;
        if (targetCategory && minTotal !== undefined) {
          await storage.updateCourierSettingsByCategory(targetCategory, { minTotal: Number(minTotal) });
        }
      }
      
      const setting = await storage.updateCourierSetting(Number(req.params.id), updates);
      res.json(setting);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete courier setting
  app.delete("/api/admin/settings/couriers/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await storage.deleteCourierSetting(Number(req.params.id));
      res.json({ message: "삭제되었습니다" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });



// Seed default couriers (from app list)
  app.post("/api/admin/settings/couriers/seed-defaults", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const existing = await storage.getAllCourierSettingsIncludingDeleted();
      const existsSet = new Set(existing.map(c => c.courierName));
      let added = 0;

      for (const name of DEFAULT_COURIERS) {
        if (existsSet.has(name)) continue;
        await storage.createCourierSetting({
          courierName: name,
          minDeliveryFee: 0,
          commissionRate: 0,
          isDefault: name === "기타",
        });
        added++;
      }

      res.json({ ok: true, added, message: `${added}개 택배사가 추가되었습니다` });
    } catch (err) {
      console.error("[Admin] Seed couriers error:", err);
      res.status(500).json({ message: "Seed failed" });
    }
  });

  // ==================== ORDER CATEGORIES (오더 카테고리 관리) ====================

  // Get all order categories
  app.get("/api/admin/settings/order-categories", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const settings = await storage.getAllOrderCategorySettings();
      res.json(settings);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create order category
  app.post("/api/admin/settings/order-categories", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { categoryName, sortOrder, isActive, isAdminOnly, allowedCourierNames } = req.body;
      if (!categoryName) {
        return res.status(400).json({ message: "카테고리명을 입력해주세요" });
      }
      const existing = await storage.getOrderCategorySettingByName(categoryName);
      if (existing) {
        return res.status(400).json({ message: "이미 존재하는 카테고리명입니다" });
      }
      const setting = await storage.createOrderCategorySetting({
        categoryName,
        sortOrder: Number(sortOrder) || 0,
        isActive: isActive !== false,
        isAdminOnly: isAdminOnly || false,
        allowedCourierNames: allowedCourierNames ? JSON.stringify(allowedCourierNames) : null,
      });
      res.json(setting);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update order category
  app.patch("/api/admin/settings/order-categories/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { categoryName, sortOrder, isActive, isAdminOnly, allowedCourierNames } = req.body;
      const updates: Record<string, any> = {};
      if (categoryName !== undefined) updates.categoryName = categoryName;
      if (sortOrder !== undefined) updates.sortOrder = Number(sortOrder);
      if (isActive !== undefined) updates.isActive = isActive;
      if (sortOrder !== undefined) updates.sortOrder = Number(sortOrder);
      if (isAdminOnly !== undefined) updates.isAdminOnly = isAdminOnly;
      if (allowedCourierNames !== undefined) {
        updates.allowedCourierNames = allowedCourierNames ? JSON.stringify(allowedCourierNames) : null;
      }
      const setting = await storage.updateOrderCategorySetting(Number(req.params.id), updates);
      res.json(setting);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete order category
  app.delete("/api/admin/settings/order-categories/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await storage.deleteOrderCategorySetting(Number(req.params.id));
      res.json({ message: "삭제되었습니다" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== CLOSING FIELD SETTINGS (마감 필드 설정) ====================

  // Get all closing field settings
  app.get("/api/admin/settings/closing-fields", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const fields = await db.select().from(closingFieldSettings).orderBy(closingFieldSettings.sortOrder);
      res.json(fields);
    } catch (err) {
      console.error("Get closing fields error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create closing field setting
  app.post("/api/admin/settings/closing-fields", adminAuth, requirePermission("settings.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { fieldName, fieldType, isRequired, placeholder, description, targetRole, sortOrder } = req.body;
      if (!fieldName) {
        return res.status(400).json({ message: "필드명을 입력해주세요" });
      }
      const [field] = await db.insert(closingFieldSettings).values({
        fieldName,
        fieldType: fieldType || 'text',
        isRequired: isRequired || false,
        placeholder: placeholder || null,
        description: description || null,
        targetRole: targetRole || 'helper',
        sortOrder: Number(sortOrder) || 0,
        createdBy: req.user?.id,
      }).returning();
      res.json(field);
    } catch (err) {
      console.error("Create closing field error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update closing field setting
  app.patch("/api/admin/settings/closing-fields/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { fieldName, fieldType, isRequired, placeholder, description, targetRole, sortOrder, isActive } = req.body;
      const updates: Record<string, any> = { updatedAt: new Date() };
      if (fieldName !== undefined) updates.fieldName = fieldName;
      if (fieldType !== undefined) updates.fieldType = fieldType;
      if (isRequired !== undefined) updates.isRequired = isRequired;
      if (placeholder !== undefined) updates.placeholder = placeholder;
      if (description !== undefined) updates.description = description;
      if (targetRole !== undefined) updates.targetRole = targetRole;
      if (sortOrder !== undefined) updates.sortOrder = Number(sortOrder);
      if (isActive !== undefined) updates.isActive = isActive;
      if (sortOrder !== undefined) updates.sortOrder = Number(sortOrder);
      
      const [field] = await db.update(closingFieldSettings)
        .set(updates)
        .where(eq(closingFieldSettings.id, Number(req.params.id)))
        .returning();
      res.json(field);
    } catch (err) {
      console.error("Update closing field error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete closing field setting
  app.delete("/api/admin/settings/closing-fields/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await db.delete(closingFieldSettings).where(eq(closingFieldSettings.id, Number(req.params.id)));
      res.json({ message: "삭제되었습니다" });
    } catch (err) {
      console.error("Delete closing field error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });


  // ==================== ORDER REGISTRATION FIELDS (오더등록 필드) ====================

  // Get all order registration fields
  app.get("/api/admin/settings/order-fields", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const fields = await db.select().from(orderRegistrationFields).orderBy(orderRegistrationFields.sortOrder);
      res.json(fields);
    } catch (err) {
      console.error("Get order registration fields error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create order registration field
  app.post("/api/admin/settings/order-fields", adminAuth, requirePermission("settings.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { fieldCode, fieldName, fieldType, isRequired, placeholder, description, options, defaultValue, validationRule, sortOrder } = req.body;
      const [field] = await db.insert(orderRegistrationFields).values({
        fieldCode,
        fieldName,
        fieldType: fieldType || 'text',
        isRequired: isRequired ?? true,
        placeholder,
        description,
        options,
        defaultValue,
        validationRule,
        sortOrder: sortOrder || 0,
        createdBy: req.user!.id,
      }).returning();
      res.json(field);
    } catch (err) {
      console.error("Create order registration field error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update order registration field
  app.patch("/api/admin/settings/order-fields/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { fieldCode, fieldName, fieldType, isRequired, placeholder, description, options, defaultValue, validationRule, sortOrder, isActive } = req.body;
      const [field] = await db.update(orderRegistrationFields)
        .set({
          ...(fieldCode !== undefined && { fieldCode }),
          ...(fieldName !== undefined && { fieldName }),
          ...(fieldType !== undefined && { fieldType }),
          ...(isRequired !== undefined && { isRequired }),
          ...(placeholder !== undefined && { placeholder }),
          ...(description !== undefined && { description }),
          ...(options !== undefined && { options }),
          ...(defaultValue !== undefined && { defaultValue }),
          ...(validationRule !== undefined && { validationRule }),
          ...(sortOrder !== undefined && { sortOrder }),
          ...(isActive !== undefined && { isActive }),
          updatedAt: new Date(),
        })
        .where(eq(orderRegistrationFields.id, Number(req.params.id)))
        .returning();
      res.json(field);
    } catch (err) {
      console.error("Update order registration field error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete order registration field
  app.delete("/api/admin/settings/order-fields/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await db.delete(orderRegistrationFields).where(eq(orderRegistrationFields.id, Number(req.params.id)));
      res.json({ message: "삭제되었습니다" });
    } catch (err) {
      console.error("Delete order registration field error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  // ==================== PRICING POLICIES (정산 자동화 정책) ====================

  // Carrier Pricing Policies (택배사별 단가 정책)
  app.get("/api/admin/settings/carrier-pricing-policies", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const policies = await db.select().from(carrierPricingPolicies).orderBy(carrierPricingPolicies.carrierCode, carrierPricingPolicies.serviceType);
      res.json(policies);
    } catch (err) {
      console.error("Get carrier pricing policies error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/settings/carrier-pricing-policies", adminAuth, requirePermission("settings.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { carrierCode, serviceType, regionCode, vehicleType, unitType, unitPriceSupply, minChargeSupply, effectiveFrom, effectiveTo } = req.body;
      if (!carrierCode || !serviceType || !unitPriceSupply || !effectiveFrom) {
        return res.status(400).json({ message: "필수 항목을 입력해주세요" });
      }
      const [policy] = await db.insert(carrierPricingPolicies).values({
        carrierCode,
        serviceType,
        regionCode: regionCode || null,
        vehicleType: vehicleType || null,
        unitType: unitType || "BOX",
        unitPriceSupply: Number(unitPriceSupply),
        minChargeSupply: minChargeSupply ? Number(minChargeSupply) : null,
        effectiveFrom,
        effectiveTo: effectiveTo || null,
        isActive: true,
        createdBy: req.user?.id,
      }).returning();
      res.json(policy);
    } catch (err) {
      console.error("Create carrier pricing policy error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/admin/settings/carrier-pricing-policies/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const updates: Record<string, any> = { updatedAt: new Date() };
      const fields = ["carrierCode", "serviceType", "regionCode", "vehicleType", "unitType", "unitPriceSupply", "minChargeSupply", "effectiveFrom", "effectiveTo", "isActive"];
      fields.forEach(f => {
        if (req.body[f] !== undefined) {
          updates[f] = f.includes("Supply") || f.includes("Price") ? Number(req.body[f]) : req.body[f];
        }
      });
      const [policy] = await db.update(carrierPricingPolicies)
        .set(updates)
        .where(eq(carrierPricingPolicies.id, Number(req.params.id)))
        .returning();
      res.json(policy);
    } catch (err) {
      console.error("Update carrier pricing policy error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/admin/settings/carrier-pricing-policies/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await db.delete(carrierPricingPolicies).where(eq(carrierPricingPolicies.id, Number(req.params.id)));
      res.json({ message: "삭제되었습니다" });
    } catch (err) {
      console.error("Delete carrier pricing policy error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Urgent Fee Policies (긴급수수료 정책)
  app.get("/api/admin/settings/urgent-fee-policies", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const policies = await db.select().from(urgentFeePolicies).orderBy(urgentFeePolicies.carrierCode);
      res.json(policies);
    } catch (err) {
      console.error("Get urgent fee policies error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/settings/urgent-fee-policies", adminAuth, requirePermission("settings.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { carrierCode, applyType, value, maxUrgentFeeSupply, effectiveFrom, effectiveTo } = req.body;
      if (!applyType || !value || !effectiveFrom) {
        return res.status(400).json({ message: "필수 항목을 입력해주세요" });
      }
      const [policy] = await db.insert(urgentFeePolicies).values({
        carrierCode: carrierCode || null,
        applyType,
        value: Number(value),
        maxUrgentFeeSupply: maxUrgentFeeSupply ? Number(maxUrgentFeeSupply) : null,
        effectiveFrom,
        effectiveTo: effectiveTo || null,
        isActive: true,
        createdBy: req.user?.id,
      }).returning();
      res.json(policy);
    } catch (err) {
      console.error("Create urgent fee policy error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/admin/settings/urgent-fee-policies/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const updates: Record<string, any> = { updatedAt: new Date() };
      const fields = ["carrierCode", "applyType", "value", "maxUrgentFeeSupply", "effectiveFrom", "effectiveTo", "isActive"];
      fields.forEach(f => {
        if (req.body[f] !== undefined) {
          updates[f] = f === "value" || f === "maxUrgentFeeSupply" ? Number(req.body[f]) : req.body[f];
        }
      });
      const [policy] = await db.update(urgentFeePolicies)
        .set(updates)
        .where(eq(urgentFeePolicies.id, Number(req.params.id)))
        .returning();
      res.json(policy);
    } catch (err) {
      console.error("Update urgent fee policy error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/admin/settings/urgent-fee-policies/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await db.delete(urgentFeePolicies).where(eq(urgentFeePolicies.id, Number(req.params.id)));
      res.json({ message: "삭제되었습니다" });
    } catch (err) {
      console.error("Delete urgent fee policy error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Platform Fee Policies (플랫폼 수수료 정책)
  app.get("/api/admin/settings/platform-fee-policies", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const policies = await db.select().from(platformFeePolicies).orderBy(desc(platformFeePolicies.isDefault), platformFeePolicies.effectiveFrom);
      res.json(policies);
    } catch (err) {
      console.error("Get platform fee policies error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/settings/platform-fee-policies", adminAuth, requirePermission("settings.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { name, baseOn, feeType, ratePercent, fixedAmount, minFee, maxFee, effectiveFrom, effectiveTo, isDefault } = req.body;
      if (!name || !baseOn || !effectiveFrom) {
        return res.status(400).json({ message: "필수 항목을 입력해주세요" });
      }
      if (isDefault) {
        await db.update(platformFeePolicies).set({ isDefault: false }).where(eq(platformFeePolicies.isDefault, true));
      }
      const [policy] = await db.insert(platformFeePolicies).values({
        name,
        baseOn,
        feeType: feeType || "PERCENT",
        ratePercent: ratePercent ? Number(ratePercent) : null,
        fixedAmount: fixedAmount ? Number(fixedAmount) : null,
        minFee: minFee ? Number(minFee) : null,
        maxFee: maxFee ? Number(maxFee) : null,
        effectiveFrom,
        effectiveTo: effectiveTo || null,
        isActive: true,
        isDefault: isDefault || false,
        createdBy: req.user?.id,
      }).returning();
      res.json(policy);
    } catch (err) {
      console.error("Create platform fee policy error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/admin/settings/platform-fee-policies/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      if (req.body.isDefault) {
        await db.update(platformFeePolicies).set({ isDefault: false }).where(eq(platformFeePolicies.isDefault, true));
      }
      const updates: Record<string, any> = { updatedAt: new Date() };
      const fields = ["name", "baseOn", "feeType", "ratePercent", "fixedAmount", "minFee", "maxFee", "effectiveFrom", "effectiveTo", "isActive", "isDefault"];
      fields.forEach(f => {
        if (req.body[f] !== undefined) {
          updates[f] = ["ratePercent", "fixedAmount", "minFee", "maxFee"].includes(f) ? Number(req.body[f]) : req.body[f];
        }
      });
      const [policy] = await db.update(platformFeePolicies)
        .set(updates)
        .where(eq(platformFeePolicies.id, Number(req.params.id)))
        .returning();
      res.json(policy);
    } catch (err) {
      console.error("Update platform fee policy error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/admin/settings/platform-fee-policies/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await db.delete(platformFeePolicies).where(eq(platformFeePolicies.id, Number(req.params.id)));
      res.json({ message: "삭제되었습니다" });
    } catch (err) {
      console.error("Delete platform fee policy error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });


  // Refund Policies (환불 정책 관리)
  // Alias for backward compatibility
  app.get("/api/admin/refund-policies", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const policies = await db.select().from(refundPolicies).orderBy(desc(refundPolicies.isDefault), desc(refundPolicies.effectiveFrom));
      res.json(policies);
    } catch (err) {
      console.error("Get refund policies error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/settings/refund-policies", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const policies = await db.select().from(refundPolicies).orderBy(desc(refundPolicies.isDefault), desc(refundPolicies.effectiveFrom));
      res.json(policies);
    } catch (err) {
      console.error("Get refund policies error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/settings/refund-policies", adminAuth, requirePermission("settings.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const data = insertRefundPolicySchema.parse({
        ...req.body,
        createdBy: req.user?.id
      });
      const [created] = await db.insert(refundPolicies).values(data).returning();
      res.status(201).json(created);
    } catch (err) {
      console.error("Create refund policy error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/admin/settings/refund-policies/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { name, beforeMatchingRefundRate, afterMatchingRefundRate, effectiveFrom, effectiveTo, isActive, isDefault } = req.body;
      const [updated] = await db
        .update(refundPolicies)
        .set({ 
          name, 
          beforeMatchingRefundRate, 
          afterMatchingRefundRate, 
          effectiveFrom, 
          effectiveTo, 
          isActive, 
          isDefault,
          updatedAt: new Date() 
        })
        .where(eq(refundPolicies.id, Number(req.params.id)))
        .returning();
      res.json(updated);
    } catch (err) {
      console.error("Update refund policy error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/admin/settings/refund-policies/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await db.delete(refundPolicies).where(eq(refundPolicies.id, Number(req.params.id)));
      res.json({ message: "삭제되었습니다" });
    } catch (err) {
      console.error("Delete refund policy error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Extra Cost Catalog (추가비용 항목 카탈로그)
  app.get("/api/admin/settings/extra-cost-catalog", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const items = await db.select().from(extraCostCatalog).orderBy(extraCostCatalog.sortOrder);
      res.json(items);
    } catch (err) {
      console.error("Get extra cost catalog error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/settings/extra-cost-catalog", adminAuth, requirePermission("settings.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { costCode, label, unitLabel, defaultUnitPriceSupply, inputMode, requireMemo, sortOrder } = req.body;
      if (!costCode || !label) {
        return res.status(400).json({ message: "항목 코드와 표시명을 입력해주세요" });
      }
      const [item] = await db.insert(extraCostCatalog).values({
        costCode,
        label,
        unitLabel: unitLabel || null,
        defaultUnitPriceSupply: defaultUnitPriceSupply ? Number(defaultUnitPriceSupply) : null,
        inputMode: inputMode || "QTY_PRICE",
        requireMemo: requireMemo || false,
        sortOrder: sortOrder ? Number(sortOrder) : 100,
        isActive: true,
        createdBy: req.user?.id,
      }).returning();
      res.json(item);
    } catch (err) {
      console.error("Create extra cost catalog error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/admin/settings/extra-cost-catalog/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const updates: Record<string, any> = { updatedAt: new Date() };
      const fields = ["costCode", "label", "unitLabel", "defaultUnitPriceSupply", "inputMode", "requireMemo", "sortOrder", "isActive"];
      fields.forEach(f => {
        if (req.body[f] !== undefined) {
          updates[f] = ["defaultUnitPriceSupply", "sortOrder"].includes(f) ? Number(req.body[f]) : req.body[f];
        }
      });
      const [item] = await db.update(extraCostCatalog)
        .set(updates)
        .where(eq(extraCostCatalog.id, Number(req.params.id)))
        .returning();
      res.json(item);
    } catch (err) {
      console.error("Update extra cost catalog error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/admin/settings/extra-cost-catalog/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await db.delete(extraCostCatalog).where(eq(extraCostCatalog.id, Number(req.params.id)));
      res.json({ message: "삭제되었습니다" });
    } catch (err) {
      console.error("Delete extra cost catalog error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Policy lookup API (앱용 정책 조회)
  app.get("/api/policies/pricing", requireAuth, async (req, res) => {
    try {
      const { carrierCode, serviceType } = req.query;
      if (!carrierCode || !serviceType) {
        return res.status(400).json({ message: "carrierCode와 serviceType이 필요합니다" });
      }
      
      const {
        findActiveCarrierPricing,
        findActiveUrgentFeePolicy,
        findActivePlatformFeePolicy,
      } = await import("./utils/settlement-calculator");
      
      const date = new Date().toISOString().split("T")[0];
      const pricingPolicy = await findActiveCarrierPricing(carrierCode as string, serviceType as string, date);
      const urgentPolicy = await findActiveUrgentFeePolicy(carrierCode as string, date);
      const platformPolicy = await findActivePlatformFeePolicy(date);
      
      res.json({
        unitPriceSupply: pricingPolicy?.unitPriceSupply || null,
        minChargeSupply: pricingPolicy?.minChargeSupply || null,
        urgent: urgentPolicy ? {
          applyType: urgentPolicy.applyType,
          value: urgentPolicy.value,
          maxFee: urgentPolicy.maxUrgentFeeSupply,
        } : null,
        platformFee: platformPolicy ? {
          baseOn: platformPolicy.baseOn,
          ratePercent: platformPolicy.ratePercent,
          minFee: platformPolicy.minFee,
          maxFee: platformPolicy.maxFee,
        } : null,
      });
    } catch (err) {
      console.error("Get policies error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== CARRIER RATE ITEMS (택배사별 품목 단가) ====================
  
  // Get all carrier rate items
  app.get("/api/admin/settings/carrier-rates", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const items = await storage.getAllCarrierRateItems();
      const couriers = await storage.getAllCourierSettings();
      const enriched = items.map(item => {
        const courier = couriers.find(c => c.id === item.courierId);
        return { ...item, courierName: courier?.courierName || "Unknown" };
      });
      res.json(enriched);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get carrier rate items by courier
  app.get("/api/admin/settings/couriers/:courierId/rates", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const items = await storage.getCarrierRateItemsByCourier(Number(req.params.courierId));
      res.json(items);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create carrier rate item
  app.post("/api/admin/settings/carrier-rates", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const parsed = insertCarrierRateItemSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: parsed.error.errors[0]?.message || "Invalid input" });
      }
      const item = await storage.createCarrierRateItem(parsed.data);
      res.json(item);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update carrier rate item
  app.patch("/api/admin/settings/carrier-rates/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { itemName, itemType, unitPrice, includeVat, displayOrder, isActive } = req.body;
      const updates: Record<string, any> = {};
      if (itemName !== undefined) updates.itemName = itemName;
      if (itemType !== undefined) updates.itemType = itemType;
      if (unitPrice !== undefined) updates.unitPrice = Number(unitPrice);
      if (includeVat !== undefined) updates.includeVat = includeVat;
      if (displayOrder !== undefined) updates.displayOrder = Number(displayOrder);
      if (isActive !== undefined) updates.isActive = isActive;
      if (sortOrder !== undefined) updates.sortOrder = Number(sortOrder);
      const item = await storage.updateCarrierRateItem(Number(req.params.id), updates);
      res.json(item);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete carrier rate item
  app.delete("/api/admin/settings/carrier-rates/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await storage.deleteCarrierRateItem(Number(req.params.id));
      res.json({ message: "삭제되었습니다" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== ADMIN BANK ACCOUNTS (입금 통장 관리) ====================
  
  // Get all admin bank accounts
  app.get("/api/admin/settings/bank-accounts", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const accounts = await storage.getAllAdminBankAccounts();
      res.json(accounts);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get bank accounts by type (deposit or balance)
  app.get("/api/admin/settings/bank-accounts/:type", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const accounts = await storage.getAdminBankAccountsByType(req.params.type);
      res.json(accounts);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create bank account
  app.post("/api/admin/settings/bank-accounts", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const parsed = insertAdminBankAccountSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: parsed.error.errors[0]?.message || "Invalid input" });
      }
      const account = await storage.createAdminBankAccount(parsed.data);
      res.json(account);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update bank account
  app.patch("/api/admin/settings/bank-accounts/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { accountType, bankName, accountNumber, accountHolder, bankBranch, displayOrder, isActive, notes } = req.body;
      const updates: Record<string, any> = {};
      if (accountType !== undefined) updates.accountType = accountType;
      if (bankName !== undefined) updates.bankName = bankName;
      if (accountNumber !== undefined) updates.accountNumber = accountNumber;
      if (accountHolder !== undefined) updates.accountHolder = accountHolder;
      if (bankBranch !== undefined) updates.bankBranch = bankBranch;
      if (displayOrder !== undefined) updates.displayOrder = Number(displayOrder);
      if (isActive !== undefined) updates.isActive = isActive;
      if (sortOrder !== undefined) updates.sortOrder = Number(sortOrder);
      if (notes !== undefined) updates.notes = notes;
      const account = await storage.updateAdminBankAccount(Number(req.params.id), updates);
      res.json(account);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete bank account
  app.delete("/api/admin/settings/bank-accounts/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await storage.deleteAdminBankAccount(Number(req.params.id));
      res.json({ message: "삭제되었습니다" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get all team commission overrides
  app.get("/api/admin/settings/team-commissions", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const overrides = await storage.getAllTeamCommissionOverrides();
      const teams = await storage.getAllTeams();
      const enriched = await Promise.all(overrides.map(async (o) => {
        const team = teams.find(t => t.id === o.teamId);
        if (!team) return { ...o, teamName: "Unknown" };
        const leader = await storage.getUser(team.leaderId);
        return { ...o, teamName: team.name, leaderName: leader?.name || "Unknown" };
      }));
      res.json(enriched);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create team commission override
  app.post("/api/admin/settings/team-commissions", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { teamId, commissionRate, notes } = req.body;
      const existing = await storage.getTeamCommissionOverride(Number(teamId));
      if (existing) {
        return res.status(400).json({ message: "이미 설정된 팀입니다. 수정하세요." });
      }
      const override = await storage.createTeamCommissionOverride({
        teamId: Number(teamId),
        commissionRate: Number(commissionRate),
        notes: notes || null,
      });
      res.json(override);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update team commission override
  app.patch("/api/admin/settings/team-commissions/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { commissionRate, notes } = req.body;
      const updates: Record<string, any> = {};
      if (commissionRate !== undefined) updates.commissionRate = Number(commissionRate);
      if (notes !== undefined) updates.notes = notes;
      const override = await storage.updateTeamCommissionOverride(Number(req.params.id), updates);
      res.json(override);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete team commission override
  app.delete("/api/admin/settings/team-commissions/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await storage.deleteTeamCommissionOverride(Number(req.params.id));
      res.json({ message: "삭제되었습니다" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== DESTINATION PRICING (착지별/시간대별 단가) ====================
  
  // Get all destination pricing
  app.get("/api/admin/settings/destination-pricing", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const pricing = await storage.getAllDestinationPricing();
      res.json(pricing);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Get destination pricing by category
  app.get("/api/admin/settings/destination-pricing/category/:category", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const pricing = await storage.getDestinationPricingByCategory(req.params.category);
      res.json(pricing);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create destination pricing
  app.post("/api/admin/settings/destination-pricing", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const parsed = insertDestinationPricingSchema.safeParse({
        workCategory: req.body.workCategory,
        courierId: req.body.courierId || null,
        destinationRegion: req.body.destinationRegion,
        timeSlot: req.body.timeSlot,
        pricePerBox: Number(req.body.pricePerBox) || 0,
        minimumFee: Number(req.body.minimumFee) || 0,
        isActive: req.body.isActive !== false,
      });
      if (!parsed.success) {
        return res.status(400).json({ message: parsed.error.errors[0]?.message || "유효하지 않은 입력입니다" });
      }
      if (parsed.data.workCategory === "택배사" && !parsed.data.courierId) {
        return res.status(400).json({ message: "택배사를 선택해주세요" });
      }
      const pricing = await storage.createDestinationPricing(parsed.data);
      res.json(pricing);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update destination pricing
  app.patch("/api/admin/settings/destination-pricing/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { workCategory, courierId, destinationRegion, timeSlot, pricePerBox, minimumFee, isActive } = req.body;
      const updates: Record<string, any> = {};
      
      const existingPricing = await storage.getDestinationPricing(Number(req.params.id));
      if (!existingPricing) {
        return res.status(404).json({ message: "가격 설정을 찾을 수 없습니다" });
      }
      
      if (workCategory !== undefined) {
        if (workCategory !== "택배사" && workCategory !== "기타택배") {
          return res.status(400).json({ message: "유효하지 않은 업무 카테고리입니다" });
        }
        updates.workCategory = workCategory;
      }
      if (courierId !== undefined) {
        updates.courierId = courierId || null;
      }
      if (destinationRegion !== undefined) {
        if (!destinationRegions.includes(destinationRegion)) {
          return res.status(400).json({ message: "유효하지 않은 착지 지역입니다" });
        }
        updates.destinationRegion = destinationRegion;
      }
      if (timeSlot !== undefined) {
        if (!timeSlots.includes(timeSlot)) {
          return res.status(400).json({ message: "유효하지 않은 시간대입니다" });
        }
        updates.timeSlot = timeSlot;
      }
      if (pricePerBox !== undefined) {
        const price = Number(pricePerBox);
        if (isNaN(price) || price < 0) {
          return res.status(400).json({ message: "박스당 단가는 0 이상이어야 합니다" });
        }
        updates.pricePerBox = price;
      }
      if (minimumFee !== undefined) {
        const fee = Number(minimumFee);
        if (isNaN(fee) || fee < 0) {
          return res.status(400).json({ message: "최저가는 0 이상이어야 합니다" });
        }
        updates.minimumFee = fee;
      }
      if (isActive !== undefined) {
        updates.isActive = Boolean(isActive);
      }
      
      const finalWorkCategory = updates.workCategory ?? existingPricing.workCategory;
      const finalCourierId = updates.courierId !== undefined ? updates.courierId : existingPricing.courierId;
      
      if (finalWorkCategory === "택배사" && !finalCourierId) {
        return res.status(400).json({ message: "택배사 카테고리에는 택배사를 선택해야 합니다" });
      }
      
      const pricing = await storage.updateDestinationPricing(Number(req.params.id), updates);
      res.json(pricing);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete destination pricing
  app.delete("/api/admin/settings/destination-pricing/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await storage.deleteDestinationPricing(Number(req.params.id));
      res.json({ message: "삭제되었습니다" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== COLD CHAIN SETTINGS (냉탑 최저가) ====================
  
  // Get all cold chain settings
  app.get("/api/admin/settings/cold-chain", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const settings = await storage.getAllColdChainSettings();
      res.json(settings);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Create cold chain setting
  app.post("/api/admin/settings/cold-chain", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const parsed = insertColdChainSettingSchema.safeParse({
        settingName: req.body.settingName,
        minimumFee: Number(req.body.minimumFee) || 0,
        description: req.body.description || null,
        isActive: req.body.isActive !== false,
      });
      if (!parsed.success) {
        return res.status(400).json({ message: parsed.error.errors[0]?.message || "유효하지 않은 입력입니다" });
      }
      const setting = await storage.createColdChainSetting(parsed.data);
      res.json(setting);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Update cold chain setting
  app.patch("/api/admin/settings/cold-chain/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { settingName, minimumFee, description, isActive } = req.body;
      const updates: Record<string, any> = {};
      
      const existingSetting = await storage.getColdChainSetting(Number(req.params.id));
      if (!existingSetting) {
        return res.status(404).json({ message: "냉탑 설정을 찾을 수 없습니다" });
      }
      
      if (settingName !== undefined) {
        if (typeof settingName !== "string" || settingName.trim().length === 0) {
          return res.status(400).json({ message: "설정명을 입력해주세요" });
        }
        updates.settingName = settingName.trim();
      }
      if (minimumFee !== undefined) {
        const fee = Number(minimumFee);
        if (isNaN(fee) || fee < 0) {
          return res.status(400).json({ message: "최저가는 0 이상이어야 합니다" });
        }
        updates.minimumFee = fee;
      }
      if (description !== undefined) {
        updates.description = description === null ? null : String(description);
      }
      if (isActive !== undefined) {
        updates.isActive = Boolean(isActive);
      }
      
      const setting = await storage.updateColdChainSetting(Number(req.params.id), updates);
      res.json(setting);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Delete cold chain setting
  app.delete("/api/admin/settings/cold-chain/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await storage.deleteColdChainSetting(Number(req.params.id));
      res.json({ message: "삭제되었습니다" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // System settings routes
  app.get("/api/admin/settings/system", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const settings = await storage.getAllSystemSettings();
      res.json(settings);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/settings/system/:key", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const setting = await storage.getSystemSetting(req.params.key);
      res.json(setting || null);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/settings/system", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { key, value, description } = req.body;
      if (!key || value === undefined) {
        return res.status(400).json({ message: "key와 value는 필수입니다" });
      }
      const setting = await storage.upsertSystemSetting(key, String(value), description);
      res.json(setting);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Job postings routes
  app.get("/api/job-postings", async (req, res) => {
    try {
      const postings = await storage.getAllJobPostings();
      res.json(postings);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/job-postings", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const postings = await storage.getAllJobPostings();
      res.json(postings);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/job-postings", adminAuth, requirePermission("orders.create"), async (req, res) => {
    try {
      const { companyName, workDays, vehicleType, fuelCost, commission, contact, workDetails, note, recruitCount, workStartTime, workEndTime } = req.body;
      
      if (!companyName || !workDays || !vehicleType || !fuelCost || !commission || !contact || !workDetails) {
        return res.status(400).json({ message: "필수 필드를 모두 입력해주세요" });
      }
      
      const posting = await storage.createJobPosting({
        companyName,
        workDays,
        vehicleType,
        fuelCost,
        commission,
        contact,
        workDetails: typeof workDetails === 'string' ? workDetails : JSON.stringify(workDetails),
        note: note || null,
        recruitCount: recruitCount || 1,
        workStartTime: workStartTime || null,
        workEndTime: workEndTime || null,
        status: "awaiting_deposit",
      });
      
      res.json(posting);
    } catch (err) {
      console.error("Create job posting error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/admin/job-postings/:id", adminAuth, requirePermission("orders.edit"), async (req, res) => {
    try {
      const { companyName, workDays, vehicleType, fuelCost, commission, contact, workDetails, note, recruitCount, workStartTime, workEndTime, status } = req.body;
      
      const updates: Record<string, any> = {};
      if (companyName !== undefined) updates.companyName = companyName;
      if (workDays !== undefined) updates.workDays = workDays;
      if (vehicleType !== undefined) updates.vehicleType = vehicleType;
      if (fuelCost !== undefined) updates.fuelCost = fuelCost;
      if (commission !== undefined) updates.commission = commission;
      if (contact !== undefined) updates.contact = contact;
      if (workDetails !== undefined) updates.workDetails = typeof workDetails === 'string' ? workDetails : JSON.stringify(workDetails);
      if (note !== undefined) updates.note = note;
      if (recruitCount !== undefined) updates.recruitCount = recruitCount;
      if (workStartTime !== undefined) updates.workStartTime = workStartTime;
      if (workEndTime !== undefined) updates.workEndTime = workEndTime;
      if (status !== undefined) updates.status = status;
      
      const posting = await storage.updateJobPosting(Number(req.params.id), updates);
      res.json(posting);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/admin/job-postings/:id", adminAuth, requirePermission("orders.delete"), async (req, res) => {
    try {
      await storage.deleteJobPosting(Number(req.params.id));
      res.json({ message: "채용공고가 삭제되었습니다" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Payment reminders routes
  app.get("/api/admin/payment-reminders", adminAuth, requirePermission("payments.view"), async (req, res) => {
    try {
      const reminders = await storage.getAllPaymentReminders();
      res.json(reminders);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/payment-reminders/:id", adminAuth, requirePermission("payments.view"), async (req, res) => {
    try {
      const reminder = await storage.getPaymentReminder(Number(req.params.id));
      if (!reminder) {
        return res.status(404).json({ message: "독촉장을 찾을 수 없습니다" });
      }
      res.json(reminder);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/payment-reminders", adminAuth, requirePermission("payments.view"), async (req, res) => {
    try {
      const { requesterId, orderId, orderNumber, unpaidAmount, dueDate, overdueDate, 
              signatureData, phoneNumber, phoneVerified, ipAddress, userAgent, 
              consentLog, contractContent } = req.body;
      
      if (!requesterId || !orderNumber || !unpaidAmount || !dueDate) {
        return res.status(400).json({ message: "필수 필드를 모두 입력해주세요" });
      }
      
      const clientIp = req.headers['x-forwarded-for'] || req.socket.remoteAddress || ipAddress;
      const clientUserAgent = req.headers['user-agent'] || userAgent;
      
      const reminder = await storage.createPaymentReminder({
        requesterId,
        orderId: orderId || null,
        orderNumber,
        unpaidAmount,
        dueDate,
        overdueDate: overdueDate || null,
        reminderLevel: 0,
        signatureData: signatureData || null,
        phoneNumber: phoneNumber || null,
        phoneVerified: phoneVerified || false,
        ipAddress: typeof clientIp === 'string' ? clientIp : String(clientIp),
        userAgent: typeof clientUserAgent === 'string' ? clientUserAgent : String(clientUserAgent),
        consentLog: consentLog || null,
        contractContent: contractContent || null,
      });
      res.status(201).json(reminder);
    } catch (err) {
      console.error("Payment reminder creation error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/admin/payment-reminders/:id", adminAuth, requirePermission("payments.view"), async (req, res) => {
    try {
      const { reminderLevel, signatureData, phoneNumber, phoneVerified, phoneVerifiedAt,
              agreedAt, ipAddress, userAgent, consentLog, contractContent,
              firstReminderSentAt, secondReminderSentAt, thirdReminderSentAt, certifiedMailPrintedAt } = req.body;
      
      const updates: Record<string, any> = {};
      if (reminderLevel !== undefined) updates.reminderLevel = reminderLevel;
      if (signatureData !== undefined) updates.signatureData = signatureData;
      if (phoneNumber !== undefined) updates.phoneNumber = phoneNumber;
      if (phoneVerified !== undefined) updates.phoneVerified = phoneVerified;
      if (phoneVerifiedAt !== undefined) updates.phoneVerifiedAt = new Date(phoneVerifiedAt);
      if (agreedAt !== undefined) updates.agreedAt = new Date(agreedAt);
      if (ipAddress !== undefined) updates.ipAddress = ipAddress;
      if (userAgent !== undefined) updates.userAgent = userAgent;
      if (consentLog !== undefined) updates.consentLog = consentLog;
      if (contractContent !== undefined) updates.contractContent = contractContent;
      if (firstReminderSentAt !== undefined) updates.firstReminderSentAt = new Date(firstReminderSentAt);
      if (secondReminderSentAt !== undefined) updates.secondReminderSentAt = new Date(secondReminderSentAt);
      if (thirdReminderSentAt !== undefined) updates.thirdReminderSentAt = new Date(thirdReminderSentAt);
      if (certifiedMailPrintedAt !== undefined) updates.certifiedMailPrintedAt = new Date(certifiedMailPrintedAt);
      
      const reminder = await storage.updatePaymentReminder(Number(req.params.id), updates);
      res.json(reminder);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/admin/payment-reminders/:id", adminAuth, requirePermission("payments.view"), async (req, res) => {
    try {
      await storage.deletePaymentReminder(Number(req.params.id));
      res.json({ message: "독촉장이 삭제되었습니다" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Announcement routes (본사 공지)
  app.get("/api/announcements", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      const userAnnouncements = await storage.getUserAnnouncements(user.id, user.role);
      res.json(userAnnouncements);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/announcements", adminAuth, requirePermission("notifications.view"), async (req, res) => {
    try {
      const announcements = await storage.getAllAnnouncements();
      res.json(announcements);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/announcements/:id", adminAuth, requirePermission("notifications.view"), async (req, res) => {
    try {
      const announcement = await storage.getAnnouncement(Number(req.params.id));
      if (!announcement) {
        return res.status(404).json({ message: "공지를 찾을 수 없습니다" });
      }
      res.json(announcement);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/announcements/:id/recipients", adminAuth, requirePermission("notifications.view"), async (req, res) => {
    try {
      const recipients = await storage.getAnnouncementRecipients(Number(req.params.id));
      const recipientDetails = await Promise.all(
        recipients.map(async (r) => {
          const user = await storage.getUser(r.userId);
          return {
            ...r,
            userName: user?.name || "알 수 없음",
            userEmail: user?.email || "",
            userRole: user?.role || "",
          };
        })
      );
      res.json(recipientDetails);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/announcements", adminAuth, requirePermission("notifications.send"), async (req, res) => {
    try {
      const { title, content, targetAudience, createdBy } = req.body;
      if (!title || !content || !targetAudience || !createdBy) {
        return res.status(400).json({ message: "필수 필드를 모두 입력해주세요" });
      }

      const announcement = await storage.createAnnouncement({
        title,
        content,
        targetAudience,
        createdBy,
      });

      // Create notifications for target users
      const allUsers = await storage.getAllUsers();
      const targetUsers = allUsers.filter((u) => {
        if (targetAudience === "all") return true;
        return u.role === targetAudience;
      });

      // Add each user as a recipient and send notification
      for (const user of targetUsers) {
        await storage.addAnnouncementRecipient({
          announcementId: announcement.id,
          userId: user.id,
        });

        await storage.createNotification({
          userId: user.id,
          type: "announcement",
          title: `[공지] ${title}`,
          message: content.substring(0, 100) + (content.length > 100 ? "..." : ""),
          relatedId: announcement.id,
        });
      }

      res.status(201).json({ 
        ...announcement,
        recipientCount: targetUsers.length,
      });
    } catch (err) {
      console.error("Announcement creation error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/admin/announcements/:id", adminAuth, requirePermission("notifications.edit"), async (req, res) => {
    try {
      await storage.deleteAnnouncement(Number(req.params.id));
      res.json({ message: "공지가 삭제되었습니다" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // User preferences (푸시 알림/위치 설정)
  app.patch("/api/users/preferences", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const { pushEnabled, locationConsent, latitude, longitude } = req.body;
      const updates: any = {};
      if (pushEnabled !== undefined) updates.pushEnabled = pushEnabled;
      if (locationConsent !== undefined) updates.locationConsent = locationConsent;
      if (latitude !== undefined) updates.latitude = latitude;
      if (longitude !== undefined) updates.longitude = longitude;
      if (latitude !== undefined || longitude !== undefined) {
        updates.locationUpdatedAt = new Date();
      }
      
      const user = await storage.updateUserPreferences(userId, updates);
      res.json(user);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/users/preferences", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      
      res.json({
        pushEnabled: user.pushEnabled ?? true,
        locationConsent: user.locationConsent ?? false,
        latitude: user.latitude,
        longitude: user.longitude,
        locationUpdatedAt: user.locationUpdatedAt,
      });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Notification settings GET
  app.get("/api/users/notification-settings", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const user = req.user!;
      
      const defaultSettings = {
        orderNotifications: true,
        contractNotifications: true,
        settlementNotifications: true,
        marketingNotifications: false,
        locationTracking: true,
      };
      
      const savedSettings = user.notificationPreferences 
        ? JSON.parse(user.notificationPreferences) 
        : {};
      
      res.json({ ...defaultSettings, ...savedSettings });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Notification settings PATCH
  app.patch("/api/users/notification-settings", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      const currentSettings = user.notificationPreferences 
        ? JSON.parse(user.notificationPreferences) 
        : {};
      
      const updatedSettings = { ...currentSettings, ...req.body };
      
      await storage.updateUser(userId, {
        notificationPreferences: JSON.stringify(updatedSettings),
      });
      
      res.json(updatedSettings);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Location update API (네이티브 앱 위치 업데이트)
  app.post("/api/location/update", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const { latitude, longitude, accuracy, capturedAt, source } = req.body;
      
      if (!latitude || !longitude) {
        return res.status(400).json({ message: "Latitude and longitude are required" });
      }
      
      // Update user's latest location
      await storage.updateUserPreferences(userId, {
        latitude: latitude.toString(),
        longitude: longitude.toString(),
        locationUpdatedAt: new Date(),
      });
      
      // Log location (optional - for tracking history)
      try {
        await db.insert(userLocationLogs).values({
          userId: userId,
          latitude: latitude.toString(),
          longitude: longitude.toString(),
          accuracy: accuracy?.toString(),
          source: source || 'foreground',
        });
        
        // Update or insert latest location
        await db.insert(userLocationLatest).values({
          userId: userId,
          latitude: latitude.toString(),
          longitude: longitude.toString(),
          accuracy: accuracy?.toString(),
        }).onConflictDoUpdate({
          target: userLocationLatest.userId,
          set: {
            latitude: latitude.toString(),
            longitude: longitude.toString(),
            accuracy: accuracy?.toString(),
            updatedAt: new Date(),
          },
        });
      } catch (logErr) {
        console.error("Location log error (non-critical):", logErr);
      }
      
      res.json({ success: true, message: "Location updated" });
    } catch (err) {
      console.error("Location update error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Helper profile endpoints (헬퍼 프로필 조회/수정)
  app.get("/api/helpers/profile", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // Get helper credentials and vehicle if exists
      const credentials = await storage.getHelperCredential(userId);
      const vehicle = await storage.getHelperVehicle(userId);
      
      res.json({
        name: user.name || "",
        phoneNumber: user.phoneNumber || "",
        email: user.email || "",
        nickname: user.nickname || credentials?.name || "",
        address: user.address || credentials?.address || "",
        birthDate: user.birthDate || "",
        categories: credentials?.category ? [credentials.category] : [],
        regions: [],
        vehicleType: vehicle?.vehicleType || "",
        monthlyCommission: 0,
      });
    } catch (err) {
      console.error("Helper profile fetch error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/helpers/profile", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const { phoneNumber, nickname, email, address, categories, regions, vehicleType } = req.body;
      
      // Update user table fields
      const userUpdates: any = {};
      if (phoneNumber !== undefined) userUpdates.phoneNumber = phoneNumber;
      if (email !== undefined) userUpdates.email = email;
      if (address !== undefined) userUpdates.address = address;
      if (nickname !== undefined) userUpdates.nickname = nickname;
      
      if (Object.keys(userUpdates).length > 0) {
        await storage.updateUserPreferences(userId, userUpdates);
      }
      
      // Update or create helper credentials for category/nickname
      const existingCredentials = await storage.getHelperCredential(userId);
      if (existingCredentials) {
        const credUpdates: any = {};
        if (nickname !== undefined) credUpdates.name = nickname;
        if (categories && Array.isArray(categories) && categories.length > 0) {
          credUpdates.category = categories[0];
        }
        if (address !== undefined) credUpdates.address = address;
        
        if (Object.keys(credUpdates).length > 0) {
          await storage.updateHelperCredential(userId, credUpdates);
        }
      } else if (nickname || (categories && categories.length > 0)) {
        // Create new credentials if needed
        const user = req.user!;
        if (user) {
          await storage.createHelperCredential(userId, {
            name: nickname || user.name || "",
            phone: phoneNumber || user.phoneNumber || "",
            address: address || "",
            category: categories?.[0] || "기타",
          });
        }
      }
      
      res.json({ success: true });
    } catch (err) {
      console.error("Helper profile update error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // User password change (비밀번호 변경)
  app.post("/api/auth/change-password", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      const { currentPassword, newPassword } = req.body;
      
      if (!currentPassword || !newPassword) {
        return res.status(400).json({ message: "현재 비밀번호와 새 비밀번호를 입력해주세요" });
      }
      
      if (newPassword.length < 6) {
        return res.status(400).json({ message: "비밀번호는 6자 이상이어야 합니다" });
      }
      
      const isValidPassword = await bcrypt.compare(currentPassword, user.password);
      if (!isValidPassword) {
        return res.status(400).json({ message: "현재 비밀번호가 일치하지 않습니다" });
      }
      
      const hashedNewPassword = await bcrypt.hash(newPassword, 10);
      await storage.updateUser(userId, { password: hashedNewPassword });
      
      res.json({ success: true, message: "비밀번호가 변경되었습니다" });
    } catch (err) {
      // 운영 로그: 민감정보 제외
      console.error("[Auth] Password change failed:", (err as Error).message?.substring(0, 50));
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // User account deletion (회원 탈퇴)
  app.delete("/api/auth/delete-account", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // Soft delete by marking user as deleted (email/username prefixed to prevent reuse)
      await storage.updateUser(userId, { 
        email: `deleted_${Date.now()}_${user.email}`,
        username: `deleted_${Date.now()}_${user.username}`,
      });
      
      res.json({ success: true, message: "회원 탈퇴가 완료되었습니다" });
    } catch (err) {
      console.error("Account deletion error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // User tax invoice setting (의뢰인 세금계산서 발행 여부)
  app.patch("/api/user/tax-invoice", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const { taxInvoiceEnabled } = req.body;
      if (typeof taxInvoiceEnabled !== "boolean") {
        return res.status(400).json({ message: "taxInvoiceEnabled must be a boolean" });
      }
      
      const user = await storage.updateUserPreferences(userId, { taxInvoiceEnabled });
      res.json({ taxInvoiceEnabled: user?.taxInvoiceEnabled ?? taxInvoiceEnabled });
    } catch (err) {
      console.error("Tax invoice setting error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Notification logs (알림 발송 기록 - 본사 관리용)
  app.get("/api/admin/notification-logs", adminAuth, requirePermission("notifications.view"), async (req, res) => {
    try {
      const logs = await storage.getAllNotificationLogs();
      
      // Enrich with user info
      const logsWithUserInfo = await Promise.all(
        logs.map(async (log) => {
          const user = await storage.getUser(log.userId);
          return {
            ...log,
            userName: user?.name || "알 수 없음",
            userEmail: user?.email || "",
            userRole: user?.role || "",
          };
        })
      );
      
      res.json(logsWithUserInfo);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/notification-logs/stats", adminAuth, requirePermission("notifications.view"), async (req, res) => {
    try {
      const logs = await storage.getAllNotificationLogs();
      const total = logs.length;
      const read = logs.filter(l => l.isRead).length;
      const unread = total - read;
      const delivered = logs.filter(l => l.isDelivered).length;
      
      res.json({
        total,
        read,
        unread,
        delivered,
        deliveredRate: total > 0 ? Math.round((delivered / total) * 100) : 0,
        readRate: total > 0 ? Math.round((read / total) * 100) : 0,
      });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== 법적 안전장치 API ====================

  // 건별 전자계약 (Job Contracts)
  app.post("/api/job-contracts", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const contract = await storage.createJobContract({
        ...req.body,
        helperId: userId,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });
      
      // 지시 이력 로그 생성
      await storage.createInstructionLog({
        orderId: req.body.orderId,
        jobContractId: contract.id,
        issuerId: req.body.instructionIssuerId,
        issuerName: req.body.instructionIssuerName,
        issuerType: req.body.instructionIssuerType,
        instructionType: "contract_created",
        instructionContent: `계약 생성: ${req.body.workContent}`,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });
      
      res.json(contract);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/job-contracts", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const contracts = await storage.getHelperJobContracts(userId);
      res.json(contracts);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/job-contracts/:id", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const contract = await storage.getJobContract(Number(req.params.id));
      if (!contract) return res.status(404).json({ message: "Contract not found" });
      
      // 본인 관련 계약만 조회 가능
      if (contract.helperId !== userId && contract.requesterId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      res.json(contract);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/job-contracts/:id/sign", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const contract = await storage.getJobContract(Number(req.params.id));
      if (!contract) return res.status(404).json({ message: "Contract not found" });
      
      // 권한 확인: 계약 당사자만 서명 가능
      if (contract.helperId !== userId && contract.requesterId !== userId) {
        return res.status(403).json({ message: "계약 당사자만 서명할 수 있습니다" });
      }
      
      const updates: any = {
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      };
      
      // 기사 서명인 경우
      if (contract.helperId === userId) {
        updates.helperSignature = req.body.signature;
        updates.helperSignedAt = new Date();
      }
      // 의뢰인 서명인 경우
      else if (contract.requesterId === userId) {
        updates.requesterSignature = req.body.signature;
        updates.requesterSignedAt = new Date();
      }
      
      // 양측 서명 완료 시에만 status를 signed로 변경
      const helperSigned = updates.helperSignature || contract.helperSignature;
      const requesterSigned = updates.requesterSignature || contract.requesterSignature;
      if (helperSigned && requesterSigned) {
        updates.status = "signed";
      }
      
      const updated = await storage.updateJobContract(Number(req.params.id), updates);
      
      // 지시 이력 로그
      await storage.createInstructionLog({
        jobContractId: contract.id,
        orderId: contract.orderId,
        issuerId: userId,
        instructionType: "contract_signed",
        instructionContent: `계약 서명 완료`,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 근무 세션 (Work Sessions)
  app.post("/api/work-sessions/check-in", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      // 기존 세션 확인
      let session = await storage.getWorkSessionByOrder(req.body.orderId);
      
      if (session) {
        // 기존 세션 업데이트
        session = await storage.updateWorkSession(session.id, {
          checkInTime: new Date(),
          checkInLatitude: req.body.latitude,
          checkInLongitude: req.body.longitude,
          checkInAddress: req.body.address,
          status: "checked_in",
        });
      } else {
        // 새 세션 생성
        session = await storage.createWorkSession({
          orderId: req.body.orderId,
          jobContractId: req.body.jobContractId,
          helperId: userId,
          checkInTime: new Date(),
          checkInLatitude: req.body.latitude,
          checkInLongitude: req.body.longitude,
          checkInAddress: req.body.address,
          status: "checked_in",
        });
      }
      
      // 출근 증빙 이벤트 기록
      await storage.createWorkProofEvent({
        workSessionId: session.id,
        helperId: userId,
        eventType: "check_in",
        latitude: req.body.latitude,
        longitude: req.body.longitude,
        address: req.body.address,
        capturedAt: new Date(),
      });
      
      res.json(session);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/work-sessions/check-out", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const session = await storage.getWorkSessionByOrder(req.body.orderId);
      if (!session) return res.status(404).json({ message: "Work session not found" });
      
      const updated = await storage.updateWorkSession(session.id, {
        checkOutTime: new Date(),
        checkOutLatitude: req.body.latitude,
        checkOutLongitude: req.body.longitude,
        checkOutAddress: req.body.address,
        checkOutPhotoUrl: req.body.photoUrl,
        status: "checked_out",
      });
      
      // 퇴근 증빙 이벤트 기록
      await storage.createWorkProofEvent({
        workSessionId: session.id,
        helperId: userId,
        eventType: "check_out",
        photoUrl: req.body.photoUrl,
        latitude: req.body.latitude,
        longitude: req.body.longitude,
        address: req.body.address,
        capturedAt: new Date(),
      });
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/work-sessions/:id/confirm", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const session = await storage.getWorkSession(Number(req.params.id));
      if (!session) return res.status(404).json({ message: "Work session not found" });
      
      const updated = await storage.updateWorkSession(session.id, {
        workConfirmed: true,
        workConfirmedAt: new Date(),
        status: "confirmed",
      });
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/work-sessions", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const sessions = await storage.getHelperWorkSessions(userId);
      res.json(sessions);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/work-sessions/order/:orderId", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const session = await storage.getWorkSessionByOrder(Number(req.params.orderId));
      if (session && session.helperId !== userId) {
        // 본인 세션만 조회 가능 (또는 관련 오더 당사자)
        const order = await storage.getOrder(Number(req.params.orderId));
        if (!order || (order.requesterId !== userId)) {
          return res.status(403).json({ message: "Access denied" });
        }
      }
      
      res.json(session || null);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 근무 증빙 이벤트 (Work Proof Events)
  app.post("/api/work-proof-events", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const event = await storage.createWorkProofEvent({
        ...req.body,
        helperId: userId,
        capturedAt: new Date(),
      });
      
      res.json(event);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/work-proof-events/:sessionId", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const session = await storage.getWorkSession(Number(req.params.sessionId));
      if (!session) return res.status(404).json({ message: "Session not found" });
      
      // 본인 세션의 증빙만 조회 가능
      if (session.helperId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const events = await storage.getWorkProofEventsBySession(Number(req.params.sessionId));
      res.json(events);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 정산 명세서 (Settlement Statements)
  app.post("/api/settlement-statements", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const { orderId, helperId, basePay, additionalPay, penalty, deduction, lineItems, ...rest } = req.body;
      
      // 수수료율 결정 로직
      let commissionRate = 0;
      
      // 1. 오더에서 택배사 정보 가져오기
      if (orderId) {
        const order = await storage.getOrder(orderId);
        if (order?.companyName) {
          const courierSettings = await storage.getAllCourierSettings();
          const courierSetting = courierSettings.find(c => c.courierName === order.companyName);
          if (courierSetting) {
            commissionRate = courierSetting.commissionRate || 0;
          }
        }
      }
      
      // 2. 헬퍼의 팀 수수료율 확인 (팀 수수료율이 있으면 우선 적용)
      if (helperId) {
        const helper = await storage.getUser(helperId);
        if (helper?.teamName) {
          const allTeams = await storage.getAllTeams();
          const team = allTeams.find(t => t.name === helper.teamName);
          if (team) {
            const teamCommission = await storage.getTeamCommissionOverride(team.id);
            if (teamCommission && teamCommission.commissionRate > 0) {
              commissionRate = teamCommission.commissionRate;
            }
          }
        }
      }
      
      // 3. 금액 계산
      const basePayAmount = Number(basePay) || 0;
      const additionalPayAmount = Number(additionalPay) || 0;
      const penaltyAmount = Number(penalty) || 0;
      const deductionAmount = Number(deduction) || 0;
      
      const totalAmount = basePayAmount + additionalPayAmount;
      const commissionAmount = Math.round(totalAmount * (commissionRate / 100));
      const netAmount = totalAmount - commissionAmount - penaltyAmount - deductionAmount;
      
      const statement = await storage.createSettlementStatement({
        orderId,
        basePay: basePayAmount,
        additionalPay: additionalPayAmount,
        penalty: penaltyAmount,
        deduction: deductionAmount,
        commissionRate,
        commissionAmount,
        totalAmount,
        netAmount,
        ...rest,
      });
      
      // 정산 항목 상세 생성
      if (lineItems && Array.isArray(lineItems)) {
        for (const item of lineItems) {
          await storage.createSettlementLineItem({
            ...item,
            statementId: statement.id,
          });
        }
      }
      
      res.json(statement);
    } catch (err) {
      console.error("Settlement creation error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/settlement-statements", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const statements = await storage.getHelperSettlementStatements(userId);
      res.json(statements);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/settlement-statements/:id", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const statement = await storage.getSettlementStatement(Number(req.params.id));
      if (!statement) return res.status(404).json({ message: "Statement not found" });
      
      // 본인 관련 정산명세서만 조회 가능
      if (statement.helperId !== userId && statement.requesterId !== userId) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const lineItems = await storage.getSettlementLineItems(statement.id);
      res.json({ ...statement, lineItems });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/settlement-statements/:id/confirm", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const statement = await storage.getSettlementStatement(Number(req.params.id));
      if (!statement) return res.status(404).json({ message: "Statement not found" });
      
      // 본인 정산명세서만 확인 가능
      if (statement.helperId !== userId) {
        return res.status(403).json({ message: "본인 정산명세서만 확인할 수 있습니다" });
      }
      
      const updated = await storage.updateSettlementStatement(statement.id, {
        helperConfirmed: true,
        helperConfirmedAt: new Date(),
        helperSignature: req.body.signature,
        helperIpAddress: req.ip,
        helperUserAgent: req.headers["user-agent"],
        status: "confirmed",
      });
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 지시 이력 로그 (Instruction Logs)
  app.get("/api/instruction-logs/order/:orderId", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      // 본인 관련 오더의 지시 이력만 조회 가능
      const order = await storage.getOrder(Number(req.params.orderId));
      if (!order) return res.status(404).json({ message: "Order not found" });
      
      // 관련 계약 확인
      const contracts = await storage.getHelperContracts(userId);
      const isHelperContract = contracts.some(c => c.orderId === Number(req.params.orderId));
      const isRequester = order.requesterId === userId;
      
      if (!isHelperContract && !isRequester) {
        return res.status(403).json({ message: "Access denied" });
      }
      
      const logs = await storage.getInstructionLogsByOrder(Number(req.params.orderId));
      res.json(logs);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/instruction-logs", adminAuth, requirePermission("contracts.view"), async (req, res) => {
    try {
      const logs = await storage.getAllInstructionLogs();
      res.json(logs);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 사고/분쟁 접수 (Incident Reports)
  app.post("/api/incident-reports", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // 사고 유형에 따른 책임주체 자동 제안
      const incidentType = req.body.incidentType;
      let suggestedResponsibility = "platform";
      
      if (incidentType === "damage") suggestedResponsibility = "helper";
      else if (incidentType === "loss") suggestedResponsibility = "helper";
      else if (incidentType === "delay") suggestedResponsibility = "shared";
      else if (incidentType === "missing") suggestedResponsibility = "requester";
      else if (incidentType === "absent") suggestedResponsibility = "helper";
      
      const report = await storage.createIncidentReport({
        ...req.body,
        reporterId: userId,
        reporterType: user?.role,
        suggestedResponsibility,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });
      
      // 분쟁 접수 알림: 관리자에게 알림
      const admins = await storage.getAllUsers();
      const hqStaff = admins.filter(u => u.isHqStaff);
      for (const admin of hqStaff) {
        await storage.createNotification({
          userId: admin.id,
          type: "dispute_submitted",
          title: "새로운 분쟁 접수",
          message: `${user?.name || "사용자"}님이 분쟁을 접수했습니다. (유형: ${incidentType})`,
          relatedId: report.id,
        });
      }
      
      res.json(report);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/incident-reports", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      const allReports = await storage.getAllIncidentReports();
      
      // 본인 관련 사고만 조회
      const reports = allReports.filter(r => 
        r.reporterId === userId || 
        r.helperId === userId || 
        r.requesterId === userId
      );
      
      res.json(reports);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/incident-reports/:id", async (req, res) => {
    try {
      const report = await storage.getIncidentReport(Number(req.params.id));
      if (!report) return res.status(404).json({ message: "Report not found" });
      
      const evidence = await storage.getIncidentEvidence(report.id);
      res.json({ ...report, evidence });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/incident-reports/:id/evidence", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const evidence = await storage.createIncidentEvidence({
        ...req.body,
        incidentId: Number(req.params.id),
        uploadedBy: userId,
      });
      
      res.json(evidence);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/incident-reports/:id", adminAuth, requirePermission("disputes.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const report = await storage.getIncidentReport(Number(req.params.id));
      if (!report) return res.status(404).json({ message: "Report not found" });
      
      const updates = {
        ...req.body,
        resolvedBy: req.body.status === "resolved" ? userId : undefined,
        resolvedAt: req.body.status === "resolved" ? new Date() : undefined,
      };
      
      const updated = await storage.updateIncidentReport(Number(req.params.id), updates);
      
      // 분쟁 해결 알림: 관련 당사자들에게 알림
      if (req.body.status === "resolved") {
        const partiesToNotify = [report.reporterId, report.helperId, report.requesterId].filter(Boolean) as string[];
        const uniqueParties = Array.from(new Set(partiesToNotify));
        
        for (const userId of uniqueParties) {
          await storage.createNotification({
            userId,
            type: "dispute_resolved",
            title: "분쟁 해결 완료",
            message: `분쟁(ID: ${report.id})이 해결되었습니다. 결과: ${req.body.resolution || "해결 완료"}`,
            relatedId: report.id,
          });
        }
      }
      
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/incident-reports", adminAuth, requirePermission("disputes.view"), async (req, res) => {
    try {
      const reports = await storage.getAllIncidentReports();
      res.json(reports);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 대체근무 요청 (Substitute Requests)
  app.post("/api/substitute-requests", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      // 급한 요청일수록 수수료 가중 적용
      const urgencyLevel = req.body.urgencyLevel || "normal";
      let urgencyPremium = 0;
      const basePayment = req.body.basePayment || 0;
      
      if (urgencyLevel === "same_day") urgencyPremium = Math.round(basePayment * 0.3); // 30% 추가
      else if (urgencyLevel === "next_day") urgencyPremium = Math.round(basePayment * 0.15); // 15% 추가
      
      const request = await storage.createSubstituteRequest({
        ...req.body,
        requesterId: userId,
        helperId: null,
        trackingNumber: null,
        requestDate: new Date().toISOString().split("T")[0],
        urgencyPremium,
        totalPayment: basePayment + urgencyPremium,
      });
      
      res.json(request);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/substitute-requests", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const requests = await storage.getRequesterSubstituteRequests(userId);
      res.json(requests);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/substitute-requests/pending", async (req, res) => {
    try {
      const requests = await storage.getPendingSubstituteRequests();
      res.json(requests);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/substitute-requests/:id/match", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      const request = await storage.getSubstituteRequest(Number(req.params.id));
      if (!request) return res.status(404).json({ message: "Request not found" });
      
      const updated = await storage.updateSubstituteRequest(request.id, {
        matchedHelperId: userId,
        matchedAt: new Date(),
        status: "matched",
      });
      
      // 건별 전자계약 자동 생성
      const contract = await storage.createJobContract({
        orderId: request.orderId,
        helperId: userId,
        requesterId: request.requesterId,
        workDate: request.workDate,
        workContent: request.workContent || "대체근무",
        paymentAmount: request.totalPayment || 0,
        status: "pending",
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });
      
      res.json({ request: updated, contract });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/substitute-requests", adminAuth, requirePermission("dispatch.view"), async (req, res) => {
    try {
      const requests = await storage.getAllSubstituteRequests();
      res.json(requests);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: 모든 법적 계약 조회
  app.get("/api/admin/job-contracts", adminAuth, requirePermission("contracts.view"), async (req, res) => {
    try {
      const contracts = await storage.getAllJobContracts();
      res.json(contracts);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin: 모든 정산 명세서 조회
  app.get("/api/admin/settlement-statements", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const statements = await storage.getAllSettlementStatements();
      res.json(statements);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== 법적 보호 API (계약 실행, 결제, 분쟁 워크플로우) ====================

  // Validation schemas for legal protection APIs
  const contractExecutionSchema = z.object({
    triggerType: z.enum(["terms_checked", "payment_confirmed", "execution_recorded"]),
    initiatorRole: z.enum(["helper", "requester"]).optional(),
    paymentId: z.number().nullable().optional(),
    termsChecked: z.boolean().optional(),
  });

  const paymentCreateSchema = z.object({
    contractId: z.number().nullable().optional(),
    jobContractId: z.number().nullable().optional(),
    orderId: z.number().nullable().optional(),
    amount: z.number().min(1, "결제 금액은 1원 이상이어야 합니다"),
    paymentType: z.enum(["deposit", "balance", "full"]),
    provider: z.string().optional(),
  });

  const paymentUpdateSchema = z.object({
    status: z.enum(["initiated", "authorized", "captured", "canceled", "refunded"]),
    reason: z.string().optional(),
  });

  const workSessionStartSchema = z.object({
    triggerSource: z.enum(["check_in", "first_proof", "requester_manual"]),
    proofEventId: z.number().nullable().optional(),
  });

  const workProofSchema = z.object({
    eventType: z.enum(["delivery", "pickup", "return", "incident", "other"]).optional(),
    photoUrl: z.string().optional(),
    latitude: z.string().optional(),
    longitude: z.string().optional(),
    address: z.string().optional(),
    notes: z.string().optional(),
  });

  const incidentWorkflowSchema = z.object({
    action: z.enum(["evidence_requested", "evidence_submitted", "hold_settlement", "review_started", "resolved", "escalated", "closed"]),
    notes: z.string().optional(),
    dueHours: z.number().optional(),
    resolution: z.string().optional(),
    resolutionAmount: z.number().optional(),
    escalatedTo: z.string().optional(),
  });

  // 계약 실행 트리거 (결제 + 약관 동의 = 법적 효력 발생)
  app.post("/api/contracts/:id/execute", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      // Validate input
      const validatedInput = contractExecutionSchema.parse(req.body);
      const contractId = Number(req.params.id);
      
      // Verify contract exists and user is authorized
      const contract = await storage.getContract(contractId);
      if (!contract) {
        return res.status(404).json({ message: "Contract not found" });
      }
      
      // Only requester can execute a contract
      if (contract.requesterId !== userId) {
        return res.status(403).json({ message: "의뢰인만 계약을 실행할 수 있습니다" });
      }
      
      // Check if contract is already executed
      if (contract.status === "deposit_paid" || contract.status === "completed") {
        return res.status(400).json({ message: "이미 실행된 계약입니다" });
      }
      
      // Verify payment exists and matches requirements for payment_confirmed trigger
      let linkedPayment = null;
      if (validatedInput.triggerType === "payment_confirmed") {
        if (!validatedInput.paymentId) {
          return res.status(400).json({ message: "결제 ID가 필요합니다" });
        }
        
        const payment = await storage.getPayment(validatedInput.paymentId);
        if (!payment) {
          return res.status(404).json({ message: "결제 정보를 찾을 수 없습니다" });
        }
        
        // Payment must be for this contract, by this requester, and captured
        if (payment.contractId !== contractId) {
          return res.status(400).json({ message: "이 계약과 연결된 결제가 아닙니다" });
        }
        if (payment.payerId !== userId) {
          return res.status(403).json({ message: "본인이 결제한 건만 사용할 수 있습니다" });
        }
        if (payment.status !== "captured") {
          return res.status(400).json({ message: "결제가 완료되지 않았습니다" });
        }
        
        // Verify minimum payment amount (at least deposit amount)
        if (contract.depositAmount && payment.amount < contract.depositAmount) {
          return res.status(400).json({ message: "결제 금액이 예약금보다 적습니다" });
        }
        
        linkedPayment = payment;
      }
      
      // 계약 실행 이벤트 기록
      const executionEvent = await storage.createContractExecutionEvent({
        contractId,
        contractType: "service_contract",
        triggerType: validatedInput.triggerType,
        initiatedBy: userId,
        initiatorRole: "requester",
        paymentId: linkedPayment?.id || null,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
        metadata: JSON.stringify({
          termsChecked: validatedInput.termsChecked,
          executionTime: new Date().toISOString(),
          paymentAmount: linkedPayment?.amount,
        }),
      });
      
      // 계약 상태 업데이트
      await storage.updateContract(contractId, {
        status: "deposit_paid",
        depositPaid: true,
          depositPaidAt: new Date(),
          downPaymentStatus: "paid",
      });
      
      res.json({ success: true, executionEvent });
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      console.error("Contract execution error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 건별 계약 실행 트리거
  app.post("/api/job-contracts/:id/execute", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      // Validate input
      const validatedInput = contractExecutionSchema.parse(req.body);
      const jobContractId = Number(req.params.id);
      
      const jobContract = await storage.getJobContract(jobContractId);
      if (!jobContract) {
        return res.status(404).json({ message: "Job contract not found" });
      }
      
      // Only helper or requester in the contract can execute
      if (jobContract.helperId !== userId && jobContract.requesterId !== userId) {
        return res.status(403).json({ message: "이 계약에 대한 권한이 없습니다" });
      }
      
      // Verify payment exists if payment_confirmed trigger
      if (validatedInput.triggerType === "payment_confirmed") {
        const existingPayment = await storage.getPaymentByJobContract(jobContractId);
        if (!existingPayment || existingPayment.status !== "captured") {
          return res.status(400).json({ message: "결제 완료 후에만 계약 실행이 가능합니다" });
        }
      }
      
      const initiatorRole = userId === jobContract.helperId ? "helper" : "requester";
      
      // 계약 실행 이벤트 기록
      const executionEvent = await storage.createContractExecutionEvent({
        contractId: jobContractId,
        contractType: "job_contract",
        triggerType: validatedInput.triggerType,
        initiatedBy: userId,
        initiatorRole,
        paymentId: validatedInput.paymentId || null,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
        metadata: JSON.stringify({
          termsChecked: validatedInput.termsChecked,
          executionTime: new Date().toISOString(),
        }),
      });
      
      // 계약 상태 업데이트
      await storage.updateJobContract(jobContractId, {
        status: "executed",
        executionEventId: executionEvent.id,
        executedAt: new Date(),
        executionStatus: "executed",
      });
      
      res.json({ success: true, executionEvent });
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      console.error("Job contract execution error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 결제 API
  app.post("/api/payments", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      // Validate input
      const validatedInput = paymentCreateSchema.parse(req.body);
      
      // At least one contract link is required
      if (!validatedInput.contractId && !validatedInput.jobContractId) {
        return res.status(400).json({ message: "계약 ID가 필요합니다" });
      }
      
      // Verify contract linkage and authorization
      if (validatedInput.contractId) {
        const contract = await storage.getContract(validatedInput.contractId);
        if (!contract) {
          return res.status(404).json({ message: "Contract not found" });
        }
        // Only requester can create payments for service contracts
        if (contract.requesterId !== userId) {
          return res.status(403).json({ message: "결제를 생성할 권한이 없습니다" });
        }
        
        // Check for existing pending/captured payments on this contract
        const existingPayment = await storage.getPaymentByContract(validatedInput.contractId);
        if (existingPayment && (existingPayment.status === "initiated" || existingPayment.status === "authorized" || existingPayment.status === "captured")) {
          return res.status(400).json({ message: "이 계약에 이미 진행 중인 결제가 있습니다" });
        }
        
        // Validate minimum payment amount matches contract
        if (validatedInput.paymentType === "deposit" && contract.depositAmount && validatedInput.amount < contract.depositAmount) {
          return res.status(400).json({ message: "예약금 금액이 부족합니다" });
        }
      }
      
      if (validatedInput.jobContractId) {
        const jobContract = await storage.getJobContract(validatedInput.jobContractId);
        if (!jobContract) {
          return res.status(404).json({ message: "Job contract not found" });
        }
        // Only requester can create payments for job contracts
        if (jobContract.requesterId !== userId) {
          return res.status(403).json({ message: "결제를 생성할 권한이 없습니다" });
        }
        
        // Check for existing pending/captured payments on this job contract
        const existingPayment = await storage.getPaymentByJobContract(validatedInput.jobContractId);
        if (existingPayment && (existingPayment.status === "initiated" || existingPayment.status === "authorized" || existingPayment.status === "captured")) {
          return res.status(400).json({ message: "이 계약에 이미 진행 중인 결제가 있습니다" });
        }
      }
      
      const payment = await storage.createPayment({
        contractId: validatedInput.contractId,
        jobContractId: validatedInput.jobContractId,
        orderId: validatedInput.orderId,
        payerId: userId,
        provider: validatedInput.provider || "manual",
        amount: validatedInput.amount,
        paymentType: validatedInput.paymentType,
        status: "initiated",
        depositFlag: validatedInput.paymentType === "deposit",
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });
      
      // 결제 상태 이벤트 기록
      await storage.createPaymentStatusEvent({
        paymentId: payment.id,
        previousStatus: null,
        newStatus: "initiated",
        changedBy: userId,
        reason: "결제 생성",
      });
      
      res.json(payment);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      console.error("Payment creation error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/payments/:id", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // Validate input
      const validatedInput = paymentUpdateSchema.parse(req.body);
      
      const paymentId = Number(req.params.id);
      const payment = await storage.getPayment(paymentId);
      if (!payment) {
        return res.status(404).json({ message: "Payment not found" });
      }
      
      // Critical transitions require HQ staff authorization
      const criticalTransitions = ["captured", "refunded"];
      if (criticalTransitions.includes(validatedInput.status)) {
        if (!user?.isHqStaff) {
          return res.status(403).json({ message: "본사 직원만 결제 완료/환불 처리할 수 있습니다" });
        }
      } else {
        // Non-critical transitions: Only payer or HQ staff can update
        if (payment.payerId !== userId && !user?.isHqStaff) {
          return res.status(403).json({ message: "결제 상태를 변경할 권한이 없습니다" });
        }
      }
      
      // Validate status transitions
      const validTransitions: Record<string, string[]> = {
        initiated: ["authorized", "captured", "canceled"],
        authorized: ["captured", "canceled"],
        captured: ["refunded"],
        canceled: [],
        refunded: [],
      };
      
      const currentStatus = payment.status || "initiated";
      if (!validTransitions[currentStatus]?.includes(validatedInput.status)) {
        return res.status(400).json({ 
          message: `${currentStatus}에서 ${validatedInput.status}로 변경할 수 없습니다` 
        });
      }
      
      const previousStatus = payment.status;
      const updates: any = { status: validatedInput.status };
      if (validatedInput.status === "captured") updates.paidAt = new Date();
      if (validatedInput.status === "canceled") { 
        updates.canceledAt = new Date(); 
        updates.cancelReason = validatedInput.reason; 
      }
      if (validatedInput.status === "refunded") { 
        updates.refundedAt = new Date(); 
        updates.refundReason = validatedInput.reason; 
      }
      
      const updated = await storage.updatePayment(paymentId, updates);
      
      // 결제 상태 변경 이벤트 기록
      await storage.createPaymentStatusEvent({
        paymentId,
        previousStatus,
        newStatus: validatedInput.status,
        changedBy: userId,
        reason: validatedInput.reason,
      });
      
      // 결제 완료 시 계약 실행 트리거 - 자동 실행하지 않음, 의뢰인이 별도로 실행해야 함
      // (이전에는 자동으로 계약 실행 이벤트를 생성했으나, 분리하여 명시적 실행 필요)
      
      // 환불/취소 시 계약 상태 업데이트
      if ((validatedInput.status === "refunded" || validatedInput.status === "canceled") && payment.contractId) {
        await storage.updateContract(payment.contractId, { status: "cancelled" });
      }
      if ((validatedInput.status === "refunded" || validatedInput.status === "canceled") && payment.jobContractId) {
        await storage.updateJobContract(payment.jobContractId, { 
          status: "voided",
          executionStatus: "voided"
        });
      }
      
      res.json(updated);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      console.error("Payment update error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Admin only - get all payments
  app.get("/api/payments", adminAuth, requirePermission("payments.view"), async (req, res) => {
    try {
      const payments = await storage.getAllPayments();
      res.json(payments);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/payments/:id/events", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      const payment = await storage.getPayment(Number(req.params.id));
      if (!payment) {
        return res.status(404).json({ message: "Payment not found" });
      }
      
      // Only payer or HQ staff can view payment events
      if (payment.payerId !== userId && !user?.isHqStaff) {
        return res.status(403).json({ message: "결제 이벤트를 조회할 권한이 없습니다" });
      }
      
      const events = await storage.getPaymentStatusEvents(Number(req.params.id));
      res.json(events);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 업무 시작 트리거 (첫 번째 증빙 또는 수동 시작)
  app.post("/api/work-sessions/:id/start", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // Validate input
      const validatedInput = workSessionStartSchema.parse(req.body);
      
      const sessionId = Number(req.params.id);
      const session = await storage.getWorkSession(sessionId);
      if (!session) {
        return res.status(404).json({ message: "Work session not found" });
      }
      
      // Authorization: Only helper in session, related requester, or HQ staff can start
      let isAuthorized = false;
      if (session.helperId === userId) {
        isAuthorized = true;
      } else if (user?.isHqStaff) {
        isAuthorized = true;
      } else if (session.jobContractId) {
        const jobContract = await storage.getJobContract(session.jobContractId);
        if (jobContract?.requesterId === userId) {
          isAuthorized = true;
        }
      }
      
      if (!isAuthorized) {
        return res.status(403).json({ message: "업무 세션을 시작할 권한이 없습니다" });
      }
      
      const updated = await storage.updateWorkSession(sessionId, {
        status: "started",
        startTriggerSource: validatedInput.triggerSource,
        startEventId: validatedInput.proofEventId || null,
        startedAt: new Date(),
        startedBy: userId,
      });
      
      res.json(updated);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      console.error("Work session start error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 첫 번째 증빙 제출 시 자동 업무 시작
  app.post("/api/work-sessions/:id/proof", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      
      // Validate input
      const validatedInput = workProofSchema.parse(req.body);
      
      const sessionId = Number(req.params.id);
      const session = await storage.getWorkSession(sessionId);
      if (!session) {
        return res.status(404).json({ message: "Work session not found" });
      }
      
      // Only the helper assigned to this session can submit proof
      if (session.helperId !== userId) {
        return res.status(403).json({ message: "이 세션에 증빙을 제출할 권한이 없습니다" });
      }
      
      // 기존 증빙 확인
      const existingProofs = await storage.getWorkProofEventsBySession(sessionId);
      const isFirstProof = existingProofs.length === 0;
      
      // 증빙 이벤트 생성
      const proofEvent = await storage.createWorkProofEvent({
        workSessionId: sessionId,
        helperId: userId,
        eventType: validatedInput.eventType || "delivery",
        photoUrl: validatedInput.photoUrl,
        latitude: validatedInput.latitude,
        longitude: validatedInput.longitude,
        address: validatedInput.address,
        notes: validatedInput.notes,
        isFirstProof,
        verifiedAt: new Date(),
      });
      
      // 첫 번째 증빙인 경우 자동으로 업무 시작
      if (isFirstProof && session.status === "pending") {
        await storage.updateWorkSession(sessionId, {
          status: "started",
          startTriggerSource: "first_proof",
          startEventId: proofEvent.id,
          startedAt: new Date(),
          startedBy: userId,
        });
      }
      
      res.json(proofEvent);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      console.error("Work proof submission error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 분쟁 목록 조회
  app.get("/api/incidents", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const user = await storage.getUser(userId);
      
      // HQ staff can see all incidents, others only their own
      if (user?.isHqStaff) {
        const incidents = await storage.getAllIncidentReports();
        return res.json(incidents);
      } else {
        const incidents = await storage.getIncidentsByUser(userId);
        return res.json(incidents);
      }
    } catch (err) {
      console.error("Get incidents error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 분쟁 신규 접수
  const createIncidentSchema = z.object({
    incidentType: z.enum(["damage", "delay", "dispute", "complaint", "other"]),
    description: z.string().min(10, "설명은 최소 10자 이상 입력해주세요"),
    damageAmount: z.number().optional(),
    orderId: z.number().optional(),
    jobContractId: z.number().optional(),
  });
  
  app.post("/api/incidents", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const user = await storage.getUser(userId);
      
      // Zod 스키마 검증
      const validatedData = createIncidentSchema.parse(req.body);
      
      // orderId 권한 검증 - 본인의 오더인지 확인
      if (validatedData.orderId) {
        const order = await storage.getOrder(validatedData.orderId);
        if (!order) {
          return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
        }
        // 헬퍼는 자신에게 배정된 오더, 의뢰인은 자신이 생성한 오더에만 분쟁 등록 가능
        if (user?.role === "helper" && order.matchedHelperId !== userId) {
          return res.status(403).json({ message: "본인에게 배정된 오더에만 분쟁을 등록할 수 있습니다" });
        }
        if (user?.role === "requester" && order.requesterId !== userId) {
          return res.status(403).json({ message: "본인이 등록한 오더에만 분쟁을 등록할 수 있습니다" });
        }
      }
      
      // jobContractId 권한 검증
      if (validatedData.jobContractId) {
        const contract = await storage.getJobContract(validatedData.jobContractId);
        if (!contract) {
          return res.status(404).json({ message: "계약을 찾을 수 없습니다" });
        }
        if (user?.role === "helper" && contract.helperId !== userId) {
          return res.status(403).json({ message: "본인의 계약에만 분쟁을 등록할 수 있습니다" });
        }
        if (user?.role === "requester" && contract.requesterId !== userId) {
          return res.status(403).json({ message: "본인의 계약에만 분쟁을 등록할 수 있습니다" });
        }
      }
      
      const incident = await storage.createIncidentReport({
        reporterId: userId,
        reporterType: user?.role || "helper",
        incidentType: validatedData.incidentType,
        description: validatedData.description,
        damageAmount: validatedData.damageAmount,
        orderId: validatedData.orderId,
        jobContractId: validatedData.jobContractId,
        helperId: user?.role === "helper" ? userId : undefined,
        requesterId: user?.role === "requester" ? userId : undefined,
        status: "submitted",
        incidentDate: new Date().toISOString().split("T")[0],
      });
      
      // 분쟁 접수 액션 로그 생성
      await storage.createIncidentAction({
        incidentId: incident.id,
        actorId: userId,
        actorRole: user?.role || "helper",
        actionType: "submitted",
        previousStatus: null,
        newStatus: "submitted",
        notes: validatedData.description,
      });
      
      res.status(201).json(incident);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      console.error("Create incident error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 분쟁 처리 워크플로우
  app.post("/api/incidents/:id/workflow", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const userId = req.user!.id;
      const user = req.user!;
      
      // Validate input
      const validatedInput = incidentWorkflowSchema.parse(req.body);
      
      const incidentId = Number(req.params.id);
      const incident = await storage.getIncidentReport(incidentId);
      if (!incident) {
        return res.status(404).json({ message: "Incident not found" });
      }
      
      // Authorization: Role-based action permissions
      const isHqStaff = user?.isHqStaff;
      const isReporter = incident.reporterId === userId;
      
      // State-based constraints: prevent actions on closed/resolved incidents
      const closedStatuses = ["closed", "resolved"];
      if (closedStatuses.includes(incident.status || "")) {
        if (validatedInput.action !== "closed" || !isHqStaff) {
          return res.status(400).json({ message: "이미 종결된 분쟁입니다" });
        }
      }
      
      // Define valid status transitions
      const validStatusTransitions: Record<string, string[]> = {
        submitted: ["awaiting_evidence", "under_review", "resolved", "closed"],
        awaiting_evidence: ["under_review", "resolved", "closed"],
        under_review: ["resolved", "escalated", "closed"],
        escalated: ["under_review", "resolved", "closed"],
        resolved: ["closed"],
        closed: [],
      };
      
      // Define which actions each role can perform
      const hqOnlyActions = ["evidence_requested", "hold_settlement", "review_started", "resolved", "escalated", "closed"];
      const reporterActions = ["evidence_submitted"];
      
      if (hqOnlyActions.includes(validatedInput.action) && !isHqStaff) {
        return res.status(403).json({ message: "본사 직원만 수행할 수 있는 작업입니다" });
      }
      
      if (reporterActions.includes(validatedInput.action) && !isReporter && !isHqStaff) {
        return res.status(403).json({ message: "신고자 또는 본사 직원만 증빙을 제출할 수 있습니다" });
      }
      
      // Evidence submission is only valid when awaiting_evidence
      if (validatedInput.action === "evidence_submitted" && incident.status !== "awaiting_evidence") {
        return res.status(400).json({ message: "증빙 요청 상태에서만 증빙을 제출할 수 있습니다" });
      }
      
      const previousStatus = incident.status || "submitted";
      let newStatus = previousStatus;
      const updates: any = {};
      
      switch (validatedInput.action) {
        case "evidence_requested":
          if (!validStatusTransitions[previousStatus]?.includes("awaiting_evidence")) {
            return res.status(400).json({ message: "현재 상태에서 증빙 요청을 할 수 없습니다" });
          }
          newStatus = "awaiting_evidence";
          const dueHours = validatedInput.dueHours || 48;
          updates.evidenceDueAt = new Date(Date.now() + dueHours * 60 * 60 * 1000);
          break;
        case "evidence_submitted":
          newStatus = "under_review";
          break;
        case "hold_settlement":
          if (incident.settlementId) {
            await storage.updateSettlementStatement(incident.settlementId, {
              isOnHold: true,
              holdReason: validatedInput.notes,
              holdIncidentId: incidentId,
              holdStartedAt: new Date(),
              status: "on_hold",
            });
            updates.settlementHoldId = incident.settlementId;
          }
          break;
        case "review_started":
          if (!validStatusTransitions[previousStatus]?.includes("under_review")) {
            return res.status(400).json({ message: "현재 상태에서 검토를 시작할 수 없습니다" });
          }
          newStatus = "under_review";
          updates.reviewStartedAt = new Date();
          updates.reviewerId = userId;
          break;
        case "resolved":
          if (!validStatusTransitions[previousStatus]?.includes("resolved")) {
            return res.status(400).json({ message: "현재 상태에서 해결할 수 없습니다" });
          }
          if (!validatedInput.resolution) {
            return res.status(400).json({ message: "해결 내용이 필요합니다" });
          }
          newStatus = "resolved";
          updates.resolvedBy = userId;
          updates.resolvedAt = new Date();
          updates.resolution = validatedInput.resolution;
          updates.resolutionAmount = validatedInput.resolutionAmount;
          if (incident.settlementHoldId) {
            await storage.updateSettlementStatement(incident.settlementHoldId, {
              isOnHold: false,
              holdReleasedAt: new Date(),
              status: "confirmed",
            });
          }
          break;
        case "escalated":
          if (!validStatusTransitions[previousStatus]?.includes("escalated")) {
            return res.status(400).json({ message: "현재 상태에서 에스컬레이션할 수 없습니다" });
          }
          if (!validatedInput.escalatedTo) {
            return res.status(400).json({ message: "에스컬레이션 대상이 필요합니다" });
          }
          newStatus = "escalated";
          updates.escalatedAt = new Date();
          updates.escalatedTo = validatedInput.escalatedTo;
          break;
        case "closed":
          if (!validStatusTransitions[previousStatus]?.includes("closed") && previousStatus !== "resolved") {
            return res.status(400).json({ message: "현재 상태에서 종결할 수 없습니다" });
          }
          newStatus = "closed";
          break;
      }
      
      updates.status = newStatus;
      const updatedIncident = await storage.updateIncidentReport(incidentId, updates);
      
      // 액션 로그 기록
      await storage.createIncidentAction({
        incidentId,
        actorId: userId,
        actorRole: isHqStaff ? "hq_staff" : (user?.role || "unknown"),
        actionType: validatedInput.action,
        previousStatus,
        newStatus,
        notes: validatedInput.notes,
        metadata: JSON.stringify(req.body),
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });
      
      res.json(updatedIncident);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({ message: err.errors[0].message });
      }
      console.error("Incident workflow error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 분쟁 액션 이력 조회
  app.get("/api/incidents/:id/actions", async (req, res) => {
    try {
      const actions = await storage.getIncidentActions(Number(req.params.id));
      res.json(actions);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 계약 실행 이벤트 조회
  app.get("/api/contracts/:id/execution-events", async (req, res) => {
    try {
      const events = await storage.getContractExecutionEventsByContract(
        Number(req.params.id), 
        "service_contract"
      );
      res.json(events);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/job-contracts/:id/execution-events", async (req, res) => {
    try {
      const events = await storage.getContractExecutionEventsByContract(
        Number(req.params.id), 
        "job_contract"
      );
      res.json(events);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 계약 문서 API
  app.post("/api/contracts/:id/documents", requireAuth, async (req: AuthenticatedRequest, res) => {
    try {
      const document = await storage.createContractDocument({
        contractId: Number(req.params.id),
        documentType: req.body.documentType,
        storagePath: req.body.storagePath,
        fileSize: req.body.fileSize,
        checksum: req.body.checksum,
        mimeType: req.body.mimeType || "application/pdf",
      });
      
      res.json(document);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/contracts/:id/documents", async (req, res) => {
    try {
      const documents = await storage.getContractDocuments(Number(req.params.id));
      res.json(documents);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==================== 추가 관리자 API (헬퍼, 요청자, 직원, 제재, 알림 템플릿) ====================

  // 기사(헬퍼) 목록 조회 (상태 필터 지원)
  app.get("/api/admin/helpers", adminAuth, requirePermission("helpers.view"), async (req, res) => {
    try {
      const statusFilter = req.query.status as string | undefined;
      const users = await storage.getAllUsers();
      let helpers = users.filter(u => u.role === "helper" && !u.isHqStaff);
      
      // 상태 필터링: available = waiting 상태 + 활성 기사 + 승인된 헬퍼만
      if (statusFilter === "available") {
        helpers = helpers.filter(h => 
          (h.dailyStatus === "waiting" || !h.dailyStatus) && 
          h.onboardingStatus === "approved"
        );
      } else if (statusFilter === "working") {
        helpers = helpers.filter(h => h.dailyStatus === "working");
      } else if (statusFilter === "off") {
        helpers = helpers.filter(h => h.dailyStatus === "off");
      }
      
      const result = helpers.map(h => ({
        id: h.id,
        username: h.username,
        email: h.email,
        name: h.name,
        phoneNumber: h.phoneNumber,
        address: h.address,
        birthDate: h.birthDate,
        dailyStatus: h.dailyStatus || "waiting",
        isTeamLeader: h.isTeamLeader || false,
        teamName: h.teamName,
        locationConsent: h.locationConsent || false,
        onboardingStatus: h.onboardingStatus,
        createdAt: h.createdAt,
      }));
      res.json(result);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 가용 헬퍼 목록 조회 (매칭용)
  app.get("/api/admin/helpers/available", adminAuth, requirePermission("helpers.view"), async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      const helpers = users.filter(u => 
        u.role === "helper" && 
        !u.isHqStaff && 
        (u.dailyStatus === "waiting" || !u.dailyStatus) && 
        u.onboardingStatus === "approved"
      );
      
      const result = helpers.map(h => ({
        id: h.id,
        username: h.username,
        email: h.email,
        name: h.name,
        phoneNumber: h.phoneNumber,
        address: h.address,
        birthDate: h.birthDate,
        dailyStatus: h.dailyStatus || "waiting",
        isTeamLeader: h.isTeamLeader || false,
        teamName: h.teamName,
        locationConsent: h.locationConsent || false,
        latitude: h.latitude,
        longitude: h.longitude,
        createdAt: h.createdAt,
      }));
      res.json(result);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 헬퍼 자격증명 상세 조회
  app.get("/api/admin/helper-credentials/:userId", adminAuth, requirePermission("helpers.view"), async (req, res) => {
    try {
      const credential = await storage.getHelperCredential(req.params.userId);
      if (!credential) {
        return res.json([]);
      }
      res.json(credential);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 요청자 목록 조회
  app.get("/api/admin/requesters", adminAuth, requirePermission("requesters.view"), async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      const requesters = users.filter(u => u.role === "requester");
      const result = requesters.map(r => ({
        id: r.id,
        username: r.username,
        email: r.email,
        name: r.name,
        phoneNumber: r.phoneNumber,
        address: r.address,
        createdAt: r.createdAt,
      }));
      res.json(result);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 요청자 오더 목록 조회
  app.get("/api/admin/requesters/:userId/orders", adminAuth, requirePermission("requesters.view"), async (req, res) => {
    try {
      const allOrders = await storage.getAllOrders();
      const orders = allOrders.filter(o => o.requesterId === req.params.userId);
      res.json(orders);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 요청자 상세 정보 조회
  app.get("/api/admin/requesters/:requesterId/detail", adminAuth, requirePermission("requesters.view"), async (req, res) => {
    try {
      const { requesterId } = req.params;
      const user = await storage.getUser(requesterId);
      if (!user || user.role !== "requester") {
        return res.status(404).json({ message: "요청자를 찾을 수 없습니다" });
      }

      const [business, serviceAgreement, refundAccountResult] = await Promise.all([
        storage.getRequesterBusiness(requesterId),
        storage.getRequesterServiceAgreement(requesterId),
        db.select().from(requesterRefundAccounts).where(eq(requesterRefundAccounts.userId, requesterId)).limit(1),
      ]);
      const refundAccount = refundAccountResult[0] || null;

      // 요청자 고유번호 생성 (12자리)
      const generateRequesterCode = (id: string) => {
        const hash = id.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
        return String(hash).padStart(12, '0').slice(-12);
      };

      res.json({
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          phoneNumber: user.phoneNumber,
          address: user.address,
          onboardingStatus: user.onboardingStatus,
          onboardingReviewedAt: user.onboardingReviewedAt,
          onboardingRejectReason: user.onboardingRejectReason,
          requesterCode: generateRequesterCode(user.id),
          createdAt: user.createdAt,
        },
        business: business ? {
          businessNumber: business.businessNumber,
          businessName: business.businessName,
          representativeName: business.representativeName,
          address: business.address,
          businessType: business.businessType,
          businessCategory: business.businessCategory,
          businessImageUrl: business.businessImageUrl,
          verificationStatus: business.verificationStatus,
        } : null,
        serviceAgreement: serviceAgreement ? {
          contractAgreed: serviceAgreement.contractAgreed,
          depositAmount: serviceAgreement.depositAmount,
          balanceAmount: serviceAgreement.balanceAmount,
          balanceDueDate: serviceAgreement.balanceDueDate,
          signatureData: serviceAgreement.signatureData,
          phoneNumber: serviceAgreement.phoneNumber,
          phoneVerified: serviceAgreement.phoneVerified,
          agreedAt: serviceAgreement.agreedAt,
        } : null,
        refundAccount: refundAccount ? {
          bankName: refundAccount.bankName,
          accountNumber: refundAccount.accountNumber,
          accountHolder: refundAccount.accountHolder,
          createdAt: refundAccount.createdAt,
          updatedAt: refundAccount.updatedAt,
        } : null,
      });
    } catch (err) {
      console.error("Requester detail error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 직원(HQ Staff) 목록 조회
  app.get("/api/admin/staff", adminAuth, requirePermission("staff.view"), async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      const staff = users.filter(u => u.isHqStaff || u.role === "admin");
      const result = staff.map(s => ({
        id: s.id,
        name: s.name,
        email: s.email,
        phoneNumber: s.phoneNumber,
        role: s.role === "admin" ? "관리자" : "본사직원",
        isHqStaff: s.isHqStaff || false,
        adminStatus: s.adminStatus || "active", // pending, active, suspended
        approvedAt: s.approvedAt,
        passwordChangedAt: s.passwordChangedAt,
        createdAt: s.createdAt,
      }));
      res.json(result);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 역할 목록 조회
  app.get("/api/admin/roles", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const roles = await storage.getAllAdminRoles();
      res.json(roles);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 역할별 권한 조회
  app.get("/api/admin/roles/:id/permissions", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const roleId = Number(req.params.id);
      const permissions = await storage.getRolePermissions(roleId);
      res.json(permissions);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 권한 목록 조회
  app.get("/api/admin/permissions", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const permissions = await storage.getAllAdminPermissions();
      res.json(permissions);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 현재 사용자 권한 목록 조회
  app.get("/api/admin/my-permissions", adminAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const permissions = await storage.getUserPermissions(userId);
      res.json(permissions);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 직원 역할 배정
  app.post("/api/admin/staff/:userId/roles", adminAuth, requirePermission("staff.roles"), async (req, res) => {
    try {
      const { roleId } = req.body;
      const userId = req.params.userId;
      const assignedBy = (req as any).user?.id;
      
      if (!roleId) {
        return res.status(400).json({ message: "역할 ID가 필요합니다" });
      }
      
      const assignment = await storage.assignRoleToStaff(userId, roleId, assignedBy);
      res.status(201).json({ success: true, assignment });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 직원 역할 해제
  app.delete("/api/admin/staff/:userId/roles/:roleId", adminAuth, requirePermission("staff.roles"), async (req, res) => {
    try {
      const userId = req.params.userId;
      const roleId = Number(req.params.roleId);
      
      await storage.removeRoleFromStaff(userId, roleId);
      res.json({ success: true });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 직원 역할 조회
  app.get("/api/admin/staff/:userId/roles", adminAuth, requirePermission("staff.view"), async (req, res) => {
    try {
      const assignments = await storage.getStaffRoleAssignments(req.params.userId);
      const roles = await storage.getAllAdminRoles();
      const roleMap = new Map(roles.map(r => [r.id, r]));
      
      const result = assignments.map(a => ({
        ...a,
        role: roleMap.get(a.roleId),
      }));
      res.json(result);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 제재 목록 조회
  app.get("/api/admin/sanctions", adminAuth, requirePermission("sanctions.view"), async (req, res) => {
    try {
      const sanctions = await storage.getAllUserSanctions();
      const users = await storage.getAllUsers();
      const userMap = new Map(users.map(u => [u.id, u]));
      
      const result = sanctions.map(s => ({
        ...s,
        userName: userMap.get(s.userId)?.name || "Unknown",
        userEmail: userMap.get(s.userId)?.email || "",
      }));
      res.json(result);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 제재 등록
  app.post("/api/admin/sanctions", adminAuth, requirePermission("sanctions.create"), async (req, res) => {
    try {
      const { userId, sanctionType, reason, evidence, durationDays } = req.body;
      if (!userId || !sanctionType || !reason) {
        return res.status(400).json({ message: "필수 정보가 누락되었습니다" });
      }
      
      const startDate = new Date().toISOString().split("T")[0];
      const endDate = durationDays 
        ? new Date(Date.now() + durationDays * 24 * 60 * 60 * 1000).toISOString().split("T")[0]
        : null;
      
      const sanction = await storage.createUserSanction({
        userId,
        sanctionType,
        reason,
        evidence: evidence || null,
        startDate,
        endDate,
        isActive: true,
        createdBy: (req as any).user?.id || null,
      });
      
      // 감사 로그 기록 (필수 - 법적 증빙)
      await logAdminAction({
        req,
        action: "sanction.create",
        targetType: "user",
        targetId: userId,
        oldValue: null,
        newValue: { sanctionType, reason, evidence, startDate, endDate },
      });
      
      // 사용자에게 알림 생성
      await storage.createNotification({
        userId,
        type: "announcement",
        title: "계정 제재 안내",
        message: `${sanctionType === "warning" ? "경고" : sanctionType === "suspension" ? "정지" : "블랙리스트"} 조치가 적용되었습니다: ${reason}`,
      });
      
      res.status(201).json({ success: true, sanction });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 제재 해제
  app.patch("/api/admin/sanctions/:id/lift", adminAuth, requirePermission("sanctions.delete"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const sanction = await storage.getUserSanction(id);
      if (!sanction) {
        return res.status(404).json({ message: "제재 정보를 찾을 수 없습니다" });
      }
      
      const updated = await storage.updateUserSanction(id, {
        isActive: false,
      });
      
      // 감사 로그 기록 (필수 - 법적 증빙)
      await logAdminAction({
        req,
        action: "sanction.lift",
        targetType: "user",
        targetId: sanction.userId,
        oldValue: { sanctionId: id, sanctionType: sanction.sanctionType, isActive: true },
        newValue: { sanctionId: id, isActive: false },
      });
      
      // 사용자에게 알림
      await storage.createNotification({
        userId: sanction.userId,
        type: "announcement",
        title: "제재 해제 안내",
        message: "계정 제재가 해제되었습니다.",
      });
      
      res.json({ success: true, sanction: updated });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ==============================================
  // 고객센터 문의 (Customer Service Inquiries)
  // ==============================================
  
  // 관리자: 모든 문의 조회
  app.get("/api/admin/cs-inquiries", adminAuth, async (req, res) => {
    try {
      const inquiries = await storage.getAllCustomerServiceInquiries();
      // 각 문의에 사용자 정보 추가
      const users = await storage.getAllUsers();
      const userMap = new Map(users.map(u => [u.id, u]));
      const result = inquiries.map(inq => ({
        ...inq,
        userName: userMap.get(inq.userId)?.name || "알 수 없음",
        userPhone: userMap.get(inq.userId)?.phoneNumber || "",
        userEmail: userMap.get(inq.userId)?.email || "",
      }));
      res.json(result);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 관리자: 문의 상세 조회
  app.get("/api/admin/cs-inquiries/:id", adminAuth, async (req, res) => {
    try {
      const id = Number(req.params.id);
      const inquiry = await storage.getCustomerServiceInquiry(id);
      if (!inquiry) {
        return res.status(404).json({ message: "문의를 찾을 수 없습니다" });
      }
      const user = await storage.getUser(inquiry.userId);
      res.json({ 
        ...inquiry, 
        userName: user?.name || "알 수 없음",
        userPhone: user?.phoneNumber || "",
        userEmail: user?.email || "",
      });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 관리자: 문의 답변/상태 업데이트
  app.patch("/api/admin/cs-inquiries/:id", adminAuth, async (req, res) => {
    try {
      const id = Number(req.params.id);
      const adminUser = (req as any).user;
      
      const parseResult = updateCustomerServiceInquirySchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({ message: "Invalid request data", errors: parseResult.error.flatten() });
      }
      
      const { status, response, adminNote, priority, assignedTo } = parseResult.data;
      
      const updates: any = {};
      if (status) updates.status = status;
      if (response !== undefined) {
        updates.response = response;
        updates.respondedAt = new Date();
        updates.respondedBy = adminUser?.id;
      }
      if (adminNote !== undefined) updates.adminNote = adminNote;
      if (priority) updates.priority = priority;
      if (assignedTo !== undefined) updates.assignedTo = assignedTo;
      
      const updated = await storage.updateCustomerServiceInquiry(id, updates);
      
      // 답변이 있으면 사용자에게 알림
      if (response) {
        const inquiry = await storage.getCustomerServiceInquiry(id);
        if (inquiry) {
          await storage.createNotification({
            userId: inquiry.userId,
            type: "announcement",
            title: "문의 답변 완료",
            message: `'${inquiry.title}' 문의에 답변이 등록되었습니다.`,
          });
        }
      }
      
      res.json({ success: true, inquiry: updated });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 사용자: 내 문의 목록 조회
  app.get("/api/cs-inquiries", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const inquiries = await storage.getCustomerServiceInquiriesByUser(userId);
      res.json(inquiries);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 사용자: 문의 상세 조회
  app.get("/api/cs-inquiries/:id", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const id = Number(req.params.id);
      const inquiry = await storage.getCustomerServiceInquiry(id);
      
      if (!inquiry) {
        return res.status(404).json({ message: "문의를 찾을 수 없습니다" });
      }
      if (inquiry.userId !== userId) {
        return res.status(403).json({ message: "권한이 없습니다" });
      }
      res.json(inquiry);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 사용자: 문의 등록
  app.post("/api/cs-inquiries", requireAuth, async (req, res) => {
    try {
      const user = (req as any).user;
      if (!user) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      
      const parseResult = insertCustomerServiceInquirySchema.safeParse({
        ...req.body,
        userId: user.id,
        userRole: user.role,
        status: "pending",
        priority: "normal",
      });
      
      if (!parseResult.success) {
        return res.status(400).json({ message: "필수 항목을 입력해주세요", errors: parseResult.error.flatten() });
      }
      
      const inquiry = await storage.createCustomerServiceInquiry(parseResult.data);
      
      res.status(201).json({ success: true, inquiry });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 알림 템플릿 목록 (systemSettings에서 템플릿 조회)
  app.get("/api/admin/notification-templates", adminAuth, requirePermission("notifications.view"), async (req, res) => {
    try {
      const settings = await storage.getAllSystemSettings();
      const templates = settings
        .filter(s => s.settingKey.startsWith("notification_template_"))
        .map((s, idx) => {
          const data = JSON.parse(s.settingValue);
          return { id: idx + 1, key: s.settingKey, ...data };
        });
      res.json(templates);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 알림 템플릿 생성/수정
  app.post("/api/admin/notification-templates", adminAuth, requirePermission("notifications.edit"), async (req, res) => {
    try {
      const { eventType, title, message, targetAudience } = req.body;
      const key = `notification_template_${eventType}`;
      const value = JSON.stringify({ eventType, title, message, targetAudience, isActive: true });
      await storage.upsertSystemSetting(key, value, `알림 템플릿: ${eventType}`);
      res.json({ success: true, key });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 알림 발송 (내부 알림 + WebSocket)
  app.post("/api/admin/notifications/send", adminAuth, requirePermission("notifications.send"), async (req, res) => {
    try {
      const { targetAudience, title, message, targetUserIds } = req.body;
      
      let userIds: string[] = [];
      
      if (targetUserIds && targetUserIds.length > 0) {
        userIds = targetUserIds;
      } else {
        const users = await storage.getAllUsers();
        if (targetAudience === "all") {
          userIds = users.map(u => u.id);
        } else if (targetAudience === "helper") {
          userIds = users.filter(u => u.role === "helper").map(u => u.id);
        } else if (targetAudience === "requester") {
          userIds = users.filter(u => u.role === "requester").map(u => u.id);
        }
      }
      
      // 각 사용자에게 알림 생성
      let sentCount = 0;
      for (const userId of userIds) {
        await storage.createNotification({
          userId,
          type: "announcement",
          title,
          message,
        });
        sentCount++;
      }
      
      res.json({ success: true, sentCount });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 오더 입금 확인 및 등록 승인 (awaiting_deposit → open)
  app.post("/api/admin/orders/:orderId/approve-deposit", adminAuth, requirePermission("orders.manage"), async (req, res) => {
    try {
      const orderId = Number(req.params.orderId);
      
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }
      
      // awaiting_deposit 상태에서만 입금 승인 가능
      if (order.status !== ORDER_STATUS.AWAITING_DEPOSIT) {
        return res.status(400).json({ message: `현재 상태(${order.status})에서는 입금 승인할 수 없습니다` });
      }
      
      // 오더 상태를 open으로 변경 (paymentStatus도 함께 업데이트)
      await storage.updateOrder(orderId, {
        status: ORDER_STATUS.OPEN,
        approvalStatus: "approved",
        paymentStatus: "deposit_confirmed",
        matchedAt: new Date(), // 입금 확인 시간 기록
      });

      // 계약(contracts) 테이블도 업데이트
      const contracts = await storage.getOrderContracts(orderId);
      if (contracts.length > 0) {
        await storage.updateContract(contracts[0].id, {
          depositPaid: true,
          depositPaidAt: new Date(),
          downPaymentStatus: "paid",
        });
      }
      
      // 의뢰인에게 알림
      if (order.requesterId) {
        await storage.createNotification({
          userId: order.requesterId,
          type: "order_approved",
          title: "오더 등록 완료",
          message: `${order.companyName} 오더 입금이 확인되어 등록되었습니다. 이제 헬퍼가 신청할 수 있습니다.`,
          relatedId: orderId,
        });
        
        notificationWS.sendOrderStatusUpdate(order.requesterId, {
          orderId,
          status: ORDER_STATUS.OPEN,
          approvalStatus: "approved",
        });
        
        sendPushToUser(order.requesterId, {
          title: "오더 등록 완료",
          body: `${order.companyName} 오더 입금 확인. 헬퍼 모집이 시작됩니다.`,
          url: "/requester-home",
          tag: `order-approved-${orderId}`,
        });
      }
      
      // 모든 헬퍼에게 새 오더 알림 (optional - broadcast)
      broadcastToAllAdmins("order", "open", orderId, {
        orderId,
        companyName: order.companyName,
        status: ORDER_STATUS.OPEN,
      });
      
      res.json({ success: true, message: "오더가 등록되었습니다" });
    } catch (err) {
      console.error("Order approval error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 오더에 기사 배정
  app.post("/api/admin/orders/:orderId/assign", adminAuth, requirePermission("orders.assign"), async (req, res) => {
    try {
      const orderId = Number(req.params.orderId);
      const { helperId } = req.body;
      
      if (!helperId) {
        return res.status(400).json({ message: "기사 ID가 필요합니다" });
      }
      
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }
      
      // 배정은 open 상태에서만 가능 (매칭 전 단계 - 표준)
      const assignOrderStatus = normalizeOrderStatus(order.status);
      if (!isOneOfStatus(assignOrderStatus, CAN_SELECT_HELPER_STATUSES)) {
        return res.status(400).json({ 
          message: "배정은 'OPEN' 상태에서만 가능합니다. 현재 상태: " + order.status 
        });
      }
      
      const helper = await storage.getUser(helperId);
      if (!helper || helper.role !== "helper") {
        return res.status(404).json({ message: "기사를 찾을 수 없습니다" });
      }
      
      // 기사가 이미 다른 오더에 배정되어 있는지 확인
      const helperApps = await storage.getHelperApplications(helperId);
      const activeApps = helperApps.filter(a => a.status === "matched" || a.status === "accepted");
      
      // 오더 지원 생성 또는 업데이트 (approved 상태로 = 관리자 배정)
      const existingApp = await storage.getOrderApplication(orderId, helperId);
      if (existingApp) {
        await storage.updateOrderApplication(existingApp.id, { status: "approved" });
      } else {
        await storage.createOrderApplication({
          orderId,
          status: "approved",
        });
      }
      
      // 오더 상태 업데이트
      const updatedOrder = await storage.updateOrder(orderId, {
        status: "scheduled",
      });
      
      // 기사 상태를 working으로 업데이트
      await storage.updateUser(helperId, { dailyStatus: "working" });
      
      // 의뢰인 정보 조회 (오더에서 requesterId)
      const requesterId = order.requesterId;
      const requester = requesterId ? await storage.getUser(requesterId) : null;
      const requesterPhone = requester?.phoneNumber || "연락처 미등록";
      const helperPhone = helper?.phoneNumber || "연락처 미등록";
      
      // 헬퍼에게 알림 (의뢰인 연락처 포함)
      await storage.createNotification({
        type: "matching_success",
        title: "오더 배정 완료",
        message: `${order.companyName || "배송"} 오더에 배정되었습니다.\n의뢰인: ${requester?.name || "의뢰인"}\n연락처: ${requesterPhone}`,
      });
      console.log(`[Push Notification] Admin assigned order ${orderId} to Helper ${helperId}`);
      
      // 의뢰인에게 알림 (헬퍼 연락처 포함)
      if (requesterId) {
        await storage.createNotification({
          userId: requesterId,
          type: "matching_success",
          title: "헬퍼 배정 완료",
          message: `${helper.name || "헬퍼"}님이 ${order.companyName || "배송"} 오더에 배정되었습니다.\n헬퍼 연락처: ${helperPhone}`,
        });
        
        // Real-time update to requester
        notificationWS.sendOrderStatusUpdate(requesterId, {
          orderId,
          status: "matched",
          currentHelpers: (order.currentHelpers || 0) + 1,
        });
      }
      
      // Real-time update to helper
      notificationWS.sendOrderStatusUpdate(helperId, {
        orderId,
        status: "matched",
        currentHelpers: (order.currentHelpers || 0) + 1,
      });
      
      // Broadcast to all admins for real-time updates
      broadcastToAllAdmins("order", "assigned", orderId, { 
        orderId, 
        helperId, 
        status: "matched" 
      });
      
      res.json({ success: true, order: updatedOrder, helperId });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 기사 상세 통합 API (Helper Detail)
  // ============================================
  // Get helper contracts (admin) - 헬퍼별 계약 정보 조회
  app.get("/api/admin/helpers/:helperId/contracts", adminAuth, requirePermission("contracts.view"), async (req, res) => {
    try {
      const { helperId } = req.params;
      const helperContracts = await storage.getHelperContracts(helperId);
      const orders = await storage.getOrders();
      const orderMap = new Map(orders.map(o => [o.id, o]));
      
      const contractsWithDetails = helperContracts.map(c => {
        const order = orderMap.get(c.orderId);
        return {
          ...c,
          orderInfo: order ? {
            id: order.id,
            companyName: order.companyName,
            deliveryArea: order.deliveryArea,
            courierCompany: order.courierCompany || order.companyName,
            status: order.status,
          } : null,
        };
      });
      
      res.json(contractsWithDetails);
    } catch (err) {
      console.error("Error fetching helper contracts:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/helpers/:helperId/detail", adminAuth, requirePermission("helpers.view"), async (req, res) => {
    try {
      const { helperId } = req.params;
      const user = await storage.getUser(helperId);
      if (!user || user.role !== "helper") {
        return res.status(404).json({ message: "기사를 찾을 수 없습니다" });
      }

      const [credential, vehicles, business, bankAccount, license, termsAgreement, helperContracts, helperJobContracts] = await Promise.all([
        storage.getHelperCredential(helperId),
        storage.getHelperVehicle(helperId),
        storage.getHelperBusiness(helperId),
        storage.getHelperBankAccount(helperId),
        storage.getHelperLicense(helperId),
        storage.getHelperTermsAgreement(helperId),
        storage.getHelperContracts(helperId),
        storage.getHelperJobContracts(helperId),
      ]);

      // 계약 정보 가공
      const contractsWithOrders = await Promise.all(
        (helperContracts || []).slice(0, 20).map(async (contract) => {
          const order = contract.orderId ? await storage.getOrder(contract.orderId) : null;
          const requester = order?.requesterId ? await storage.getUser(order.requesterId) : null;
          return {
            id: contract.id,
            orderId: contract.orderId,
            status: contract.status,
            depositAmount: contract.depositAmount,
            depositPaidAt: contract.depositPaidAt,
            balanceAmount: contract.balanceAmount,
            balancePaidAt: contract.balancePaidAt,
            totalAmount: contract.totalAmount,
            createdAt: contract.createdAt,
            order: order ? {
              pickupAddress: order.pickupAddress,
              deliveryAddress: order.deliveryAddress,
              scheduledDate: order.scheduledDate,
              averageQuantity: order.averageQuantity,
            } : null,
            requesterName: requester?.name || '-',
          };
        })
      );

      // 본사 계약 (Job Contracts) 정보 가공
      const jobContractsWithDetails = await Promise.all(
        (helperJobContracts || []).slice(0, 20).map(async (jc) => {
          const order = jc.orderId ? await storage.getOrder(jc.orderId) : null;
          const requester = jc.requesterId ? await storage.getUser(jc.requesterId) : null;
          return {
            id: jc.id,
            orderId: jc.orderId,
            status: jc.status,
            executionStatus: jc.executionStatus,
            workDate: jc.workDate,
            workStartTime: jc.workStartTime,
            workEndTime: jc.workEndTime,
            workContent: jc.workContent,
            paymentAmount: jc.paymentAmount,
            helperSignedAt: jc.helperSignedAt,
            requesterSignedAt: jc.requesterSignedAt,
            createdAt: jc.createdAt,
            order: order ? {
              pickupAddress: order.pickupAddress,
              deliveryAddress: order.deliveryAddress,
              scheduledDate: order.scheduledDate,
              averageQuantity: order.averageQuantity,
            } : null,
            requesterName: requester?.name || '-',
          };
        })
      );

            // 팀 정보 조회
      let teamInfo = null;
      const teams = await storage.getAllTeams();
      for (const team of teams) {
        const members = await storage.getTeamMembers(team.id);
        const isMember = members.some(m => m.helperId === helperId && m.isActive);
        if (isMember) {
          const leader = await storage.getUser(team.leaderId);
          teamInfo = {
            teamId: team.id,
            teamName: team.name,
            leaderName: leader?.name || "",
          };
          break;
        }
      }

      res.json({
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          phoneNumber: user.phoneNumber,
          dailyStatus: user.dailyStatus,
          isTeamLeader: user.isTeamLeader,
          helperVerified: user.helperVerified,
          helperVerifiedAt: user.helperVerifiedAt,
          onboardingStatus: user.onboardingStatus,
          onboardingReviewedAt: user.onboardingReviewedAt,
          onboardingRejectReason: user.onboardingRejectReason,
          qrCode: user.qrCodeToken || `HELPER-${user.id}`,
          createdAt: user.createdAt,
        },
        credential,
        vehicles: vehicles || [],
        business,
        bankAccount,
        license,
        termsAgreement: termsAgreement ? {
          agreedAt: termsAgreement.agreedAt,
          signatureImageUrl: termsAgreement.signatureData,
          requiredTermsAgreed: Boolean(termsAgreement.serviceAgreed && termsAgreement.liabilityAgreed && termsAgreement.settlementAgreed),
          optionalTermsAgreed: Boolean(termsAgreement.locationAgreed),
          marketingAgreed: Boolean(termsAgreement.privacyAgreed),
          serviceAgreed: termsAgreement.serviceAgreed,
          vehicleAgreed: termsAgreement.vehicleAgreed,
          liabilityAgreed: termsAgreement.liabilityAgreed,
          settlementAgreed: termsAgreement.settlementAgreed,
          locationAgreed: termsAgreement.locationAgreed,
          privacyAgreed: termsAgreement.privacyAgreed,
        } : null,
        teamInfo,
        contracts: contractsWithOrders,
        jobContracts: jobContractsWithDetails,
      });
    } catch (err) {
      console.error("Helper detail error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 본사 계약 오더 API (Enterprise Orders)
  // ============================================
  app.get("/api/admin/enterprise-orders", adminAuth, requirePermission("enterprise.view"), async (req, res) => {
    try {
      const batches = await storage.getAllEnterpriseOrderBatches();
      const result = await Promise.all(batches.map(async (batch) => {
        const company = await storage.getEnterpriseAccount(batch.enterpriseId);
        return {
          id: batch.id,
          companyId: batch.enterpriseId,
          companyName: company?.name || "알수없음",
          projectCode: batch.projectCode,
          orderCount: batch.orderCount || 0,
          slaType: batch.slaType === "same_day" ? "당일배송" : batch.slaType === "next_day" ? "익일배송" : "예약배송",
          settlementModel: "건당정산",
          taxType: "exclusive",
          status: batch.status || "pending",
          createdAt: batch.createdAt,
          totalAmount: batch.totalAmount || 0,
        };
      }));
      res.json(result);
    } catch (err) {
      console.error("enterprise-orders error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/enterprise-companies", adminAuth, requirePermission("enterprise.view"), async (req, res) => {
    try {
      const accounts = await storage.getAllEnterpriseAccounts();
      const result = accounts.map(a => ({
        id: a.id,
        name: a.name,
        businessNumber: a.businessNumber || "",
        contactName: a.contactName || "",
        contactPhone: a.contactPhone || "",
        contractStart: a.contractStartDate,
        contractEnd: a.contractEndDate,
        status: a.isActive ? "active" : "inactive",
      }));
      res.json(result);
    } catch (err) {
      console.error("enterprise-companies error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/enterprise-companies", adminAuth, requirePermission("enterprise.create"), async (req, res) => {
    try {
      const { name, businessNumber, contactName, contactPhone, contractStart, contractEnd } = req.body;
      const account = await storage.createEnterpriseAccount({
        name,
        businessNumber: businessNumber || "",
        contactName,
        contactPhone,
        contractStartDate: contractStart,
        contractEndDate: contractEnd,
        isActive: true,
      });
      res.status(201).json(account);
    } catch (err) {
      console.error("create enterprise error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/enterprise-orders", adminAuth, requirePermission("enterprise.create"), async (req, res) => {
    try {
      const { companyId, projectCode, slaType, orderCount, totalAmount, notes, deliveryArea, vehicleType, pricePerUnit, scheduledDate } = req.body;
      
      // Get enterprise company info
      const company = await storage.getEnterpriseAccount(parseInt(companyId));
      if (!company) {
        return res.status(404).json({ message: "업체를 찾을 수 없습니다" });
      }
      
      // Create batch record
      const batch = await storage.createEnterpriseOrderBatch({
        enterpriseId: parseInt(companyId),
        projectCode,
        slaType: slaType || "next_day",
        orderCount: parseInt(orderCount) || 1,
        totalAmount: parseInt(totalAmount) || 0,
        notes,
        status: "pending",
      });
      
      // Create actual orders in orders table so helpers can see them
      const numOrders = parseInt(orderCount) || 1;
      const createdOrders = [];
      
      // Generate date string for scheduled date
      const today = new Date();
      const targetDate = scheduledDate || (() => {
        if (slaType === "same_day") {
          return `${today.getMonth() + 1}월 ${today.getDate()}일`;
        } else {
          const nextDay = new Date(today);
          nextDay.setDate(nextDay.getDate() + 1);
          return `${nextDay.getMonth() + 1}월 ${nextDay.getDate()}일`;
        }
      })();
      
      for (let i = 0; i < numOrders; i++) {
        const order = await storage.createOrder({
          requesterId: null, // Enterprise orders don't have individual requesters
          companyName: `${company.name} - ${projectCode}`,
          pricePerUnit: parseInt(pricePerUnit) || 1500,
          averageQuantity: "협의",
          deliveryArea: deliveryArea || "전국",
          scheduledDate: targetDate,
          vehicleType: vehicleType || "1톤하이탑",
          isUrgent: slaType === "same_day",
          status: ORDER_STATUS.OPEN,
          maxHelpers: 1,
          currentHelpers: 0,
        });
        createdOrders.push(order);
      }
      
      // Notify all approved helpers about new orders
      const allHelpers = await storage.getAllUsers();
      const approvedHelpers = allHelpers.filter(u => u.role === "helper" && u.onboardingStatus === "approved");
      for (const helper of approvedHelpers) {
        await storage.createNotification({
          userId: helper.id,
          type: "new_order",
          title: "새로운 기업 오더 등록",
          message: `${company.name} - ${numOrders}건의 새 오더가 등록되었습니다.`,
          relatedId: createdOrders[0]?.id,
        });
      }
      
      res.status(201).json({ batch, orders: createdOrders });
    } catch (err) {
      console.error("create enterprise order error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/enterprise/orders", adminAuth, requirePermission("enterprise.create"), async (req, res) => {
    try {
      const { companyId, projectCode, slaType, orderCount, totalAmount, notes, deliveryArea, vehicleType, pricePerUnit, scheduledDate } = req.body;
      
      // Redirect to main enterprise-orders endpoint
      const company = await storage.getEnterpriseAccount(parseInt(companyId));
      if (!company) {
        return res.status(404).json({ message: "업체를 찾을 수 없습니다" });
      }
      
      const batch = await storage.createEnterpriseOrderBatch({
        enterpriseId: parseInt(companyId),
        projectCode,
        slaType: slaType || "next_day",
        orderCount: parseInt(orderCount) || 1,
        totalAmount: parseInt(totalAmount) || 0,
        notes,
        status: "pending",
      });
      
      // Create actual orders in orders table
      const numOrders = parseInt(orderCount) || 1;
      const createdOrders = [];
      
      const today = new Date();
      const targetDate = scheduledDate || (() => {
        if (slaType === "same_day") {
          return `${today.getMonth() + 1}월 ${today.getDate()}일`;
        } else {
          const nextDay = new Date(today);
          nextDay.setDate(nextDay.getDate() + 1);
          return `${nextDay.getMonth() + 1}월 ${nextDay.getDate()}일`;
        }
      })();
      
      for (let i = 0; i < numOrders; i++) {
        const order = await storage.createOrder({
          requesterId: null,
          companyName: `${company.name} - ${projectCode}`,
          pricePerUnit: parseInt(pricePerUnit) || 1500,
          averageQuantity: notes || "협의",
          deliveryArea: deliveryArea || "전국",
          scheduledDate: targetDate,
          vehicleType: vehicleType || "1톤하이탑",
          isUrgent: slaType === "same_day",
          status: ORDER_STATUS.OPEN,
          maxHelpers: 1,
          currentHelpers: 0,
        });
        createdOrders.push(order);
      }
      
      res.status(201).json({ batch, orders: createdOrders });
    } catch (err) {
      console.error("create enterprise order error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/enterprise/orders/import", adminAuth, requirePermission("enterprise.upload"), async (req, res) => {
    try {
      const { enterpriseId, csvData } = req.body;
      
      if (!enterpriseId || !csvData || !Array.isArray(csvData)) {
        return res.status(400).json({ message: "enterpriseId와 csvData 배열이 필요합니다" });
      }
      
      // 최대 500행 제한
      const MAX_ROWS = 500;
      if (csvData.length > MAX_ROWS) {
        return res.status(400).json({ 
          message: `한 번에 최대 ${MAX_ROWS}행까지만 업로드할 수 있습니다. 현재: ${csvData.length}행` 
        });
      }
      
      const enterprise = await storage.getEnterpriseAccount(enterpriseId);
      if (!enterprise) {
        return res.status(404).json({ message: "업체를 찾을 수 없습니다" });
      }
      
      // 유효한 차량 타입 목록
      const VALID_VEHICLE_TYPES = [
        "다마스", "라보", "1톤", "1.2톤", "1.4톤", "1톤하이탑",
        "2.5톤", "3.5톤", "5톤", "5톤플러스", "11톤", "오토바이"
      ];
      
      // 날짜 형식 검증 (YYYY-MM-DD)
      const isValidDate = (dateStr: string): boolean => {
        if (!dateStr) return false;
        const dateRegex = /^\d{4}-\d{2}-\d{2}$/;
        if (!dateRegex.test(dateStr)) return false;
        const date = new Date(dateStr);
        return !isNaN(date.getTime());
      };
      
      const createdOrders: any[] = [];
      const errors: string[] = [];
      const processedKeys = new Set<string>();
      let duplicateCount = 0;
      
      for (let i = 0; i < csvData.length; i++) {
        const row = csvData[i];
        try {
          // 필수 필드 검증
          if (!row.companyName || !row.deliveryArea || !row.scheduledDate || !row.vehicleType) {
            errors.push(`행 ${i + 1}: 필수 필드(회사명, 배송지역, 일정, 차종) 누락`);
            continue;
          }
          
          // 날짜 형식 검증
          if (!isValidDate(row.scheduledDate)) {
            errors.push(`행 ${i + 1}: 날짜 형식 오류 (YYYY-MM-DD 형식 필요)`);
            continue;
          }
          
          // 차량 타입 검증
          if (!VALID_VEHICLE_TYPES.includes(row.vehicleType)) {
            errors.push(`행 ${i + 1}: 유효하지 않은 차종 (${row.vehicleType})`);
            continue;
          }
          
          // 가격 검증
          const price = parseInt(row.pricePerUnit);
          if (row.pricePerUnit && (isNaN(price) || price < 0)) {
            errors.push(`행 ${i + 1}: 유효하지 않은 단가`);
            continue;
          }
          
          // 중복 검사 (같은 회사+날짜+지역+차종)
          const rowKey = `${row.companyName}|${row.scheduledDate}|${row.deliveryArea}|${row.vehicleType}`;
          if (processedKeys.has(rowKey)) {
            errors.push(`행 ${i + 1}: 중복 데이터 (동일 조건 이미 존재)`);
            duplicateCount++;
            continue;
          }
          processedKeys.add(rowKey);
          
          const order = await storage.createOrder({
            companyName: row.companyName || enterprise.name,
            pricePerUnit: price || 0,
            averageQuantity: row.averageQuantity || "0box",
            deliveryArea: row.deliveryArea,
            scheduledDate: row.scheduledDate,
            vehicleType: row.vehicleType,
            isUrgent: row.isUrgent === true || row.isUrgent === "true",
            status: ORDER_STATUS.OPEN,
            maxHelpers: parseInt(row.maxHelpers) || 3,
            currentHelpers: 0,
          });
          createdOrders.push(order);
        } catch (rowErr) {
          console.error(`Row ${i + 1} error:`, rowErr);
          errors.push(`행 ${i + 1}: 처리 실패`);
        }
      }
      
      res.json({ 
        success: true, 
        importedCount: createdOrders.length,
        totalRows: csvData.length,
        errorCount: errors.length,
        errors: errors.slice(0, 20), // 최대 20개 에러까지 표시
        skippedDuplicates: duplicateCount,
      });
    } catch (err) {
      console.error("CSV import error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 대행배차 API (Dispatch Requests)
  // ============================================
  app.get("/api/admin/dispatch-requests", adminAuth, requirePermission("dispatch.view"), async (req, res) => {
    try {
      const requests = await storage.getAllDispatchRequests();
      const users = await storage.getAllUsers();
      const userMap = new Map(users.map(u => [u.id, u]));
      
      const result = requests.map(r => ({
        ...r,
        requesterName: userMap.get(r.requesterId)?.name || "Unknown",
        assignedHelperName: r.assignedHelperId ? userMap.get(r.assignedHelperId)?.name : null,
      }));
      res.json(result);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/dispatch-requests", adminAuth, requirePermission("dispatch.edit"), async (req, res) => {
    try {
      const { requesterId, pickupAddress, deliveryAddress, urgency, notes, orderId } = req.body;
      const request = await storage.createDispatchRequest({
        requesterId,
        pickupAddress,
        deliveryAddress,
        urgency: urgency || "normal",
        notes,
        orderId,
        status: "pending",
      });
      res.status(201).json(request);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/dispatch-requests/:id/assign", adminAuth, requirePermission("dispatch.assign"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { helperId } = req.body;
      
      if (!helperId) {
        return res.status(400).json({ message: "기사 ID가 필요합니다" });
      }
      
      const request = await storage.getDispatchRequest(id);
      if (!request) {
        return res.status(404).json({ message: "배차 요청을 찾을 수 없습니다" });
      }
      
      const helper = await storage.getUser(helperId);
      if (!helper || helper.role !== "helper") {
        return res.status(404).json({ message: "기사를 찾을 수 없습니다" });
      }
      
      const updated = await storage.updateDispatchRequest(id, {
        assignedAt: new Date(),
        status: "assigned",
      });
      
      // 요청자 정보 조회
      const requester = request.requesterId ? await storage.getUser(request.requesterId) : null;
      const requesterPhone = requester?.phoneNumber || "연락처 미등록";
      const helperPhone = helper?.phoneNumber || "연락처 미등록";
      
      // 기사에게 알림 (요청자 연락처 포함)
      await storage.createNotification({
        type: "matching_success",
        title: "대행배차 배정",
        message: `새로운 대행배차가 배정되었습니다.\n픽업: ${request.pickupAddress}\n의뢰인 연락처: ${requesterPhone}`,
      });
      
      // 요청자에게 알림 (헬퍼 연락처 포함)
      if (request.requesterId) {
        await storage.createNotification({
          userId: request.requesterId,
          type: "matching_success",
          title: "대행배차 헬퍼 배정 완료",
          message: `대행배차에 헬퍼가 배정되었습니다.\n헬퍼: ${helper.name || "헬퍼"}\n연락처: ${helperPhone}`,
        });
      }
      
      res.json({ success: true, request: updated });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Reject dispatch request (admin)
  app.post("/api/admin/dispatch-requests/:id/reject", adminAuth, requirePermission("dispatch.assign"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { reason } = req.body;
      
      const request = await storage.getDispatchRequest(id);
      if (!request) {
        return res.status(404).json({ message: "배차 요청을 찾을 수 없습니다" });
      }
      
      const updated = await storage.updateDispatchRequest(id, {
        status: "rejected",
        notes: reason || "관리자에 의해 거절됨",
      });
      
      // 요청자에게 알림
      if (request.requesterId) {
        await storage.createNotification({
          userId: request.requesterId,
          type: "matching_failed",
          title: "대행배차 거절",
          message: `대행배차 요청이 거절되었습니다. 사유: ${reason || "배차 불가"}`,
        });
      }
      
      res.json({ success: true, request: updated });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // Auto dispatch - assign to available helpers automatically (admin)
  app.post("/api/admin/dispatch-requests/auto-assign", adminAuth, requirePermission("dispatch.assign"), async (req, res) => {
    try {
      const pendingRequests = await storage.getAllDispatchRequests();
      const pending = pendingRequests.filter(r => r.status === "pending");
      
      if (pending.length === 0) {
        return res.json({ message: "대기 중인 배차 요청이 없습니다", assigned: 0 });
      }
      
      // 가용 헬퍼 조회
      const users = await storage.getAllUsers();
      const availableHelpers = users.filter(u => 
        u.role === "helper" && 
        u.dailyStatus === "available"
      );
      
      if (availableHelpers.length === 0) {
        return res.json({ message: "배정 가능한 기사가 없습니다", assigned: 0 });
      }
      
      let assignedCount = 0;
      const results = [];
      
      // 긴급 요청 우선 정렬
      const sortedRequests = pending.sort((a, b) => {
        const urgencyOrder = { emergency: 0, urgent: 1, normal: 2 };
        return (urgencyOrder[a.urgency as keyof typeof urgencyOrder] || 2) - 
               (urgencyOrder[b.urgency as keyof typeof urgencyOrder] || 2);
      });
      
      for (let i = 0; i < sortedRequests.length && i < availableHelpers.length; i++) {
        const request = sortedRequests[i];
        const helper = availableHelpers[i];
        
        await storage.updateDispatchRequest(request.id, {
          assignedHelperId: helper.id,
          assignedAt: new Date(),
          status: "assigned",
        });
        
        // 기사에게 알림
        await storage.createNotification({
          userId: helper.id,
          type: "matching_success",
          title: "대행배차 자동 배정",
          message: `새로운 대행배차가 자동 배정되었습니다.\n픽업: ${request.pickupAddress}`,
        });
        
        assignedCount++;
        results.push({ requestId: request.id, helperId: helper.id, helperName: helper.name });
      }
      
      res.json({ 
        message: `${assignedCount}건 자동 배차 완료`, 
        assigned: assignedCount,
        results 
      });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 팀장 인센티브 API (Team Incentives)
  // ============================================
  app.get("/api/admin/team-incentives", adminAuth, requirePermission("incentives.view"), async (req, res) => {
    try {
      const incentives = await storage.getAllTeamIncentives();
      const teams = await storage.getAllTeams();
      const users = await storage.getAllUsers();
      const teamMap = new Map(teams.map(t => [t.id, t]));
      const userMap = new Map(users.map(u => [u.id, u]));
      
      const result = incentives.map(i => {
        const team = teamMap.get(i.teamId);
        const leader = team ? userMap.get(team.leaderId) : null;
        return {
          ...i,
          teamName: team?.name || "Unknown",
          leaderName: leader?.name || "Unknown",
        };
      });
      res.json(result);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/team-incentives/:id/details", adminAuth, requirePermission("incentives.view"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const incentive = await storage.getTeamIncentive(id);
      if (!incentive) {
        return res.status(404).json({ message: "인센티브를 찾을 수 없습니다" });
      }
      
      const team = await storage.getTeam(incentive.teamId);
      const members = team ? await storage.getTeamMembers(team.id) : [];
      const memberIds = members.map(m => m.helperId);
      const users = await storage.getAllUsers();
      const userMap = new Map(users.map(u => [u.id, u]));
      
      const [year, month] = incentive.period.split("-").map(Number);
      const settlements = await storage.getAllSettlementStatements();
      
      const details = settlements
        .filter(s => {
          if (!memberIds.includes(s.helperId)) return false;
          if (!s.workDate) return false;
          const workDate = new Date(s.workDate);
          return workDate.getFullYear() === year && (workDate.getMonth() + 1) === month;
        })
        .map(s => {
          const helper = userMap.get(s.helperId);
          return {
            id: s.id,
            helperName: helper?.name || "Unknown",
            helperNickname: (helper as any)?.nickname || null,
            workDate: s.workDate,
            deliveryCount: s.deliveryCount || 0,
            totalAmount: s.totalAmount || 0,
            commissionAmount: s.commissionAmount || 0,
          };
        });
      
      res.json({ incentive, details });
    } catch (err) {
      console.error("Get incentive details error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/incentives/calc", adminAuth, requirePermission("incentives.calc"), async (req, res) => {
    try {
      const { period } = req.body;
      if (!period) {
        return res.status(400).json({ message: "기간(YYYY-MM)을 선택해주세요" });
      }
      
      const teams = await storage.getAllTeams();
      const settlements = await storage.getAllSettlementStatements();
      const settings = await storage.getAllSystemSettings();
      const policies = await storage.getAllIncentivePolicies();
      const users = await storage.getAllUsers();
      const userMap = new Map(users.map(u => [u.id, u]));
      
      const rateSetting = settings.find(s => s.settingKey === "default_incentive_rate");
      const defaultRate = rateSetting ? parseFloat(rateSetting.settingValue) : 5;
      
      const [year, month] = period.split("-").map(Number);
      
      const createdIncentives = [];
      
      for (const team of teams) {
        const members = await storage.getTeamMembers(team.id);
        const memberIds = members.map(m => m.helperId);
        
        if (memberIds.length === 0) continue;
        
        const teamSettlements = settlements.filter(s => {
          if (!s.teamLeaderId || s.teamLeaderId !== team.leaderId) return false;
          if (!s.workDate) return false;
          if (s.status !== "confirmed" && s.status !== "paid") return false;
          
          const workDate = new Date(s.workDate);
          return workDate.getFullYear() === year && (workDate.getMonth() + 1) === month;
        });
        
        if (teamSettlements.length === 0) continue;
        
        const totalFees = teamSettlements.reduce((sum, s) => sum + (s.totalAmount || 0), 0);
        const incentiveAmount = teamSettlements.reduce((sum, s) => sum + (s.teamLeaderIncentive || 0), 0);
        
        const teamPolicy = policies.find(p => p.teamId === team.id && p.isActive);
        const incentiveRate = teamPolicy?.defaultRate || Math.round(defaultRate);
        
        const leader = userMap.get(team.leaderId);
        
        // 팀별 인센티브 생성을 트랜잭션으로 감싸 원자성 보장
        try {
          const incentive = await db.transaction(async (tx) => {
            const [newIncentive] = await tx.insert(teamIncentives).values({
              teamId: team.id,
              period,
              totalFees,
              incentiveRate,
              incentiveAmount,
              status: "pending",
            }).returning();
            
            for (const s of teamSettlements) {
              await tx.insert(incentiveDetails).values({
                incentiveId: newIncentive.id,
                contractAmount: s.totalAmount || 0,
                feeRate: s.commissionRate || 0,
                feeAmount: s.commissionAmount || 0,
                completedAt: s.helperConfirmedAt,
              });
            }
            
            return newIncentive;
          });
          
          createdIncentives.push({
            ...incentive,
            teamName: team.name,
            leaderName: leader?.name || "Unknown",
            memberCount: memberIds.length,
            settlementCount: teamSettlements.length,
          });
          
          console.log(`[Incentive Created] Team: ${team.name}, Leader: ${leader?.name}, Rate: ${incentiveRate}%, Amount: ${incentiveAmount}원`);
        } catch (teamErr) {
          console.error(`[Incentive Error] Failed to create incentive for team ${team.name}:`, teamErr);
        }
      }
      
      res.json({ 
        success: true, 
        message: `${createdIncentives.length}개 팀의 인센티브가 산출되었습니다`,
        incentives: createdIncentives
      });
    } catch (err) {
      console.error("Calculate incentives error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/incentive-policies", adminAuth, requirePermission("incentives.view"), async (req, res) => {
    try {
      const policies = await storage.getAllIncentivePolicies();
      const teams = await storage.getAllTeams();
      const teamMap = new Map(teams.map(t => [t.id, t]));
      
      const result = policies.map(p => ({
        ...p,
        teamName: p.teamId ? teamMap.get(p.teamId)?.name : "전체 기본값",
      }));
      
      res.json(result);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/incentive-policies", adminAuth, requirePermission("incentives.calc"), async (req, res) => {
    try {
      const { teamId, defaultRate, minThreshold, paymentCycle, autoApprove } = req.body;
      
      if (defaultRate < 0 || defaultRate > 100) {
        return res.status(400).json({ message: "인센티브율은 0~100% 사이여야 합니다" });
      }
      
      const policy = await storage.createIncentivePolicy({
        teamId: teamId || null,
        defaultRate: defaultRate || 5,
        minThreshold: minThreshold || 0,
        paymentCycle: paymentCycle || "monthly",
        autoApprove: autoApprove || false,
        isActive: true,
      });
      
      res.json({ success: true, policy });
    } catch (err) {
      console.error("Create incentive policy error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/admin/incentive-policies/:id", adminAuth, requirePermission("incentives.calc"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { defaultRate, minThreshold, paymentCycle, autoApprove, isActive } = req.body;
      
      if (defaultRate !== undefined && (defaultRate < 0 || defaultRate > 100)) {
        return res.status(400).json({ message: "인센티브율은 0~100% 사이여야 합니다" });
      }
      
      const updated = await storage.updateIncentivePolicy(id, {
        ...(defaultRate !== undefined && { defaultRate }),
        ...(minThreshold !== undefined && { minThreshold }),
        ...(paymentCycle !== undefined && { paymentCycle }),
        ...(autoApprove !== undefined && { autoApprove }),
        ...(isActive !== undefined && { isActive }),
      });
      
      res.json({ success: true, policy: updated });
    } catch (err) {
      console.error("Update incentive policy error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/incentives/:id/approve", adminAuth, requirePermission("incentives.approve"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const incentive = await storage.getTeamIncentive(id);
      if (!incentive) {
        return res.status(404).json({ message: "인센티브를 찾을 수 없습니다" });
      }
      
      const updated = await storage.updateTeamIncentive(id, {
        status: "approved",
        approvedAt: new Date(),
        approvedBy: (req as any).user?.id || "admin",
      });
      
      res.json({ success: true, incentive: updated });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/incentives/:id/pay", adminAuth, requirePermission("incentives.pay"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const incentive = await storage.getTeamIncentive(id);
      if (!incentive) {
        return res.status(404).json({ message: "인센티브를 찾을 수 없습니다" });
      }
      if (incentive.status !== "approved") {
        return res.status(400).json({ message: "승인된 인센티브만 지급할 수 있습니다" });
      }
      
      const updated = await storage.updateTeamIncentive(id, {
        status: "paid",
        paidAt: new Date(),
      });
      
      // 팀장에게 알림
      const team = await storage.getTeam(incentive.teamId);
      if (team) {
        await storage.createNotification({
          userId: team.leaderId,
          type: "announcement",
          title: "인센티브 지급 완료",
          message: `${incentive.period} 인센티브가 지급되었습니다.`,
        });
      }
      
      res.json({ success: true, incentive: updated });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 세금계산서 API (Tax Invoices)
  // ============================================
  // ============================================
  // 월별 정산 집계 API (Monthly Settlement Summary)
  // ============================================
  
  // 월별 정산 요약 조회 (헬퍼/요청자별)
  app.get("/api/admin/monthly-settlement-summary", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const { month, userType } = req.query;
      
      if (!month || typeof month !== 'string') {
        return res.status(400).json({ error: "month parameter required (YYYY-MM format)" });
      }
      
      // 월의 시작일과 끝일 계산
      const [year, monthNum] = month.split('-').map(Number);
      const startDate = new Date(year, monthNum - 1, 1);
      const endDate = new Date(year, monthNum, 0, 23, 59, 59);
      
      // 정산 레코드 조회 (해당 월에 생성된 것들)
      const allSettlements = await db.select().from(settlementRecords)
        .where(
          and(
            gte(settlementRecords.createdAt, startDate),
            lte(settlementRecords.createdAt, endDate),
            eq(settlementRecords.status, 'completed')
          )
        );
      
      // 사용자 정보 조회
      const userIds = [...new Set(allSettlements.map(s => s.helperId))];
      const allUsers = await storage.getAllUsers();
      const userMap = new Map(allUsers.map(u => [u.id, u]));
      
      // 헬퍼별 집계
      const helperSummary = new Map<string, { 
        userId: string; 
        userName: string; 
        email: string;
        totalSupply: number; 
        totalVat: number; 
        totalAmount: number;
        settlementCount: number;
        settlementIds: number[];
        hasMonthlyInvoice: boolean;
      }>();
      
      for (const settlement of allSettlements) {
        const helperId = settlement.helperId;
        const user = userMap.get(helperId);
        
        if (!helperSummary.has(helperId)) {
          helperSummary.set(helperId, {
            userName: user?.name || 'Unknown',
            email: user?.email || '',
            totalSupply: 0,
            totalVat: 0,
            totalAmount: 0,
            settlementCount: 0,
            settlementIds: [],
            hasMonthlyInvoice: false,
          });
        }
        
        const summary = helperSummary.get(helperId)!;
        summary.totalSupply += Number(settlement.finalSupply) || 0;
        summary.totalVat += Number(settlement.vat) || 0;
        summary.totalAmount += Number(settlement.finalTotal) || 0;
        summary.settlementCount += 1;
        summary.settlementIds.push(settlement.id);
      }
      
      // 이미 발행된 월별 세금계산서 확인
      const existingMonthlyInvoices = await db.select().from(taxInvoices)
        .where(
          and(
            eq(taxInvoices.invoiceScope, 'monthly'),
            eq(taxInvoices.targetMonth, month)
          )
        );
      
      for (const invoice of existingMonthlyInvoices) {
        if (invoice.targetUserId && helperSummary.has(invoice.targetUserId)) {
          helperSummary.get(invoice.targetUserId)!.hasMonthlyInvoice = true;
        }
      }
      
      const summaryArray = Array.from(helperSummary.values())
        .filter(s => s.settlementCount > 0)
        .sort((a, b) => b.totalAmount - a.totalAmount);
      
      res.json({
        month,
        helpers: summaryArray,
        totalHelpers: summaryArray.length,
        grandTotalSupply: summaryArray.reduce((sum, s) => sum + s.totalSupply, 0),
        grandTotalVat: summaryArray.reduce((sum, s) => sum + s.totalVat, 0),
        grandTotalAmount: summaryArray.reduce((sum, s) => sum + s.totalAmount, 0),
      });
    } catch (error) {
      console.error("Monthly settlement summary error:", error);
      res.status(500).json({ error: "Failed to fetch monthly settlement summary" });
    }
  });
  
  // 월별 합산 세금계산서 생성
  app.post("/api/admin/tax-invoices/monthly", adminAuth, requirePermission("tax.issue"), async (req, res) => {
    try {
      const { month, userId, userType = 'helper', issueType = 'forward' } = req.body;
      
      if (!month || !userId) {
        return res.status(400).json({ error: "month and userId required" });
      }
      
      // 월의 시작일과 끝일 계산
      const [year, monthNum] = month.split('-').map(Number);
      const startDate = new Date(year, monthNum - 1, 1);
      const endDate = new Date(year, monthNum, 0, 23, 59, 59);
      
      // 기존 월별 세금계산서 확인
      const existingInvoice = await db.select().from(taxInvoices)
        .where(
          and(
            eq(taxInvoices.invoiceScope, 'monthly'),
            eq(taxInvoices.targetMonth, month),
            eq(taxInvoices.targetUserId, userId)
          )
        )
        .limit(1);
      
      if (existingInvoice.length > 0) {
        return res.status(409).json({ 
          error: "Monthly invoice already exists",
          existingInvoice: existingInvoice[0]
        });
      }
      
      // 해당 월의 정산 레코드 조회
      const settlements = await db.select().from(settlementRecords)
        .where(
          and(
            eq(settlementRecords.helperId, userId),
            gte(settlementRecords.createdAt, startDate),
            lte(settlementRecords.createdAt, endDate),
            eq(settlementRecords.status, 'completed')
          )
        );
      
      if (settlements.length === 0) {
        return res.status(404).json({ error: "No completed settlements found for this month" });
      }
      
      // 금액 합산
      const totalSupply = settlements.reduce((sum, s) => sum + (Number(s.finalSupply) || 0), 0);
      const totalVat = settlements.reduce((sum, s) => sum + (Number(s.vat) || 0), 0);
      const totalAmount = settlements.reduce((sum, s) => sum + (Number(s.finalTotal) || 0), 0);
      const settlementIds = settlements.map(s => s.id);
      
      // 사용자 정보 조회
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      
      // 세금계산서 번호 생성
      const invoiceNumber = `MTI-${month.replace('-', '')}-${userId.slice(-6).toUpperCase()}`;
      const mgtKey = `M${month.replace('-', '')}${Date.now().toString().slice(-8)}`;
      
      // 월별 세금계산서 생성
      const newInvoice = await storage.createTaxInvoice({
        invoiceNumber,
        invoiceScope: 'monthly',
        targetMonth: month,
        targetUserId: userId,
        targetUserType: userType,
        settlementIds: JSON.stringify(settlementIds),
        issueType,
        supplyAmount: totalSupply,
        vatAmount: totalVat,
        totalAmount,
        writeDate: new Date().toISOString().slice(0, 10).replace(/-/g, ''),
        buyerCorpName: user.name || user.email,
        buyerEmail: user.email,
        popbillMgtKey: mgtKey,
        status: 'draft',
        createdBy: (req as AuthenticatedRequest).user.id,
        detailList: JSON.stringify([{
          sn: 1,
          itemName: `${month} 월간 정산`,
          qty: settlements.length,
          unitCost: Math.round(totalSupply / settlements.length),
          supplyCost: totalSupply,
          tax: totalVat,
        }]),
      });
      
      res.status(201).json({
        success: true,
        invoice: newInvoice,
        summary: {
          settlementCount: settlements.length,
          totalSupply,
          totalVat,
          totalAmount,
        }
      });
    } catch (error) {
      console.error("Create monthly tax invoice error:", error);
      res.status(500).json({ error: "Failed to create monthly tax invoice" });
    }
  });

  app.get("/api/admin/tax-invoices", adminAuth, requirePermission("tax.view"), async (req, res) => {
    try {
      const invoices = await storage.getAllTaxInvoices();
      const users = await storage.getAllUsers();
      const userMap = new Map(users.map(u => [u.id, u]));
      
      const result = invoices.map(inv => {
        return {
          ...inv,
          helperName: inv.recipientName || "Unknown",
        };
      });
      
      res.json(result);
    } catch (err) {
      console.error("Get tax invoices error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/tax-invoices/pending-queue", adminAuth, requirePermission("tax.view"), async (req, res) => {
    try {
      const settlements = await storage.getAllSettlementStatements();
      const users = await storage.getAllUsers();
      const userMap = new Map(users.map(u => [u.id, u]));
      
      const confirmedSettlements = settlements.filter(s => s.status === "confirmed" || s.status === "paid");
      
      const pendingQueue = confirmedSettlements.map(s => {
        const helper = userMap.get(s.helperId);
        const supplyAmount = s.supplyAmount || Math.round((s.totalAmount || 0) / 1.1);
        const vatAmount = s.vatAmount || Math.round(supplyAmount * 0.1);
        
        return {
          id: s.id,
          settlementId: s.id,
          helperName: helper?.name || "Unknown",
            helperNickname: (helper as any)?.nickname || null,
          businessNumber: helper?.address || "",
          supplyAmount,
          vatAmount,
          totalAmount: s.totalAmount || 0,
          commissionAmount: s.commissionAmount || 0,
          workDate: s.workDate,
          status: s.status === "paid" ? "issued" : "pending",
          confirmedAt: s.helperConfirmedAt,
        };
      });
      
      res.json(pendingQueue);
    } catch (err) {
      console.error("Get pending queue error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/vat-settings", adminAuth, requirePermission("tax.view"), async (req, res) => {
    try {
      const settings = await storage.getAllSystemSettings();
      const vatRateSetting = settings.find(s => s.settingKey === "vat_rate");
      const taxTypeSetting = settings.find(s => s.settingKey === "default_tax_type");
      const autoIssueSetting = settings.find(s => s.settingKey === "auto_issue_tax_invoice");
      const issueDelaySetting = settings.find(s => s.settingKey === "tax_invoice_issue_delay_days");
      
      res.json({
        defaultTaxType: taxTypeSetting?.settingValue || "exclusive",
        vatRate: vatRateSetting ? parseInt(vatRateSetting.settingValue) : 10,
        autoIssue: autoIssueSetting?.settingValue === "true",
        issueDelayDays: issueDelaySetting ? parseInt(issueDelaySetting.settingValue) : 3,
      });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/tax-invoices/generate-monthly", adminAuth, requirePermission("tax.issue"), async (req, res) => {
    try {
      const { period, helperId } = req.body;
      if (!period) {
        return res.status(400).json({ message: "기간(YYYY-MM)을 입력해주세요" });
      }
      
      const [year, month] = period.split("-").map(Number);
      const settlements = await storage.getAllSettlementStatements();
      const users = await storage.getAllUsers();
      const helperBusinesses = await storage.getAllHelperBusinesses();
      const userMap = new Map(users.map(u => [u.id, u]));
      const businessMap = new Map(helperBusinesses.map(b => [b.userId, b]));
      
      const helperSettlements: { [key: string]: typeof settlements } = {};
      
      for (const s of settlements) {
        if (s.status !== "confirmed" && s.status !== "paid") continue;
        if (!s.workDate) continue;
        
        const workDate = new Date(s.workDate);
        if (workDate.getFullYear() !== year || (workDate.getMonth() + 1) !== month) continue;
        if (helperId && s.helperId !== helperId) continue;
        
        if (!helperSettlements[s.helperId]) {
          helperSettlements[s.helperId] = [];
        }
        helperSettlements[s.helperId].push(s);
      }
      
      const createdInvoices = [];
      const settings = await storage.getAllSystemSettings();
      const commissionRateSetting = settings.find(s => s.settingKey === "platform_commission_rate");
      const commissionRate = commissionRateSetting ? parseFloat(commissionRateSetting.settingValue) : 5;
      
      for (const [hId, hSettlements] of Object.entries(helperSettlements)) {
        const helper = userMap.get(hId);
        const business = businessMap.get(hId);
        
        if (!helper) continue;
        
        let totalAmount = 0;
        let totalDeliveryCount = 0;
        let totalReturnCount = 0;
        
        for (const s of hSettlements) {
          totalAmount += s.totalAmount || 0;
          totalDeliveryCount += s.deliveryCount || 0;
          totalReturnCount += s.returnCount || 0;
        }
        
        const commissionAmount = Math.round(totalAmount * commissionRate / 100);
        const supplyAfterCommission = totalAmount - commissionAmount;
        const supplyAmount = Math.round(supplyAfterCommission / 1.1);
        const vatAmount = supplyAfterCommission - supplyAmount;
        
        const invoiceNumber = `INV-${period.replace("-", "")}-${hId.substring(0, 6).toUpperCase()}-${Date.now().toString().slice(-4)}`;
        
        const invoice = await storage.createTaxInvoice({
          invoiceNumber,
          issueType: "forward",
          supplyAmount,
          vatAmount,
          totalAmount: supplyAfterCommission,
          issuerName: "헬프미",
          issuerBusinessNumber: "000-00-00000",
          recipientName: business?.businessName || helper.name || "Unknown",
          recipientBusinessNumber: business?.businessNumber || "",
          issueDate: period,
          status: "pending",
        });
        
        createdInvoices.push({
          ...invoice,
          helperName: helper.name,
          deliveryCount: totalDeliveryCount,
          returnCount: totalReturnCount,
          commissionAmount,
          originalTotal: totalAmount,
        });
      }
      
      res.json({
        success: true,
        message: `${createdInvoices.length}건의 세금계산서가 생성되었습니다`,
        invoices: createdInvoices,
      });
    } catch (err) {
      console.error("Generate monthly tax invoices error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/tax-invoices/:id/issue", adminAuth, requirePermission("tax.issue"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const invoice = await storage.getTaxInvoice(id);
      
      if (!invoice) {
        return res.status(404).json({ message: "세금계산서를 찾을 수 없습니다" });
      }
      
      const updated = await storage.updateTaxInvoice(id, {
        status: "issued",
        issueDate: new Date().toISOString().split("T")[0],
      });
      
      res.json({ 
        success: true, 
        invoice: updated,
        message: "세금계산서가 발행되었습니다",
      });
    } catch (err) {
      console.error("Issue tax invoice error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/tax-invoices/:id/reverse", adminAuth, requirePermission("tax.reverse"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const invoice = await storage.getTaxInvoice(id);
      
      if (!invoice) {
        return res.status(404).json({ message: "세금계산서를 찾을 수 없습니다" });
      }
      
      const updated = await storage.updateTaxInvoice(id, {
        issueType: "reverse",
        status: "pending",
      });
      
      res.json({ 
        success: true, 
        invoice: updated,
        message: "역발행 요청이 처리되었습니다",
      });
    } catch (err) {
      console.error("Reverse tax invoice error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/tax-invoices/:id/cancel", adminAuth, requirePermission("tax.cancel"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const { reason } = req.body;
      
      const invoice = await storage.getTaxInvoice(id);
      if (!invoice) {
        return res.status(404).json({ message: "세금계산서를 찾을 수 없습니다" });
      }
      
      const updated = await storage.updateTaxInvoice(id, {
        status: "cancelled",
        cancelReason: reason,
        cancelledAt: new Date(),
        cancelledBy: (req as any).user?.id || "admin",
      });
      
      res.json({ 
        success: true, 
        invoice: updated,
        message: "세금계산서가 취소되었습니다",
      });
    } catch (err) {
      console.error("Cancel tax invoice error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/tax-invoices/:id", adminAuth, requirePermission("tax.view"), async (req, res) => {

  // ============================================
  // 팝빌 세금계산서 API 연동
  // ============================================
  
  // 팝빌 연동 상태 확인
  app.get("/api/admin/popbill/status", adminAuth, requirePermission("tax.view"), async (req, res) => {
    try {
      res.json({
        configured: popbill.isConfigured(),
        message: popbill.isConfigured() 
          ? "팝빌 API가 설정되었습니다" 
          : "팝빌 API 키가 설정되지 않았습니다. POPBILL_LINK_ID와 POPBILL_SECRET_KEY를 설정하세요.",
      });
    } catch (err) {
      console.error("Check popbill status error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 팝빌 정발행 (공급자 → 공급받는자)
  app.post("/api/admin/tax-invoices/:id/popbill-issue", adminAuth, requirePermission("tax.issue"), async (req, res) => {
    try {
      if (!popbill.isConfigured()) {
        return res.status(400).json({ message: "팝빌 API가 설정되지 않았습니다" });
      }

      const id = Number(req.params.id);
      const invoice = await storage.getTaxInvoice(id);
      
      if (!invoice) {
        return res.status(404).json({ message: "세금계산서를 찾을 수 없습니다" });
      }

      const mgtKey = popbill.generateMgtKey();
      const writeDate = new Date().toISOString().split("T")[0].replace(/-/g, "");
      
      const taxInvoiceData = popbill.buildTaxInvoice({
        type: "forward",
        writeDate,
        supplierCorpNum: invoice.supplierCorpNum || "",
        supplierCorpName: invoice.supplierCorpName || "",
        supplierCeoName: invoice.supplierCeoName || "",
        supplierAddr: invoice.supplierAddr || undefined,
        supplierBizType: invoice.supplierBizType || undefined,
        supplierBizClass: invoice.supplierBizClass || undefined,
        supplierEmail: invoice.supplierEmail || undefined,
        buyerCorpNum: invoice.buyerCorpNum || "",
        buyerCorpName: invoice.buyerCorpName || "",
        buyerCeoName: invoice.buyerCeoName || "",
        buyerAddr: invoice.buyerAddr || undefined,
        buyerBizType: invoice.buyerBizType || undefined,
        buyerBizClass: invoice.buyerBizClass || undefined,
        buyerEmail: invoice.buyerEmail || undefined,
        supplyAmount: invoice.supplyAmount || 0,
        vatAmount: invoice.vatAmount || 0,
        remark1: invoice.remark1 || undefined,
      });

      const result = await popbill.registIssue(
        invoice.supplierCorpNum || "",
        mgtKey,
        taxInvoiceData
      );

      const updated = await storage.updateTaxInvoice(id, {
        status: "issued",
        issueDate: writeDate,
        popbillMgtKey: mgtKey,
        popbillNtsconfirmNum: result.ntsConfirmNum,
        popbillStatus: "issued",
      });

      res.json({
        success: true,
        invoice: updated,
        popbillResult: result,
        message: "세금계산서가 팝빌을 통해 발행되었습니다",
      });
    } catch (err: any) {
      console.error("Popbill issue tax invoice error:", err);
      res.status(500).json({ message: err.message || "팝빌 발행 오류" });
    }
  });

  // 팝빌 역발행 요청 (공급받는자 → 공급자 승인 요청)
  app.post("/api/admin/tax-invoices/:id/popbill-reverse", adminAuth, requirePermission("tax.reverse"), async (req, res) => {
    try {
      if (!popbill.isConfigured()) {
        return res.status(400).json({ message: "팝빌 API가 설정되지 않았습니다" });
      }

      const id = Number(req.params.id);
      const { memo } = req.body;
      const invoice = await storage.getTaxInvoice(id);
      
      if (!invoice) {
        return res.status(404).json({ message: "세금계산서를 찾을 수 없습니다" });
      }

      const mgtKey = popbill.generateMgtKey();
      const writeDate = new Date().toISOString().split("T")[0].replace(/-/g, "");
      
      const taxInvoiceData = popbill.buildTaxInvoice({
        type: "reverse",
        writeDate,
        supplierCorpNum: invoice.supplierCorpNum || "",
        supplierCorpName: invoice.supplierCorpName || "",
        supplierCeoName: invoice.supplierCeoName || "",
        buyerCorpNum: invoice.buyerCorpNum || "",
        buyerCorpName: invoice.buyerCorpName || "",
        buyerCeoName: invoice.buyerCeoName || "",
        supplyAmount: invoice.supplyAmount || 0,
        vatAmount: invoice.vatAmount || 0,
      });

      const result = await popbill.registRequest(
        invoice.buyerCorpNum || "",
        mgtKey,
        taxInvoiceData,
        memo
      );

      const updated = await storage.updateTaxInvoice(id, {
        issueType: "reverse",
        status: "pending",
        popbillMgtKey: mgtKey,
        popbillStatus: "requested",
      });

      res.json({
        success: true,
        invoice: updated,
        popbillResult: result,
        message: "역발행 요청이 팝빌을 통해 전송되었습니다",
      });
    } catch (err: any) {
      console.error("Popbill reverse tax invoice error:", err);
      res.status(500).json({ message: err.message || "팝빌 역발행 오류" });
    }
  });

  // 팝빌 세금계산서 상태 조회
  app.get("/api/admin/tax-invoices/:id/popbill-status", adminAuth, requirePermission("tax.view"), async (req, res) => {
    try {
      if (!popbill.isConfigured()) {
        return res.status(400).json({ message: "팝빌 API가 설정되지 않았습니다" });
      }

      const id = Number(req.params.id);
      const invoice = await storage.getTaxInvoice(id);
      
      if (!invoice) {
        return res.status(404).json({ message: "세금계산서를 찾을 수 없습니다" });
      }

      if (!invoice.popbillMgtKey) {
        return res.status(400).json({ message: "팝빌 연동 정보가 없습니다" });
      }

      const mgtKeyType = invoice.issueType === "forward" ? "SELL" : "BUY";
      const result = await popbill.getInfo(
        invoice.supplierCorpNum || invoice.buyerCorpNum || "",
        mgtKeyType,
        invoice.popbillMgtKey
      );

      await storage.updateTaxInvoice(id, {
        popbillStatus: result.stateCode,
        ntsResult: result.ntsConfirmNum ? "accepted" : "pending",
      });

      res.json({
        success: true,
        status: result,
      });
    } catch (err: any) {
      console.error("Get popbill status error:", err);
      res.status(500).json({ message: err.message || "상태 조회 오류" });
    }
  });

  // 팝빌 PDF 조회
  app.get("/api/admin/tax-invoices/:id/popbill-pdf", adminAuth, requirePermission("tax.view"), async (req, res) => {
    try {
      if (!popbill.isConfigured()) {
        return res.status(400).json({ message: "팝빌 API가 설정되지 않았습니다" });
      }

      const id = Number(req.params.id);
      const invoice = await storage.getTaxInvoice(id);
      
      if (!invoice || !invoice.popbillMgtKey) {
        return res.status(404).json({ message: "세금계산서를 찾을 수 없습니다" });
      }

      const mgtKeyType = invoice.issueType === "forward" ? "SELL" : "BUY";
      const result = await popbill.getPDF(
        invoice.supplierCorpNum || invoice.buyerCorpNum || "",
        mgtKeyType,
        invoice.popbillMgtKey
      );

      res.json({
        success: true,
        pdfUrl: result.url,
      });
    } catch (err: any) {
      console.error("Get popbill PDF error:", err);
      res.status(500).json({ message: err.message || "PDF 조회 오류" });
    }
  });

  // 정산에서 세금계산서 생성
  app.post("/api/admin/settlements/:settlementId/create-tax-invoice", adminAuth, requirePermission("tax.issue"), async (req, res) => {
    try {
      const settlementId = Number(req.params.settlementId);
      const { issueType = "forward" } = req.body;
      
      // 정산 정보 조회
      const settlements = await storage.getAllSettlementRecords();
      const settlement = settlements.find(s => s.id === settlementId);
      
      if (!settlement) {
        return res.status(404).json({ message: "정산 정보를 찾을 수 없습니다" });
      }

      // 세금계산서 생성
      const taxInvoice = await storage.createTaxInvoice({
        orderId: settlement.orderId,
        settlementId: settlement.id,
        issueType,
        supplyAmount: Math.round(Number(settlement.supplyPrice || 0)),
        vatAmount: Math.round(Number(settlement.vat || 0)),
        totalAmount: Math.round(Number(settlement.finalTotal || 0)),
        status: "draft",
        writeDate: new Date().toISOString().split("T")[0].replace(/-/g, ""),
        createdBy: (req as any).user?.id,
      });

      res.json({
        success: true,
        taxInvoice,
        message: "세금계산서가 생성되었습니다",
      });
    } catch (err) {
      console.error("Create tax invoice from settlement error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

    try {
      const id = Number(req.params.id);
      const invoice = await storage.getTaxInvoice(id);
      
      if (!invoice) {
        return res.status(404).json({ message: "세금계산서를 찾을 수 없습니다" });
      }
      
      res.json(invoice);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 단가 변환 API (Price Conversion)
  // ============================================
  app.get("/api/admin/minimum-fares", adminAuth, requirePermission("carriers.view"), async (req, res) => {
    try {
      // courierSettings에서 최저운임 정보 조회
      const settings = await storage.getAllCourierSettings();
      const fares = settings.map(s => ({
        id: s.id,
        carrierId: s.id,
        carrierName: s.courierName,
        workType: "일반배송",
        baseWeight: "5kg이하",
        minimumAmount: s.minDeliveryFee || 3000,
        updatedAt: s.updatedAt?.toISOString().split("T")[0] || new Date().toISOString().split("T")[0],
      }));
      res.json(fares);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/price-conversion-rules", adminAuth, requirePermission("carriers.view"), async (req, res) => {
    try {
      const rules = await storage.getAllPriceConversionRules();
      res.json(rules);
    } catch (err) {
      console.error("price conversion rules fetch error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/price-conversion-rules", adminAuth, requirePermission("carriers.edit"), async (req, res) => {
    try {
      const { name, courierId, workType, timeSlot, conversionType, unit, priority, isActive } = req.body;
      
      if (!name) {
        return res.status(400).json({ message: "규칙명을 입력해주세요" });
      }
      
      if (unit !== undefined && (unit <= 0 || unit % 10 !== 0)) {
        return res.status(400).json({ message: "단위는 10 이상의 10의 배수여야 합니다" });
      }
      
      const rule = await storage.createPriceConversionRule({
        name,
        courierId: courierId || null,
        workType: workType || null,
        timeSlot: timeSlot || null,
        conversionType: conversionType || "ceiling",
        unit: unit || 100,
        priority: priority || 0,
        isActive: isActive !== false,
      });
      
      res.status(201).json(rule);
    } catch (err) {
      console.error("create price conversion rule error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/admin/price-conversion-rules/:id", adminAuth, requirePermission("carriers.edit"), async (req, res) => {
    try {
      const ruleId = parseInt(req.params.id);
      if (isNaN(ruleId)) {
        return res.status(400).json({ message: "유효하지 않은 ID입니다" });
      }
      
      const existing = await storage.getPriceConversionRule(ruleId);
      if (!existing) {
        return res.status(404).json({ message: "규칙을 찾을 수 없습니다" });
      }
      
      const { name, courierId, workType, timeSlot, conversionType, unit, priority, isActive } = req.body;
      
      if (unit !== undefined && (unit <= 0 || unit % 10 !== 0)) {
        return res.status(400).json({ message: "단위는 10 이상의 10의 배수여야 합니다" });
      }
      
      const updated = await storage.updatePriceConversionRule(ruleId, {
        ...(name !== undefined && { name }),
        ...(courierId !== undefined && { courierId }),
        ...(workType !== undefined && { workType }),
        ...(timeSlot !== undefined && { timeSlot }),
        ...(conversionType !== undefined && { conversionType }),
        ...(unit !== undefined && { unit }),
        ...(priority !== undefined && { priority }),
        ...(isActive !== undefined && { isActive }),
      });
      
      res.json(updated);
    } catch (err) {
      console.error("update price conversion rule error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/admin/price-conversion-rules/:id", adminAuth, requirePermission("carriers.edit"), async (req, res) => {
    try {
      const ruleId = parseInt(req.params.id);
      if (isNaN(ruleId)) {
        return res.status(400).json({ message: "유효하지 않은 ID입니다" });
      }
      
      const existing = await storage.getPriceConversionRule(ruleId);
      if (!existing) {
        return res.status(404).json({ message: "규칙을 찾을 수 없습니다" });
      }
      
      await storage.deletePriceConversionRule(ruleId);
      res.json({ success: true, message: "규칙이 삭제되었습니다" });
    } catch (err) {
      console.error("delete price conversion rule error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/pricing/convert", adminAuth, requirePermission("carriers.edit"), async (req, res) => {
    try {
      const { amount, courierId } = req.body;
      // 100원 단위 올림 변환
      const unit = 100;
      const converted = Math.ceil(amount / unit) * unit;
      res.json({ 
        original: amount, 
        converted, 
        unit,
        appliedRule: "100원 단위 올림",
      });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 최저운임 100원 단위 validation
  app.patch("/api/admin/minimum-fares/:id", adminAuth, requirePermission("carriers.edit"), async (req, res) => {
    try {
      const courierId = parseInt(req.params.id);
      const { minimumAmount } = req.body;
      
      if (isNaN(courierId)) {
        return res.status(400).json({ message: "유효하지 않은 ID입니다" });
      }
      
      // 100원 단위 검증
      if (minimumAmount % 100 !== 0) {
        return res.status(400).json({ 
          message: "최저운임은 100원 단위로 입력해야 합니다",
          suggestedAmount: Math.ceil(minimumAmount / 100) * 100,
        });
      }
      
      // courierSettings 업데이트
      const updated = await storage.updateCourierSetting(courierId, { 
        minDeliveryFee: minimumAmount 
      });
      
      if (!updated) {
        return res.status(404).json({ message: "택배사 설정을 찾을 수 없습니다" });
      }
      
      res.json({ success: true, message: "최저운임이 업데이트되었습니다", updated });
    } catch (err) {
      console.error("minimum fare update error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 택배사별 박스 수량 차등 가격 API
  // ============================================
  app.get("/api/admin/courier-tiered-pricing", adminAuth, requirePermission("carriers.view"), async (req, res) => {
    try {
      const tieredPricing = await storage.getAllCourierTieredPricing();
      res.json(tieredPricing);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/courier-tiered-pricing/:courierId", adminAuth, requirePermission("carriers.view"), async (req, res) => {
    try {
      const courierId = parseInt(req.params.courierId);
      const tieredPricing = await storage.getCourierTieredPricingByCourier(courierId);
      res.json(tieredPricing);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/courier-tiered-pricing", adminAuth, requirePermission("carriers.edit"), async (req, res) => {
    try {
      const { courierId, minBoxCount, maxBoxCount, minTotalVatInclusive, description } = req.body;
      
      if (!minBoxCount || minBoxCount < 1) {
        return res.status(400).json({ message: "최소 박스 수량은 1개 이상이어야 합니다" });
      }
      if (!minTotalVatInclusive || minTotalVatInclusive < 1000) {
        return res.status(400).json({ message: "최소 요청 합계금액은 1,000원 이상이어야 합니다" });
      }
      
      // VAT 포함 금액에서 VAT 제외 금액 계산 (10% VAT)
      const netTotal = Math.round(minTotalVatInclusive / 1.1);
      // 박스당 단가 계산 (100원 단위로 올림)
      const calculatedPricePerBox = Math.ceil(netTotal / minBoxCount / 100) * 100;
      // 미달 시 인상액 계산 (기본 100원, 최소 합계 유지를 위해 필요한 인상액)
      const calculatedIncrement = 100;
      
      const newTier = await storage.createCourierTieredPricing({
        courierId,
        minBoxCount,
        maxBoxCount: maxBoxCount || null,
        minTotalVatInclusive,
        pricePerBox: calculatedPricePerBox,
        belowMinIncrementPerBox: calculatedIncrement,
        description: description || null,
        isActive: true,
      });
      res.json(newTier);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/admin/courier-tiered-pricing/:id", adminAuth, requirePermission("carriers.edit"), async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const { minBoxCount, maxBoxCount, minTotalVatInclusive, description, isActive } = req.body;
      
      let calculatedPricePerBox: number | undefined;
      let calculatedIncrement: number | undefined;
      
      // minTotalVatInclusive가 제공되면 자동 계산
      if (minTotalVatInclusive && minBoxCount) {
        const netTotal = Math.round(minTotalVatInclusive / 1.1);
        calculatedPricePerBox = Math.ceil(netTotal / minBoxCount / 100) * 100;
        calculatedIncrement = 100;
      }
      
      const updated = await storage.updateCourierTieredPricing(id, {
        minBoxCount,
        maxBoxCount,
        minTotalVatInclusive,
        pricePerBox: calculatedPricePerBox,
        belowMinIncrementPerBox: calculatedIncrement,
        description,
        isActive,
      });
      res.json(updated);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/admin/courier-tiered-pricing/:id", adminAuth, requirePermission("carriers.edit"), async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.deleteCourierTieredPricing(id);
      res.json({ success: true });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 팀 QR 관리 API (Team QR Management)
  // ============================================
  const createTeamQrSchema = z.object({
    teamId: z.number({ coerce: true }),
    expiryDays: z.number({ coerce: true }).optional(),
  });
  
  const updateTeamCommissionSchema = z.object({
    commissionRate: z.number({ coerce: true }).min(0).max(100),
    notes: z.string().optional(),
  });
  
  const assignTeamLeaderSchema = z.object({
    teamName: z.string().optional(),
    commissionRate: z.number({ coerce: true }).min(0).max(100).optional(),
  });
  
  app.get("/api/admin/team-qr", adminAuth, requirePermission("teams.qr"), async (req, res) => {
    try {
      const qrCodes = await storage.getAllTeamQrCodes();
      const teams = await storage.getAllTeams();
      const teamMap = new Map(teams.map(t => [t.id, t]));
      
      const result = qrCodes.map(qr => ({
        ...qr,
        teamName: teamMap.get(qr.teamId)?.name || '알 수 없음',
      }));
      res.json(result);
    } catch (err) {
      console.error("team-qr list error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/team-qr/scan-logs", adminAuth, requirePermission("teams.qr"), async (req, res) => {
    try {
      const logs = await storage.getAllQrScanLogs();
      res.json(logs);
    } catch (err) {
      console.error("scan-logs error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/team-qr", adminAuth, requirePermission("teams.qr"), async (req, res) => {
    try {
      const parsed = createTeamQrSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "유효하지 않은 요청입니다", errors: parsed.error.errors });
      }
      
      const { teamId, expiryDays } = parsed.data;
      
      const team = await storage.getTeam(teamId);
      if (!team) {
        return res.status(404).json({ message: "팀을 찾을 수 없습니다" });
      }
      
      const code = `TEAM-${teamId}-${Date.now().toString(36).toUpperCase()}`;
      const expiresAt = expiryDays ? new Date(Date.now() + expiryDays * 24 * 60 * 60 * 1000) : null;
      
      const created = await storage.createTeamQrCode({
        teamId,
        code,
        qrType: "TEAM_JOIN_QR",
        expiresAt,
        status: "active",
      });
      
      res.json({ success: true, qrCode: created });
    } catch (err) {
      console.error("team-qr create error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.delete("/api/admin/team-qr/:id", adminAuth, requirePermission("teams.qr"), async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      await storage.revokeTeamQrCode(id);
      res.json({ success: true, message: "QR 코드가 폐기되었습니다" });
    } catch (err) {
      console.error("team-qr revoke error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // ============================================
  // 팀장 지정 API (Assign Team Leader)
  // 관리자가 헬퍼를 팀장으로 지정하면 팀 생성 및 QR 변경
  // ============================================
  app.post("/api/admin/helpers/:helperId/assign-team-leader", adminAuth, requirePermission("teams.edit"), async (req, res) => {
    try {
      const { helperId } = req.params;
      const parsed = assignTeamLeaderSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "유효하지 않은 요청입니다", errors: parsed.error.errors });
      }
      
      const { teamName, commissionRate } = parsed.data;
      
      const helper = await storage.getUser(helperId);
      if (!helper || helper.role !== "helper") {
        return res.status(404).json({ message: "헬퍼를 찾을 수 없습니다" });
      }
      
      const existingTeam = await storage.getTeamByLeader(helperId);
      if (existingTeam) {
        return res.status(400).json({ message: "이미 팀장으로 등록되어 있습니다" });
      }
      
      const teamQrToken = helper.checkInToken || `team-${Date.now().toString(36)}`;
      const finalTeamName = teamName || `${helper.name || helper.username}팀`;
      const rate = commissionRate !== undefined ? commissionRate : 5;
      
      const { team } = await storage.assignTeamLeaderTransactional({
        teamName: finalTeamName,
        teamQrToken,
        commissionRate: rate,
      });
      
      res.json({ 
        success: true, 
        team,
        message: `${helper.name || helper.username}님이 팀장으로 지정되었습니다` 
      });
    } catch (err) {
      console.error("assign team leader error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  app.patch("/api/admin/teams/:teamId/commission", adminAuth, requirePermission("teams.edit"), async (req, res) => {
    try {
      const teamId = Number(req.params.teamId);
      const parsed = updateTeamCommissionSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ message: "유효하지 않은 요청입니다", errors: parsed.error.errors });
      }
      
      const { commissionRate, notes } = parsed.data;
      
      const team = await storage.getTeam(teamId);
      if (!team) {
        return res.status(404).json({ message: "팀을 찾을 수 없습니다" });
      }
      
      const existing = await storage.getTeamCommissionOverride(teamId);
      
      if (existing) {
        const updated = await storage.updateTeamCommissionOverride(existing.id, {
          commissionRate,
          notes: notes || existing.notes,
        });
        res.json(updated);
      } else {
        const created = await storage.createTeamCommissionOverride({
          teamId,
          commissionRate,
          notes: notes || "관리자 설정",
        });
        res.json(created);
      }
    } catch (err) {
      console.error("team commission update error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 헬퍼 온보딩 승인 API (Helper Onboarding Approval)
  // ============================================
  app.get("/api/admin/helpers/onboarding", adminAuth, requirePermission("helpers.verify"), async (req, res) => {
    try {
      const { status } = req.query;
      const credentials = await storage.getHelperCredentialsByStatus(status as string || "pending");
      res.json(credentials);
    } catch (err) {
      console.error("onboarding list error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/helpers/:id/onboarding/approve", adminAuth, requirePermission("helpers.verify"), async (req, res) => {
    try {
      const credentialId = parseInt(req.params.id);
      const reviewerId = (req as any).user?.id;
      
      // Get the credential to find the userId
      const credential = await storage.getHelperCredentialById(credentialId);
      if (!credential) {
        return res.status(404).json({ message: "자격 증명을 찾을 수 없습니다" });
      }
      
      const oldStatus = credential.verificationStatus;
      await storage.updateHelperCredentialStatus(credentialId, "approved", reviewerId);
      
      // 감사 로그 기록
      await storage.createAuditLog({
        userId: reviewerId,
        action: "helper.onboarding.approve",
        targetType: "helper_credential",
        targetId: String(credentialId),
        oldValue: JSON.stringify({ verificationStatus: oldStatus, userId: credential.userId }),
        newValue: JSON.stringify({ verificationStatus: "approved", userId: credential.userId }),
        ipAddress: req.ip || req.headers["x-forwarded-for"]?.toString() || null,
        userAgent: req.headers["user-agent"] || null,
      });
      
      // Send push notification to the helper
      await storage.createNotification({
        userId: credential.userId,
        type: "onboarding_approved",
        title: "가입 승인 완료",
        message: "축하합니다! 헬퍼 가입이 승인되었습니다. 이제 오더를 확인하고 업무를 시작할 수 있습니다.",
        relatedId: credentialId,
      });
      
      res.json({ success: true, message: "승인되었습니다" });
    } catch (err) {
      console.error("approve error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/helpers/:id/onboarding/reject", adminAuth, requirePermission("helpers.verify"), async (req, res) => {
    try {
      const credentialId = parseInt(req.params.id);
      const { reason } = req.body;
      const reviewerId = (req as any).user?.id;
      
      // Get the credential to find the userId
      const credential = await storage.getHelperCredentialById(credentialId);
      if (!credential) {
        return res.status(404).json({ message: "자격 증명을 찾을 수 없습니다" });
      }
      
      const oldStatus = credential.verificationStatus;
      await storage.updateHelperCredentialStatus(credentialId, "rejected", reviewerId, reason);
      
      // 감사 로그 기록
      await storage.createAuditLog({
        userId: reviewerId,
        action: "helper.onboarding.reject",
        targetType: "helper_credential",
        targetId: String(credentialId),
        oldValue: JSON.stringify({ verificationStatus: oldStatus, userId: credential.userId }),
        newValue: JSON.stringify({ verificationStatus: "rejected", userId: credential.userId, reason }),
        ipAddress: req.ip || req.headers["x-forwarded-for"]?.toString() || null,
        userAgent: req.headers["user-agent"] || null,
      });
      
      // Send push notification to the helper with rejection reason
      await storage.createNotification({
        userId: credential.userId,
        type: "onboarding_rejected",
        title: "가입 반려",
        message: `헬퍼 가입이 반려되었습니다. 사유: ${reason || "사유 없음"}. 정보를 수정 후 다시 제출해주세요.`,
        relatedId: credentialId,
      });
      
      res.json({ success: true, message: "반려되었습니다" });
    } catch (err) {
      console.error("reject error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 헬퍼 가입 승인/반려 API (User-level onboarding)
  // ============================================
  
  // 심사 대기중인 헬퍼 목록 조회
  app.get("/api/admin/helpers/pending", adminAuth, requirePermission("helpers.verify"), async (req, res) => {
    try {
      const users = await storage.getAllUsers();
      const pendingHelpers = users.filter(u => u.role === "helper" && u.onboardingStatus === "pending");
      
      // 각 헬퍼의 서류 정보 조회
      const helpersWithDocs = await Promise.all(pendingHelpers.map(async (helper) => {
        const [credential, vehicle, license, bankAccount] = await Promise.all([
          storage.getHelperCredential(helper.id),
          storage.getHelperVehicle(helper.id),
          storage.getHelperLicense(helper.id),
          storage.getHelperBankAccount(helper.id),
        ]);
        
        return {
          id: helper.id,
          username: helper.username,
          name: helper.name,
          email: helper.email,
          phoneNumber: helper.phoneNumber,
          onboardingStatus: helper.onboardingStatus,
          createdAt: helper.createdAt,
          credential,
          vehicle,
          license,
          bankAccount,
        };
      }));
      
      res.json(helpersWithDocs);
    } catch (err) {
      console.error("pending helpers error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 헬퍼 가입 승인 (User-level)
  app.post("/api/admin/helpers/:helperId/approve", adminAuth, requirePermission("helpers.verify"), async (req, res) => {
    try {
      const { helperId } = req.params;
      const reviewerId = (req as any).user?.id;
      
      const helper = await storage.getUser(helperId);
      if (!helper || helper.role !== "helper") {
        return res.status(404).json({ message: "헬퍼를 찾을 수 없습니다" });
      }
      
      if (helper.onboardingStatus === "approved") {
        return res.status(400).json({ message: "이미 승인된 헬퍼입니다" });
      }
      
      // 사용자 온보딩 상태 업데이트
      await storage.updateUser(helperId, {
        onboardingStatus: "approved",
        onboardingReviewedAt: new Date(),
        onboardingReviewedBy: reviewerId,
        onboardingRejectReason: null,
      });
      
      // 알림 저장 및 푸시 알림 전송
      await storage.createNotification({
        type: "onboarding_approved",
        title: "가입 승인 완료",
        message: "축하합니다! 헬퍼 가입이 승인되었습니다. 이제 오더를 확인하고 업무를 시작할 수 있습니다.",
        relatedId: null,
      });
      
      // 실제 푸시 알림 전송
      sendPushToUser(helperId, {
        title: "가입 승인 완료",
        body: "축하합니다! 헬퍼 가입이 승인되었습니다. 이제 오더를 확인하고 업무를 시작할 수 있습니다.",
        url: "/helper-home",
        tag: "onboarding_approved",
      });
      
      // WebSocket notification for real-time status update
      notificationWS.sendDataRefresh(helperId, {
        type: "onboarding",
        action: "updated",
        metadata: { status: "approved" },
      });
      
      // SMS 알림 발송
      if (helper.phoneNumber) {
        const smsResult = await smsService.sendApprovalNotice(helper.phoneNumber, helper.name);
        if (!smsResult.success) {
          console.error(`[승인 SMS 실패] ${smsResult.error}`);
        }
      }
      
      res.json({ success: true, message: "헬퍼 가입이 승인되었습니다" });
    } catch (err) {
      console.error("approve helper error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 헬퍼 가입 반려 (User-level)
  app.post("/api/admin/helpers/:helperId/reject", adminAuth, requirePermission("helpers.verify"), async (req, res) => {
    try {
      const { helperId } = req.params;
      const { reason } = req.body;
      const reviewerId = (req as any).user?.id;
      
      if (!reason || !reason.trim()) {
        return res.status(400).json({ message: "반려 사유를 입력해주세요" });
      }
      
      const helper = await storage.getUser(helperId);
      if (!helper || helper.role !== "helper") {
        return res.status(404).json({ message: "헬퍼를 찾을 수 없습니다" });
      }
      
      // 사용자 온보딩 상태 업데이트
      await storage.updateUser(helperId, {
        onboardingStatus: "rejected",
        onboardingReviewedAt: new Date(),
        onboardingReviewedBy: reviewerId,
        onboardingRejectReason: reason.trim(),
      });
      
      // 알림 저장 및 푸시 알림 전송
      await storage.createNotification({
        type: "onboarding_rejected",
        title: "가입 심사 반려",
        message: `가입 심사가 반려되었습니다. 사유: ${reason.trim()}`,
        relatedId: null,
      });
      
      // 실제 푸시 알림 전송
      sendPushToUser(helperId, {
        title: "가입 심사 반려",
        body: `가입 심사가 반려되었습니다. 사유: ${reason.trim()}`,
        url: "/helper-home",
        tag: "onboarding_rejected",
      });
      
      // WebSocket notification for real-time status update
      notificationWS.sendDataRefresh(helperId, {
        type: "onboarding",
        action: "updated",
        metadata: { status: "rejected" },
      });
      
      // SMS 알림 발송
      if (helper.phoneNumber) {
        const smsResult = await smsService.sendRejectionNotice(helper.phoneNumber, helper.name, reason);
        if (!smsResult.success) {
          console.error(`[반려 SMS 실패] ${smsResult.error}`);
        }
      }
      
      res.json({ success: true, message: "헬퍼 가입이 반려되었습니다" });
    } catch (err) {
      console.error("reject helper error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 헬퍼 앱 정산/인센티브 조회 API
  // ============================================
  app.get("/api/helpers/me/settlements", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const settlements = await storage.getSettlementsByHelper(userId);
      res.json(settlements);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.patch("/api/helpers/settlements/:id/confirm", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const settlementId = Number(req.params.id);
      
      // Idempotency check
      const idempotencyKey = getIdempotencyKeyFromRequest(req);
      if (idempotencyKey) {
        const { isDuplicate, cachedResponse } = await checkIdempotency(
          userId,
          `PATCH:/api/helpers/settlements/${settlementId}/confirm`,
          idempotencyKey
        );
        if (isDuplicate && cachedResponse) {
          console.log(`[Idempotency] Returning cached settlement confirm for ${settlementId}, key: ${idempotencyKey}`);
          return res.status(cachedResponse.status).json(cachedResponse.body);
        }
      }
      
      if (!settlementId || isNaN(settlementId)) {
        return res.status(400).json({ message: "유효하지 않은 정산 ID입니다" });
      }
      
      const settlement = await storage.getSettlementStatement(settlementId);
      
      if (!settlement) {
        return res.status(404).json({ message: "정산 내역을 찾을 수 없습니다" });
      }
      
      if (settlement.helperId !== userId) {
        return res.status(403).json({ message: "본인의 정산만 확인할 수 있습니다" });
      }
      
      if (settlement.helperConfirmed) {
        return res.status(400).json({ message: "이미 확인된 정산입니다" });
      }
      
      const forwardedFor = req.headers["x-forwarded-for"];
      const ipAddress = (typeof forwardedFor === "string" ? forwardedFor.split(",")[0].trim() : null) 
        || req.ip 
        || req.socket?.remoteAddress 
        || "unknown";
      const userAgent = req.headers["user-agent"] || "unknown";
      
      const updated = await storage.updateSettlementStatement(settlementId, {
        helperConfirmed: true,
        helperConfirmedAt: new Date(),
        helperIpAddress: typeof ipAddress === "string" ? ipAddress : String(ipAddress),
        helperUserAgent: userAgent,
      });
      
      console.log(`[Settlement Confirmed] Settlement ${settlementId} confirmed by helper ${userId}`);
      
      const confirmResponse = { success: true, message: "정산 내역을 확인했습니다", settlement: updated };
      
      // Store idempotency response
      if (idempotencyKey) {
        await storeIdempotencyResponse(userId, `PATCH:/api/helpers/settlements/${settlementId}/confirm`, idempotencyKey, 200, confirmResponse);
      }
      
      res.json(confirmResponse);
    } catch (err) {
      console.error("helper settlement confirm error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/team-leader/incentives", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const user = await storage.getUser(userId);
      if (!user?.isTeamLeader) {
        return res.status(403).json({ message: "팀장만 접근 가능합니다" });
      }
      const incentives = await storage.getIncentivesByTeamLeader(userId);
      res.json(incentives);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 헬퍼 개인식별 코드 API
  // ============================================
  
  // 헬퍼 개인 코드 조회 (없으면 생성)
  app.get("/api/helpers/me/personal-code", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const user = await storage.getUser(userId);
      
      if (!user || user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      const code = await getOrCreatePersonalCode(userId);
      
      res.json({ 
        personalCode: code,
        isTeamLeader: user.isTeamLeader,
        teamName: user.teamName,
      });
    } catch (err) {
      console.error("get personal code error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 의뢰인 개인 코드 조회 (없으면 생성) - 웹 텍스트 입력용
  app.get("/api/requesters/me/personal-code", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const user = await storage.getUser(userId);
      
      if (!user || user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 접근 가능합니다" });
      }
      
      const code = await getOrCreatePersonalCode(userId);
      
      res.json({ 
        personalCode: code,
        name: user.name,
      });
    } catch (err) {
      console.error("get requester personal code error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 팀 탈퇴 API
  app.post("/api/helpers/me/leave-team", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const user = await storage.getUser(userId);
      
      if (!user || user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 접근 가능합니다" });
      }
      
      // 팀 소속 확인
      const teamMembership = await storage.getTeamMemberByUserId(userId);
      if (!teamMembership || !teamMembership.isActive) {
        return res.status(400).json({ message: "소속된 팀이 없습니다" });
      }
      
      // 팀장은 탈퇴 불가 (팀 해산 필요)
      if (user.isTeamLeader) {
        return res.status(400).json({ message: "팀장은 팀을 탈퇴할 수 없습니다. 관리자에게 문의해주세요." });
      }
      
      // 팀 멤버십 비활성화
      await storage.updateTeamMember(teamMembership.id, {
        isActive: false,
      });
      
      // 사용자 정보 업데이트
      await storage.updateUser(userId, {
        teamName: null,
      });
      
      res.json({ success: true, message: "팀에서 탈퇴했습니다" });
    } catch (err) {
      console.error("leave team error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 팀장 팀 QR 코드 조회 (본인 팀)
  app.get("/api/team-leader/team-qr", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const user = await storage.getUser(userId);
      
      if (!user?.isTeamLeader) {
        return res.status(403).json({ message: "팀장만 접근 가능합니다" });
      }
      
      // 팀 조회
      const team = await storage.getTeamByLeader(userId);
      if (!team) {
        return res.status(404).json({ message: "팀을 찾을 수 없습니다" });
      }
      
      // 팀 QR 코드 조회
      const qrCodes = await storage.getTeamQrCodes(team.id);
      const activeQr = qrCodes.find((qr: any) => qr.status === "active");
      
      res.json({
        teamId: team.id,
        teamName: team.name,
        qrCode: activeQr?.code || user.personalCode || null,
        qrType: activeQr ? "team_qr" : "personal_code",
      });
    } catch (err) {
      console.error("get team qr error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 헬퍼 팀 관리 API (Team QR)
  // ============================================
  
  // 팀장의 팀 정보 및 QR 코드 조회
  app.get("/api/helper/my-team", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const user = await storage.getUser(userId);
      
      if (!user || !user.isTeamLeader) {
        return res.status(403).json({ message: "팀장만 접근할 수 있습니다" });
      }

      // Get or create team for this leader
      let team = await storage.getTeamByLeader(userId);
      
      if (!team) {
        // Auto-create team for team leader with unique QR token
        const qrToken = `TEAM_${randomUUID()}`;
        team = await storage.createTeam({
          leaderId: userId,
          name: user.teamName || `${user.name || '헬퍼'} 팀`,
          qrCodeToken: qrToken,
          isActive: true,
        });
        
        // Add leader as a member of their own team
        await storage.addTeamMember({
          teamId: team.id,
          helperId: userId,
          isActive: true,
        });
      }

      // Ensure team has a valid QR token (regenerate if missing)
      if (!team.qrCodeToken) {
        team = await storage.regenerateTeamQrToken(team.id);
      }

      // Get member count
      const members = await storage.getTeamMembers(team.id);
      
      res.json({
        teamId: team.id,
        teamName: team.name,
        qrCode: team.qrCodeToken,
        memberCount: members.length,
        members: members.map(m => ({
          id: m.id,
        })),
      });
    } catch (err) {
      console.error("Error fetching team info:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 팀원 가입 (QR 스캔 - 팀장 개인코드 또는 팀 QR 토큰)
  app.post("/api/helper/join-team", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const { qrCode, personalCode } = req.body;

      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "사용자를 찾을 수 없습니다" });
      }

      if (user.role !== "helper") {
        return res.status(403).json({ message: "헬퍼만 팀에 가입할 수 있습니다" });
      }

      let team;
      
      // personalCode가 명시적으로 제공된 경우: 팀장 개인코드로 팀 찾기
      if (personalCode) {
        // 개인코드 정규화 (대문자)
        const normalizedCode = personalCode.trim().toUpperCase();
        const teamLeader = await storage.getUserByPersonalCode(normalizedCode);
        
        if (teamLeader) {
          if (!teamLeader.isTeamLeader) {
            return res.status(400).json({ message: "해당 사용자는 팀장이 아닙니다" });
          }
          team = await storage.getTeamByLeader(teamLeader.id);
          if (!team) {
            return res.status(404).json({ message: "해당 팀장의 팀을 찾을 수 없습니다" });
          }
        } else {
          // 개인코드로 찾지 못한 경우 팀 토큰으로 폴백 시도
          team = await storage.getTeamByToken(personalCode);
          if (!team) {
            return res.status(404).json({ message: "유효하지 않은 개인코드입니다" });
          }
        }
      } else if (qrCode) {
        // qrCode가 제공된 경우: 기존 팀 QR 토큰으로 팀 찾기 (레거시 호환)
        team = await storage.getTeamByToken(qrCode);
        if (!team) {
          return res.status(404).json({ message: "유효하지 않은 QR 코드입니다" });
        }
      } else {
        return res.status(400).json({ message: "팀장 개인코드 또는 QR 코드가 필요합니다" });
      }

      // Block leaders from joining their own team
      if (team.leaderId === userId) {
        return res.status(400).json({ message: "본인의 팀에 가입할 수 없습니다" });
      }

      // Check if user is already a team leader
      if (user.isTeamLeader) {
        return res.status(400).json({ message: "팀장은 다른 팀에 가입할 수 없습니다" });
      }

      // Check if already in a team
      const existingMembership = await storage.getHelperTeam(userId);
      if (existingMembership) {
        // If already in this team, return success (idempotent)
        if (existingMembership.team.id === team.id) {
          return res.json({ 
            success: true, 
            teamName: team.name,
            message: `이미 ${team.name} 팀에 소속되어 있습니다` 
          });
        }
        return res.status(400).json({ message: "이미 다른 팀에 소속되어 있습니다" });
      }

      // Check if already a member of this specific team (defensive)
      const isAlreadyMember = await storage.isHelperInTeam(team.id, userId);
      if (isAlreadyMember) {
        return res.json({ 
          success: true, 
          teamName: team.name,
          message: `이미 ${team.name} 팀에 소속되어 있습니다` 
        });
      }

      // Join the team
      await storage.addTeamMember({
        teamId: team.id,
        helperId: userId,
        isActive: true,
      });

      // Update user's team name
      await storage.updateUser(userId, { teamName: team.name });

      res.json({ 
        success: true, 
        teamName: team.name,
        message: `${team.name} 팀에 가입되었습니다` 
      });
    } catch (err) {
      console.error("Error joining team:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 헬퍼 대행배차 수락/거절 API
  // ============================================
  app.get("/api/helper/dispatch-requests", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const requests = await storage.getDispatchRequestsForHelper(userId);
      res.json(requests);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/helper/dispatch-requests/:id/accept", requireAuth, async (req, res) => {
    try {
      const requestId = parseInt(req.params.id);
      const userId = (req as any).user?.id;
      await storage.acceptDispatchRequest(requestId, userId);
      res.json({ success: true, message: "배차를 수락했습니다" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/helper/dispatch-requests/:id/reject", requireAuth, async (req, res) => {
    try {
      const requestId = parseInt(req.params.id);
      const { reason } = req.body;
      await storage.rejectDispatchRequest(requestId, reason);
      res.json({ success: true, message: "배차를 거절했습니다" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 팀 QR 스캔 로그 (팀별 필터)
  // ============================================
  app.get("/api/admin/teams/:teamId/qr/scans", adminAuth, requirePermission("teams.qr"), async (req, res) => {
    try {
      const teamId = parseInt(req.params.teamId);
      const logs = await storage.getQrScanLogsByTeam(teamId);
      res.json(logs);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 긴급 대타 요청 API (Substitute Requests)
  // ============================================
  app.post("/api/substitute-requests", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const { orderId, urgencyLevel, workDate, workContent } = req.body;
      const request = await storage.createSubstituteRequest({
        requesterId: userId,
        orderId,
        urgencyLevel: urgencyLevel || "normal",
        workDate: workDate || new Date().toISOString().split("T")[0],
        requestDate: new Date().toISOString().split("T")[0],
        workContent,
        status: "pending",
      });
      res.status(201).json(request);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/substitute-requests/feed", requireAuth, async (req, res) => {
    try {
      const requests = await storage.getPendingSubstituteRequests();
      res.json(requests);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/substitute-requests/:id/accept", requireAuth, async (req, res) => {
    try {
      const requestId = parseInt(req.params.id);
      const userId = (req as any).user?.id;
      await storage.acceptSubstituteRequest(requestId, userId);
      res.json({ success: true, message: "대타 요청을 수락했습니다" });
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 지시사항 이력 API (Instruction Logs)
  // ============================================
  app.post("/api/admin/contracts/:id/instructions", adminAuth, requirePermission("contracts.edit"), async (req, res) => {
    try {
      const jobContractId = parseInt(req.params.id);
      const userId = (req as any).user?.id;
      const { instructionContent, instructionType } = req.body;
      const log = await storage.createInstructionLog({
        jobContractId,
        issuerId: userId,
        instructionContent: instructionContent || "",
        instructionType: instructionType || "general",
      });
      res.status(201).json(log);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.get("/api/admin/contracts/:id/instructions", adminAuth, requirePermission("contracts.view"), async (req, res) => {
    try {
      const contractId = parseInt(req.params.id);
      const logs = await storage.getInstructionLogsByContract(contractId);
      res.json(logs);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 단가 변환 규칙 CRUD (Price Conversion Rules)
  // ============================================
  app.get("/api/admin/pricing/conversion-rules", adminAuth, requirePermission("carriers.view"), async (req, res) => {
    try {
      const rules = await storage.getAllPriceConversionRules();
      res.json(rules);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  app.post("/api/admin/pricing/conversion-rules", adminAuth, requirePermission("carriers.edit"), async (req, res) => {
    try {
      const { name, conversionType, unit, priority, isActive } = req.body;
      const rule = await storage.createPriceConversionRule({
        name,
        conversionType,
        unit: unit || 100,
        priority: priority || 1,
        isActive: isActive !== false,
      });
      res.status(201).json(rule);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 내 제재 조회 API (My Sanctions)
  // ============================================
  app.get("/api/me/sanctions", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const sanctions = await storage.getSanctionsByUser(userId);
      res.json(sanctions);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // 분쟁 상태 조회 API (My Incidents)
  // ============================================
  app.get("/api/incidents/my", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const incidents = await storage.getIncidentsByUser(userId);
      res.json(incidents);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // QR 기반 출근 체크 API (QR Check-in)
  // ============================================
  
  // 헬퍼 역할 확인 미들웨어
  const requireHelper = async (req: any, res: any, next: any) => {
    const user = await storage.getUser(req.user?.id);
    if (!user || user.role !== "helper") {
      return res.status(403).json({ message: "헬퍼만 출근 체크를 할 수 있습니다" });
    }
    req.helperUser = user;
    next();
  };
  
  app.post("/api/checkin/qr", requireAuth, requireHelper, async (req: any, res) => {
    try {
      const helperId = req.user?.id;
      const helperUser = req.helperUser;
      const { qrData, latitude, longitude, address } = req.body;
      
      // QR 데이터 파싱
      let parsedQR;
      try {
        parsedQR = JSON.parse(qrData);
      } catch {
        return res.status(400).json({ message: "잘못된 QR 코드입니다" });
      }
      
      // QR 유형 확인
      if (parsedQR.type !== "hellpme_checkin") {
        return res.status(400).json({ message: "출근 체크용 QR 코드가 아닙니다" });
      }
      
      const requesterId = parsedQR.requesterId;
      if (!requesterId) {
        return res.status(400).json({ message: "의뢰인 정보가 없는 QR 코드입니다" });
      }
      
      // 영구 토큰 검증
      if (!parsedQR.token) {
        return res.status(400).json({ message: "유효하지 않은 QR 코드입니다" });
      }
      
      // 의뢰인 확인 및 토큰 검증
      const requester = await storage.getUser(requesterId);
      if (!requester || requester.role !== "requester") {
        return res.status(400).json({ message: "유효하지 않은 의뢰인입니다" });
      }
      
      if (requester.checkInToken !== parsedQR.token) {
        return res.status(400).json({ message: "QR 코드가 유효하지 않습니다" });
      }
      
      // 헬퍼-의뢰인 간 활성 배정 확인
      const helperApplications = await storage.getHelperApplications(helperId);
      const requesterOrders = await storage.getOrdersByRequesterId(requesterId);
      const activeOrderIds = new Set(
        requesterOrders
          .filter(o => {
            const s = normalizeOrderStatus(o.status);
            return s === ORDER_STATUS.SCHEDULED || s === ORDER_STATUS.OPEN;
          })
          .map(o => o.id)
      );
      
      const hasActiveAssignment = helperApplications.some(
        app => app.status === "approved" && activeOrderIds.has(app.orderId)
      );
      
      if (!hasActiveAssignment) {
        return res.status(403).json({ 
          message: "이 의뢰인과의 활성 배정이 없습니다. 오더에 지원 후 승인되어야 출근할 수 있습니다." 
        });
      }
      
      // 이미 오늘 이 의뢰인에게 출근한 기록이 있는지 확인 (중복 출근 방지)
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const existingRecords = await storage.getCheckInRecordsByHelper(helperId, today);
      const alreadyCheckedIn = existingRecords.some(r => r.requesterId === requesterId);
      
      if (alreadyCheckedIn) {
        return res.status(400).json({ 
          message: "이미 오늘 이 의뢰인에게 출근 체크를 하셨습니다",
          alreadyCheckedIn: true
        });
      }
      
      // 해당 헬퍼가 배정된 활성 오더 찾기 (scheduled → in_progress로 변경)
      const approvedApp = helperApplications.find(
        app => (app.status === "approved" || app.status === "selected") && activeOrderIds.has(app.orderId)
      );
      
      let updatedOrder = null;
      if (approvedApp) {
        const order = await storage.getOrder(approvedApp.orderId);
        // 출근 가능한 상태: scheduled 또는 레거시 상태들 (normalizeOrderStatus로 변환됨)
        const orderStatus = normalizeOrderStatus(order.status);
        if (order && (orderStatus === ORDER_STATUS.SCHEDULED || orderStatus === ORDER_STATUS.OPEN)) {
          // 오더 상태를 "in_progress" (업무중)으로 변경
          updatedOrder = await storage.updateOrder(approvedApp.orderId, {
            status: "in_progress",
          });
          
          // 배정 기록에 체크인 시간 기록
          await storage.updateOrderApplication(approvedApp.id, {
            checkedInAt: new Date(),
          });
        }
      }
      
      // 출근 기록 생성
      const checkInRecord = await storage.createCheckInRecord({
        requesterId,
        requesterName: parsedQR.requesterName || requester.name,
        checkInTime: new Date(),
        latitude: latitude || null,
        longitude: longitude || null,
        address: address || null,
        status: "checked_in",
        orderId: approvedApp?.orderId || null,
      });
      
      // 헬퍼 상태를 "근무중"으로 변경
      await storage.updateUser(helperId, { dailyStatus: "working" });
      
      // 알림 생성 - 의뢰인에게 헬퍼 출근 알림
      await storage.createNotification({
        userId: requesterId,
        type: "order_application",
        title: "헬퍼 출근 완료",
        message: `${helperUser?.name || "헬퍼"}님이 출근 체크를 완료했습니다. 오더가 업무중으로 변경되었습니다.`,
        relatedId: checkInRecord.id,
      });
      
      res.status(201).json({
        success: true,
        message: "출근 체크가 완료되었습니다. 오더가 업무중으로 변경되었습니다.",
        checkIn: checkInRecord,
        requesterName: parsedQR.requesterName || requester.name,
        orderStatus: updatedOrder?.status || null,
      });
    } catch (err) {
      console.error("Check-in error:", err);
      res.status(500).json({ message: "출근 체크 중 오류가 발생했습니다" });
    }
  });

  // 출근 체크 (scheduled → in_progress 상태 변경) - 헬퍼가 QR 스캔 또는 직접 출근
  app.post("/api/checkin", requireAuth, requireHelper, async (req: any, res) => {
    try {
      const helperId = req.user?.id;
      const helperUser = req.helperUser;
      const { orderId, latitude, longitude, address } = req.body;
      
      if (!orderId) {
        return res.status(400).json({ message: "오더 ID가 필요합니다" });
      }
      
      // 오더 확인
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }
      
      // 이미 오늘 이 오더에 출근한 기록이 있는지 확인
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const existingRecords = await storage.getCheckInRecordsByHelper(helperId, today);
      const alreadyCheckedIn = existingRecords.some(r => r.orderId === orderId);
      
      if (alreadyCheckedIn) {
        return res.status(400).json({ message: "이미 출근 체크를 하셨습니다" });
      }
      
      const checkInTime = new Date();
      
      // 출근 기록 생성
      const checkInRecord = await storage.createCheckInRecord({
        orderId: orderId,
        requesterId: order.requesterId || "",
        requesterName: null,
        checkInTime,
        latitude: latitude || null,
        longitude: longitude || null,
        address: address || null,
        status: "checked_in",
      });
      
      // 헬퍼 신청 상태를 in_progress로 변경
      const application = await storage.getOrderApplication(orderId, helperId);
      if (application && application.status === "scheduled") {
        await storage.updateOrderApplication(application.id, {
          status: "in_progress",
          checkedInAt: checkInTime,
        });
      }
      
      // 오더 상태를 in_progress로 변경
      if (order.status === "scheduled") {
        await storage.updateOrder(orderId, {
          status: "in_progress",
          checkedInAt: checkInTime,
        });
      }
      
      // 헬퍼 상태를 "근무중"으로 변경
      await storage.updateUser(helperId, { dailyStatus: "working" });
      
      // 알림 생성 - 의뢰인에게 헬퍼 출근 알림
      if (order.requesterId) {
        await storage.createNotification({
          userId: order.requesterId,
          type: "helper_checked_in",
          title: "헬퍼 출근",
          message: `${helperUser?.name || "헬퍼"}님이 ${order.companyName} 오더에 출근했습니다.`,
          relatedId: orderId,
        });
        
        // WebSocket 알림
        notificationWS.sendOrderStatusUpdate(order.requesterId, {
          orderId,
          status: "in_progress",
          approvalStatus: order.approvalStatus || undefined,
        });
        notificationWS.sendToUser(order.requesterId, {
          type: "helper_checked_in",
          title: "헬퍼 출근",
          message: `${helperUser?.name || "헬퍼"}님이 ${order.companyName} 오더에 출근했습니다.`,
          relatedId: orderId,
        });
        
        // 푸시 알림
        sendPushToUser(order.requesterId, {
          title: "헬퍼 출근",
          body: `${helperUser?.name || "헬퍼"}님이 ${order.companyName} 오더에 출근했습니다.`,
          url: "/requester-home",
          tag: `checkin-${orderId}`,
        });
      }
      
      // 관리자에게 브로드캐스트
      broadcastToAllAdmins("order_status", "helper_checked_in", orderId, {
        orderId,
        helperName: helperUser?.name,
        companyName: order.companyName,
      });
      
      res.status(201).json({
        success: true,
        message: "출근 체크가 완료되었습니다",
        checkIn: checkInRecord,
      });
    } catch (err) {
      console.error("Check-in error:", err);
      res.status(500).json({ message: "출근 체크 중 오류가 발생했습니다" });
    }
  });

  // 오더 기반 체크인 (오래된 코드 - 새로운 체크인 라우트 이후에 유지)
  app.post("/api/checkin/order", requireAuth, requireHelper, async (req: any, res) => {
    try {
      const helperId = req.user?.id;
      const helperUser = req.helperUser;
      const { orderId, latitude, longitude, address } = req.body;
      
      if (!orderId) {
        return res.status(400).json({ message: "오더 ID가 필요합니다" });
      }
      
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }
      
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const existingRecords = await storage.getCheckInRecordsByHelper(helperId, today);
      const alreadyCheckedIn = existingRecords.some(r => r.orderId === orderId);
      
      if (alreadyCheckedIn) {
        return res.status(400).json({ message: "이미 출근 체크를 하셨습니다" });
      }
      
      const checkInRecord = await storage.createCheckInRecord({
        orderId: orderId,
        requesterId: order.requesterId || "",
        requesterName: null,
        checkInTime: new Date(),
        latitude: latitude || null,
        longitude: longitude || null,
        address: address || null,
        status: "checked_in",
      });
      
      await storage.updateUser(helperId, { dailyStatus: "working" });
      
      if (order.requesterId) {
        await storage.createNotification({
          userId: order.requesterId,
          type: "order_application",
          title: "헬퍼 출근 완료",
          message: `${helperUser?.name || "헬퍼"}님이 오더 #${orderId}에 출근 체크를 완료했습니다.`,
          relatedId: checkInRecord.id,
        });
        
        // Real-time update to requester
        notificationWS.sendOrderStatusUpdate(order.requesterId, {
          orderId,
          status: "checked_in",
          currentHelpers: order.currentHelpers || 1,
        });
        notificationWS.sendToUser(order.requesterId, {
          type: "checkin_update",
          title: "헬퍼 출근 완료",
          message: `${helperUser?.name || "헬퍼"}님이 출근 체크를 완료했습니다.`,
          relatedId: orderId,
        });
      }
      
      // Notify all other helpers on this order
      notifyOrderHelpers(orderId, "checkin_update", "checked_in");
      
      // Broadcast to admins for real-time admin console updates
      broadcastToAllAdmins("checkin", "created", checkInRecord.id, { 
        orderId, 
        helperId, 
        status: "checked_in" 
      });
      
      res.status(201).json({
        success: true,
        message: "출근 체크가 완료되었습니다",
        checkIn: checkInRecord,
      });
    } catch (err) {
      console.error("Check-in error:", err);
      res.status(500).json({ message: "출근 체크 중 오류가 발생했습니다" });
    }
  });

  // 오늘의 출근 기록 조회 (헬퍼 전용)
  app.get("/api/checkin/today", requireAuth, requireHelper, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      const records = await storage.getCheckInRecordsByHelper(userId, today);
      res.json(records);
    } catch (err) {
      res.status(500).json({ message: "Internal server error" });
    }
  });
  
  // 의뢰인용 QR 코드 API (영구 토큰 사용)
  app.get("/api/checkin/qr-data", requireAuth, async (req, res) => {
    try {
      const userId = (req as any).user?.id;
      const user = await storage.getUser(userId);
      
      if (!user || user.role !== "requester") {
        return res.status(403).json({ message: "의뢰인만 QR 코드를 생성할 수 있습니다" });
      }
      
      // If user doesn't have a checkInToken, generate one
      let checkInToken = user.checkInToken;
      if (!checkInToken) {
        checkInToken = randomBytes(32).toString("hex");
        await storage.updateUser(userId, { checkInToken });
      }
      
      const qrData = {
        type: "hellpme_checkin",
        requesterId: userId,
        requesterName: user.name,
        requesterPhone: user.phoneNumber,
        token: checkInToken,
      };
      
      res.json(qrData);
    } catch (err) {
      console.error("QR data error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 헬퍼가 요청자 개인코드로 출근 체크 (12자리 코드 입력)
  app.post("/api/checkin/by-code", requireAuth, requireHelper, async (req: any, res) => {
    try {
      const helperId = req.user?.id;
      const helperUser = req.helperUser;
      const { requesterCode, latitude, longitude, address } = req.body;
      
      if (!requesterCode || typeof requesterCode !== "string" || requesterCode.length !== 12) {
        return res.status(400).json({ message: "12자리 요청자 코드를 입력해주세요" });
      }
      
      // 요청자 코드로 사용자 찾기
      const normalizedCode = requesterCode.trim().toUpperCase();
      const requester = await storage.getUserByPersonalCode(normalizedCode);
      
      if (!requester) {
        return res.status(404).json({ message: "유효하지 않은 요청자 코드입니다" });
      }
      
      if (requester.role !== "requester") {
        return res.status(400).json({ message: "해당 코드는 요청자 계정이 아닙니다" });
      }
      
      const requesterId = requester.id;
      
      // 헬퍼-요청자 간 활성 배정 확인
      const helperApplications = await storage.getHelperApplications(helperId);
      const requesterOrders = await storage.getOrdersByRequesterId(requesterId);
      const activeOrderIds = new Set(
        requesterOrders
          .filter(o => {
            const s = normalizeOrderStatus(o.status);
            return s === ORDER_STATUS.SCHEDULED || s === ORDER_STATUS.OPEN;
          })
          .map(o => o.id)
      );
      
      const approvedApp = helperApplications.find(
        app => (app.status === "approved" || app.status === "selected") && activeOrderIds.has(app.orderId)
      );
      
      if (!approvedApp) {
        return res.status(403).json({ 
          message: "이 요청자와의 활성 배정이 없습니다. 오더에 지원 후 승인되어야 출근할 수 있습니다." 
        });
      }
      
      // 이미 오늘 이 요청자에게 출근한 기록이 있는지 확인
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const existingRecords = await storage.getCheckInRecordsByHelper(helperId, today);
      const alreadyCheckedIn = existingRecords.some(r => r.requesterId === requesterId);
      
      if (alreadyCheckedIn) {
        return res.status(400).json({ 
          message: "이미 오늘 이 요청자에게 출근 체크를 하셨습니다",
          alreadyCheckedIn: true
        });
      }
      
      // 오더 상태를 "in_progress" (업무중)으로 변경
      let updatedOrder = null;
      const order = await storage.getOrder(approvedApp.orderId);
      // 출근 가능한 상태: scheduled 또는 레거시 상태들
      const checkOrderStatus = normalizeOrderStatus(order.status);
      if (order && (checkOrderStatus === ORDER_STATUS.SCHEDULED || checkOrderStatus === ORDER_STATUS.OPEN)) {
        updatedOrder = await storage.updateOrder(approvedApp.orderId, {
          status: "in_progress",
        });
        
        // 배정 기록에 체크인 시간 기록
        await storage.updateOrderApplication(approvedApp.id, {
          checkedInAt: new Date(),
        });
      }
      
      // 출근 기록 생성
      const checkInRecord = await storage.createCheckInRecord({
        helperId: null,
        requesterId,
        requesterName: requester.name,
        checkInTime: new Date(),
        latitude: latitude || null,
        longitude: longitude || null,
        address: address || null,
        status: "checked_in",
        orderId: approvedApp.orderId,
      });
      
      // 헬퍼 상태를 "근무중"으로 변경
      await storage.updateUser(helperId, { dailyStatus: "working" });
      
      // 알림 생성 - 요청자에게 헬퍼 출근 알림
      await storage.createNotification({
        userId: requesterId,
        type: "order_application",
        title: "헬퍼 출근 완료",
        message: `${helperUser?.name || "헬퍼"}님이 출근 체크를 완료했습니다. 오더가 업무중으로 변경되었습니다.`,
        relatedId: checkInRecord.id,
      });
      
      res.status(201).json({
        success: true,
        message: "출근 체크가 완료되었습니다. 오더가 업무중으로 변경되었습니다.",
        checkIn: checkInRecord,
        requesterName: requester.name,
        orderStatus: updatedOrder?.status || "in_progress",
        orderId: approvedApp.orderId,
      });
    } catch (err) {
      console.error("check-in by-code error:", err);
      res.status(500).json({ message: "출근 체크 중 오류가 발생했습니다" });
    }
  });

  // 요청자가 헬퍼 개인코드로 출근 확인 (12자리 코드 입력 또는 QR 스캔)
  app.post("/api/checkin/verify-helper-code", requireAuth, async (req: any, res) => {
    try {
      const requesterId = req.user?.id;
      const requester = await storage.getUser(requesterId);
      
      if (!requester || requester.role !== "requester") {
        return res.status(403).json({ message: "요청자만 헬퍼 출근을 확인할 수 있습니다" });
      }
      
      const { helperCode } = req.body;
      if (!helperCode || typeof helperCode !== "string" || helperCode.length !== 12) {
        return res.status(400).json({ message: "12자리 헬퍼 코드를 입력해주세요" });
      }
      
      // 헬퍼 코드로 사용자 찾기
      const normalizedCode = helperCode.trim().toUpperCase();
      const helper = await storage.getUserByPersonalCode(normalizedCode);
      
      if (!helper) {
        return res.status(404).json({ message: "유효하지 않은 헬퍼 코드입니다" });
      }
      
      if (helper.role !== "helper") {
        return res.status(400).json({ message: "해당 코드는 헬퍼 계정이 아닙니다" });
      }
      
      // 출근 기록 생성
      const now = new Date();
      const checkInRecord = await storage.createCheckInRecord({
        helperId: helper.id,
        requesterId: requesterId,
        checkInTime: now,
        checkInType: "personal_code",
        location: null,
        verifiedBy: requesterId,
      });
      
      // 알림 전송
      await storage.createNotification({
        userId: helper.id,
        title: "출근 확인",
        message: `${requester.name || "요청자"}님이 출근을 확인했습니다.`,
        type: "checkin",
        referenceId: checkInRecord.id.toString(),
        referenceType: "checkin",
      });
      
      res.json({
        success: true,
        message: "헬퍼 출근이 확인되었습니다",
        helperName: helper.name,
        helperId: helper.id,
        checkInTime: now,
      });
    } catch (err) {
      console.error("verify-helper-code error:", err);
      res.status(500).json({ message: "출근 확인 중 오류가 발생했습니다" });
    }
  });

  // =====================================================
  // Web Push Notification APIs
  // =====================================================
  
  // Get VAPID public key
  app.get("/api/push/vapid-public-key", (_req, res) => {
    const publicKey = process.env.VAPID_PUBLIC_KEY;
    if (!publicKey) {
      return res.status(500).json({ message: "VAPID public key not configured" });
    }
    res.json({ publicKey });
  });
  
  // Subscribe to push notifications
  const pushSubscribeSchema = z.object({
    subscription: z.object({
      endpoint: z.string().url(),
      keys: z.object({
        p256dh: z.string().min(1),
        auth: z.string().min(1),
      }),
    }),
    userAgent: z.string().optional(),
  });
  
  app.post("/api/push/subscribe", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      
      const parseResult = pushSubscribeSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({ 
          message: "잘못된 구독 데이터입니다",
          errors: parseResult.error.errors 
        });
      }
      
      const { subscription, userAgent } = parseResult.data;
      
      // Remove existing subscription for this endpoint
      await storage.deletePushSubscriptionByEndpoint(subscription.endpoint);
      
      // Create new subscription
      const pushSub = await storage.createPushSubscription({
        userId,
        endpoint: subscription.endpoint,
        p256dh: subscription.keys.p256dh,
        auth: subscription.keys.auth,
        userAgent: userAgent || null,
      });
      
      res.status(201).json({ 
        success: true, 
        message: "푸시 알림이 활성화되었습니다",
        subscriptionId: pushSub.id 
      });
    } catch (err) {
      console.error("Push subscribe error:", err);
      res.status(500).json({ message: "푸시 구독 중 오류가 발생했습니다" });
    }
  });
  
  // Unsubscribe from push notifications
  app.post("/api/push/unsubscribe", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      const { endpoint } = req.body;
      
      if (endpoint) {
        await storage.deletePushSubscriptionByEndpoint(endpoint);
      } else {
        await storage.deletePushSubscriptionsByUser(userId);
      }
      
      res.json({ success: true, message: "푸시 알림이 비활성화되었습니다" });
    } catch (err) {
      console.error("Push unsubscribe error:", err);
      res.status(500).json({ message: "푸시 구독 해제 중 오류가 발생했습니다" });
    }
  });
  
  // Check push subscription status
  app.get("/api/push/status", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user?.id;
      const subscriptions = await storage.getPushSubscriptionsByUser(userId);
      
      res.json({ 
        subscribed: subscriptions.length > 0,
        subscriptionCount: subscriptions.length 
      });
    } catch (err) {
      console.error("Push status error:", err);
      res.status(500).json({ message: "푸시 상태 조회 중 오류가 발생했습니다" });
    }
  });

  // Register FCM token for native mobile push notifications
  const fcmRegisterSchema = z.object({
    fcmToken: z.string().min(1),
    platform: z.string().optional().default("native"),
    deviceInfo: z.string().optional(),
  });

  app.post("/api/push/register-fcm", requireAuth, async (req: any, res) => {
    try {
      const userId = req.user?.id;

      const parseResult = fcmRegisterSchema.safeParse(req.body);
      if (!parseResult.success) {
        return res.status(400).json({ 
          message: "잘못된 FCM 토큰 데이터입니다",
          errors: parseResult.error.errors 
        });
      }

      const { fcmToken, platform, deviceInfo } = parseResult.data;

      const token = await storage.createOrUpdateFcmToken({
        userId,
        token: fcmToken,
        platform,
        deviceInfo,
      });

      res.json({ 
        success: true, 
        message: "FCM 토큰이 등록되었습니다",
        tokenId: token.id 
      });
    } catch (err) {
      console.error("FCM register error:", err);
      res.status(500).json({ message: "FCM 토큰 등록 중 오류가 발생했습니다" });
    }
  });

  // Unregister FCM token
  app.post("/api/push/unregister-fcm", requireAuth, async (req: any, res) => {
    try {
      const { fcmToken } = req.body;

      if (fcmToken) {
        await storage.deleteFcmToken(fcmToken);
      } else {
        const userId = req.user?.id;
        await storage.deleteFcmTokensByUser(userId);
      }

      res.json({ success: true, message: "FCM 토큰이 해제되었습니다" });
    } catch (err) {
      console.error("FCM unregister error:", err);
      res.status(500).json({ message: "FCM 토큰 해제 중 오류가 발생했습니다" });
    }
  });
  
  // Admin: Send test push notification
  app.post("/api/admin/push/test", adminAuth, async (req: any, res) => {
    try {
      const { userId, title, body, url } = req.body;
      
      if (!userId) {
        return res.status(400).json({ message: "userId is required" });
      }
      
      const subscriptions = await storage.getPushSubscriptionsByUser(userId);
      
      if (subscriptions.length === 0) {
        return res.status(404).json({ message: "해당 사용자의 푸시 구독이 없습니다" });
      }
      
      const webpush = await import("web-push");
      
      const vapidPublicKey = process.env.VAPID_PUBLIC_KEY;
      const vapidPrivateKey = process.env.VAPID_PRIVATE_KEY;
      
      if (!vapidPublicKey || !vapidPrivateKey) {
        return res.status(500).json({ message: "VAPID keys not configured" });
      }
      
      webpush.setVapidDetails(
        "mailto:admin@hellpme.com",
        vapidPublicKey,
        vapidPrivateKey
      );
      
      const payload = JSON.stringify({
        title: title || "테스트 알림",
        body: body || "이것은 테스트 푸시 알림입니다.",
        url: url || "/",
        tag: "test-" + Date.now(),
      });
      
      let successCount = 0;
      let failCount = 0;
      
      for (const sub of subscriptions) {
        try {
          await webpush.sendNotification(
            {
              endpoint: sub.endpoint,
              keys: { p256dh: sub.p256dh, auth: sub.auth },
            },
            payload
          );
          successCount++;
        } catch (err: any) {
          console.error("Push send error:", err);
          failCount++;
          
          // Remove invalid subscription
          if (err.statusCode === 404 || err.statusCode === 410) {
            await storage.deletePushSubscription(sub.id);
          }
        }
      }
      
      res.json({ 
        success: true, 
        message: `${successCount}개 전송 성공, ${failCount}개 실패` 
      });
    } catch (err) {
      console.error("Test push error:", err);
      res.status(500).json({ message: "테스트 푸시 전송 중 오류가 발생했습니다" });
    }
  });

  // ========================================
  // Data Management APIs (SUPER_ADMIN only)
  // ========================================
  
  // Check if user is super admin
  const requireSuperAdmin = async (req: any, res: any, next: any) => {
    const user = req.adminUser || req.user;
    if (!user) {
      return res.status(401).json({ message: "인증이 필요합니다" });
    }
    
    // Hardcoded super admin emails for production reliability
    const superAdminEmails = ['jshmir7070@gmail.com'];
    if (superAdminEmails.includes(user.email)) {
      return next();
    }
    
    // Check if user has SUPER_ADMIN role by querying database
    const result = await db.execute(sql`
      SELECT r.code FROM staff_role_assignments sra
      JOIN admin_roles r ON r.id = sra.role_id
      WHERE sra.user_id = ${user.id}::text AND r.code = 'SUPER_ADMIN' AND sra.is_active = true
      LIMIT 1
    `);
    
    if (!result.rows || result.rows.length === 0) {
      console.log("SUPER_ADMIN check failed for user:", user.id, user.email);
      return res.status(403).json({ 
        message: `최고관리자 권한이 필요합니다 (${user.email || user.id})`
      });
    }
    next();
  };

  // Get data statistics for management
  app.get("/api/admin/data-management/stats", adminAuth, requireSuperAdmin, async (req, res) => {
    try {
      const stats = await db.execute(sql`
        SELECT 
          (SELECT COUNT(*) FROM users) as users_count,
          (SELECT COUNT(*) FROM help_posts) as posts_count,
          (SELECT COUNT(*) FROM orders) as orders_count,
          (SELECT COUNT(*) FROM settlements) as settlements_count,
          (SELECT COUNT(*) FROM helper_credentials) as helpers_count,
          (SELECT COUNT(*) FROM check_in_records) as checkins_count,
          (SELECT COUNT(*) FROM work_proof_events) as work_proofs_count,
          (SELECT COUNT(*) FROM teams) as teams_count,
          (SELECT COUNT(*) FROM contracts) as contracts_count,
          (SELECT COUNT(*) FROM hq_staff) as staff_count
      `);
      
      res.json(stats.rows[0] || {});
    } catch (err) {
      console.error("Data stats error:", err);
      res.status(500).json({ message: "데이터 통계 조회 실패" });
    }
  });

  // Delete specific data type
  app.delete("/api/admin/data-management/:dataType", adminAuth, requireSuperAdmin, async (req, res) => {
    const { dataType } = req.params;
    const { confirmCode } = req.body;
    
    // Require confirmation code for safety
    if (confirmCode !== "DELETE_CONFIRM") {
      return res.status(400).json({ message: "확인 코드가 올바르지 않습니다" });
    }
    
    try {
      let deletedCount = 0;
      
      switch (dataType) {
        case "orders":
          // Delete related data first
          await db.execute(sql`DELETE FROM work_proof_events`);
          await db.execute(sql`DELETE FROM check_in_records`);
          await db.execute(sql`DELETE FROM settlements`);
          await db.execute(sql`DELETE FROM helper_applications`);
          const ordersResult = await db.execute(sql`DELETE FROM orders`);
          deletedCount = ordersResult.rowCount || 0;
          break;
          
        case "settlements":
          const settlementsResult = await db.execute(sql`DELETE FROM settlements`);
          deletedCount = settlementsResult.rowCount || 0;
          break;
          
        case "posts":
          await db.execute(sql`DELETE FROM orders`);
          await db.execute(sql`DELETE FROM settlements`);
          const postsResult = await db.execute(sql`DELETE FROM help_posts`);
          deletedCount = postsResult.rowCount || 0;
          break;
          
        case "users":
          // Only delete non-admin users
          const usersResult = await db.execute(sql`
            DELETE FROM users 
            WHERE role != 'admin' 
            AND id NOT IN (SELECT user_id FROM hq_staff WHERE user_id IS NOT NULL)
          `);
          deletedCount = usersResult.rowCount || 0;
          break;
          
        case "checkins":
          const checkinsResult = await db.execute(sql`DELETE FROM check_in_records`);
          deletedCount = checkinsResult.rowCount || 0;
          break;
          
        case "work_proofs":
          const workProofsResult = await db.execute(sql`DELETE FROM work_proof_events`);
          deletedCount = workProofsResult.rowCount || 0;
          break;
          
        default:
          return res.status(400).json({ message: "지원하지 않는 데이터 유형입니다" });
      }
      
      // Log the action
      console.log(`[DATA_MANAGEMENT] User ${(req as any).user.id} deleted ${dataType}: ${deletedCount} records`);
      
      res.json({ 
        success: true, 
        message: `${deletedCount}건의 ${dataType} 데이터가 삭제되었습니다` 
      });
    } catch (err) {
      console.error("Data delete error:", err);
      res.status(500).json({ message: "데이터 삭제 중 오류가 발생했습니다" });
    }
  });

  // ========================================
  // Staff Management APIs (SUPER_ADMIN only)
  // ========================================

  // Get all admin roles
  app.get("/api/admin/staff/roles", adminAuth, requireSuperAdmin, async (req, res) => {
    try {
      const result = await db.execute(sql`
        SELECT id, code, name, description FROM admin_roles ORDER BY id
      `);
      res.json(result.rows);
    } catch (err) {
      console.error("Get roles error:", err);
      res.status(500).json({ message: "역할 목록 조회 실패" });
    }
  });

  // Get all staff members
  app.get("/api/admin/staff", adminAuth, requireSuperAdmin, async (req, res) => {
    try {
      const result = await db.execute(sql`
        SELECT u.id, u.email, u.name, u.phone_number as "phoneNumber", u.address, 
               u.admin_status as "adminStatus", u.created_at as "createdAt",
               ar.code as "roleCode", ar.name as "roleName"
        FROM users u
        LEFT JOIN staff_role_assignments sra ON sra.user_id = u.id::text AND sra.is_active = true
        LEFT JOIN admin_roles ar ON ar.id = sra.role_id
        WHERE u.is_hq_staff = true OR u.role = 'admin'
        ORDER BY u.created_at DESC
      `);
      res.json(result.rows);
    } catch (err) {
      console.error("Get staff error:", err);
      res.status(500).json({ message: "직원 목록 조회 실패" });
    }
  });

  // Create new staff member
  app.post("/api/admin/staff", adminAuth, requireSuperAdmin, async (req, res) => {
    const { email, name, phoneNumber, address, password, roleId } = req.body;
    
    if (!email || !name || !password) {
      return res.status(400).json({ message: "이메일, 이름, 비밀번호는 필수입니다" });
    }
    
    try {
      // Check if email already exists
      const existing = await db.execute(sql`SELECT id FROM users WHERE email = ${email}`);
      if (existing.rows && existing.rows.length > 0) {
        return res.status(400).json({ message: "이미 존재하는 이메일입니다" });
      }
      
      // Hash password
      const hashedPassword = await bcrypt.hash(password, 10);
      const userId = crypto.randomUUID();
      const username = email.split("@")[0];
      
      // Create user
      await db.execute(sql`
        INSERT INTO users (id, email, username, name, phone_number, address, password, role, is_hq_staff, admin_status, onboarding_status)
        VALUES (${userId}, ${email}, ${username}, ${name}, ${phoneNumber || null}, ${address || null}, ${hashedPassword}, 'admin', true, 'active', 'approved')
      `);
      
      // Assign role if provided
      if (roleId) {
        await db.execute(sql`
          INSERT INTO staff_role_assignments (user_id, role_id, assigned_by, is_active)
          VALUES (${userId}, ${roleId}, ${(req as any).user.id}, true)
        `);
      }
      
      console.log(`[STAFF] Created new staff: ${email} by ${(req as any).user.id}`);
      
      res.json({ 
        success: true, 
        message: "직원이 등록되었습니다",
        userId 
      });
    } catch (err) {
      console.error("Create staff error:", err);
      res.status(500).json({ message: "직원 등록 중 오류가 발생했습니다" });
    }
  });

  // Update staff role
  app.patch("/api/admin/staff/:userId/role", adminAuth, requireSuperAdmin, async (req, res) => {
    const { userId } = req.params;
    const { roleId } = req.body;
    
    try {
      // Deactivate existing role
      await db.execute(sql`
        UPDATE staff_role_assignments SET is_active = false WHERE user_id = ${userId}
      `);
      
      // Assign new role
      if (roleId) {
        await db.execute(sql`
          INSERT INTO staff_role_assignments (user_id, role_id, assigned_by, is_active)
          VALUES (${userId}, ${roleId}, ${(req as any).user.id}, true)
        `);
      }
      
      res.json({ success: true, message: "역할이 변경되었습니다" });
    } catch (err) {
      console.error("Update role error:", err);
      res.status(500).json({ message: "역할 변경 실패" });
    }
  });

  // Delete staff member (deactivate)
  app.delete("/api/admin/staff/:userId", adminAuth, requireSuperAdmin, async (req, res) => {
    const { userId } = req.params;
    
    try {
      await db.execute(sql`
        UPDATE users SET admin_status = 'inactive' WHERE id = ${userId}
      `);
      await db.execute(sql`
        UPDATE staff_role_assignments SET is_active = false WHERE user_id = ${userId}
      `);
      
      res.json({ success: true, message: "직원이 비활성화되었습니다" });
    } catch (err) {
      console.error("Delete staff error:", err);
      res.status(500).json({ message: "직원 비활성화 실패" });
    }
  });

  // Reset all data (dangerous!)
  app.post("/api/admin/data-management/reset-all", adminAuth, requireSuperAdmin, async (req, res) => {
    const { confirmCode, confirmText } = req.body;
    
    // Double confirmation for safety
    if (confirmCode !== "RESET_ALL_DATA" || confirmText !== "전체 초기화 확인") {
      return res.status(400).json({ message: "확인 정보가 올바르지 않습니다" });
    }
    
    try {
      // Helper to safely delete from table (ignores if table doesn't exist)
      const safeDelete = async (tableName: string) => {
        try {
          await db.execute(sql.raw(`DELETE FROM ${tableName}`));
        } catch (e: any) {
          if (!e.message?.includes('does not exist')) {
            throw e;
          }
        }
      };
      
      // Delete in order (respect foreign key constraints)
      await safeDelete('work_proof_events');
      await safeDelete('check_in_records');
      await safeDelete('settlements');
      await safeDelete('helper_applications');
      await safeDelete('orders');
      await safeDelete('contracts');
      await safeDelete('help_posts');
      await safeDelete('helper_credentials');
      await safeDelete('helper_terms_agreements');
      await safeDelete('push_subscriptions');
      await safeDelete('fcm_tokens');
      
      // Keep admin users and HQ staff
      try {
        await db.execute(sql`
          DELETE FROM users 
          WHERE role != 'admin' 
          AND id NOT IN (SELECT user_id FROM hq_staff WHERE user_id IS NOT NULL)
        `);
      } catch (e: any) {
        // If hq_staff doesn't exist, just delete non-admin users
        if (e.message?.includes('does not exist')) {
          await db.execute(sql`DELETE FROM users WHERE role != 'admin'`);
        } else {
          throw e;
        }
      }
      
      const user = (req as any).adminUser || (req as any).user;
      console.log(`[DATA_MANAGEMENT] User ${user?.id} performed FULL DATA RESET`);
      
      res.json({ 
        success: true, 
        message: "모든 데이터가 초기화되었습니다 (관리자 계정 제외)" 
      });
    } catch (err) {
      console.error("Data reset error:", err);
      res.status(500).json({ message: "전체 초기화 중 오류가 발생했습니다: " + (err as any).message });
    }
  });

  // Auto-hide scheduler: hide completed orders after 24 hours
  const runAutoHideScheduler = async () => {
    try {
      const now = new Date();
      // Use optimized DB query instead of loading all orders
      const ordersToHide = await storage.getOrdersPendingAutoHide();
      
      for (const order of ordersToHide) {
        await storage.updateOrder(order.id, { hiddenAt: now });
        console.log(`[AUTO_HIDE] Order ${order.id} hidden at ${now.toISOString()}`);
      }
      
      if (ordersToHide.length > 0) {
        console.log(`[AUTO_HIDE] Processed ${ordersToHide.length} orders`);
      }
    } catch (err) {
      console.error("[AUTO_HIDE] Scheduler error:", err);
    }
  };
  
  // Run auto-hide scheduler every hour
  setInterval(runAutoHideScheduler, 60 * 60 * 1000);
  // Also run once on startup
  setTimeout(runAutoHideScheduler, 5000);
  console.log("Auto-hide scheduler initialized (runs every hour)");

  // Auto-delete scheduler: delete unmatched orders after scheduled date has passed
  const runAutoDeleteExpiredOrders = async () => {
    try {
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      
      // Get all orders that are still in open/awaiting_deposit status
      const allOrders = await storage.getOrders();
      const expiredOrders = allOrders.filter(order => {
        // Only delete unmatched orders (open, awaiting_deposit - 표준)
        const unmatchedStatuses = [ORDER_STATUS.OPEN, ORDER_STATUS.AWAITING_DEPOSIT];
        const normalizedStatus = normalizeOrderStatus(order.status);
        if (!order.status || !unmatchedStatuses.includes(normalizedStatus as any)) return false;
        
        // Check if scheduled date has passed
        if (!order.scheduledDate) return false;
        
        // Parse Korean date format (e.g., "1월 15일" or "2026-01-15")
        let scheduledDate: Date;
        if (order.scheduledDate.includes("월")) {
          // Korean format: "1월 15일"
          const match = order.scheduledDate.match(/(\d+)월\s*(\d+)일/);
          if (!match) return false;
          const month = parseInt(match[1]) - 1;
          const day = parseInt(match[2]);
          scheduledDate = new Date(now.getFullYear(), month, day);
          // If the date appears to be in the past by more than 6 months, it might be next year
          if (scheduledDate.getTime() > now.getTime() + 180 * 24 * 60 * 60 * 1000) {
            scheduledDate = new Date(now.getFullYear() - 1, month, day);
          }
        } else {
          // ISO format
          scheduledDate = new Date(order.scheduledDate);
        }
        
        const scheduledDateOnly = new Date(scheduledDate.getFullYear(), scheduledDate.getMonth(), scheduledDate.getDate());
        
        return scheduledDateOnly < today;
      });
      
      for (const order of expiredOrders) {
        // Soft delete by setting hiddenAt and status to closed
        await storage.updateOrder(order.id, { 
          status: "closed",
          hiddenAt: now
        });
        console.log(`[AUTO_DELETE] Expired order ${order.id} (scheduledDate: ${order.scheduledDate}) deleted at ${now.toISOString()}`);
      }
      
      if (expiredOrders.length > 0) {
        console.log(`[AUTO_DELETE] Processed ${expiredOrders.length} expired orders`);
      }
    } catch (err) {
      console.error("[AUTO_DELETE] Scheduler error:", err);
    }
  };
  
  // Run auto-delete scheduler every hour
  setInterval(runAutoDeleteExpiredOrders, 60 * 60 * 1000);
  // Also run once on startup (after 10 seconds)
  setTimeout(runAutoDeleteExpiredOrders, 10000);
  console.log("Auto-delete expired orders scheduler initialized (runs every hour)");

  // Auto-cancel unassigned orders scheduler
  // 입차 예정일이 지났는데 헬퍼가 배정되지 않은 오더를 자동 취소하고 환불 처리
  const runAutoUnassignedOrderCancel = async () => {
    try {
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      
      // open 또는 awaiting_deposit 상태에서 헬퍼가 배정되지 않은 오더 조회
      const openOrders = await db.select().from(orders).where(
        and(
          or(eq(orders.status, "open"), eq(orders.status, "awaiting_deposit")),
          isNull(orders.matchedHelperId),
          isNull(orders.hiddenAt),
          sql`true`
        )
      );
      
      // 입차 예정일이 지난 오더 필터링
      const expiredUnassignedOrders = openOrders.filter(order => {
        if (!order.scheduledDate) return false;
        
        let scheduledDate: Date;
        if (order.scheduledDate.includes("월")) {
          const match = order.scheduledDate.match(/(\d+)월\s*(\d+)일/);
          if (!match) return false;
          const month = parseInt(match[1]) - 1;
          const day = parseInt(match[2]);
          scheduledDate = new Date(now.getFullYear(), month, day);
          if (scheduledDate.getTime() > now.getTime() + 180 * 24 * 60 * 60 * 1000) {
            scheduledDate = new Date(now.getFullYear() - 1, month, day);
          }
        } else {
          scheduledDate = new Date(order.scheduledDate);
        }
        
        const scheduledDateOnly = new Date(scheduledDate.getFullYear(), scheduledDate.getMonth(), scheduledDate.getDate());
        return scheduledDateOnly < today;
      });
      
      for (const order of expiredUnassignedOrders) {
        // 오더 취소 처리
        await storage.updateOrder(order.id, { 
          status: "cancelled",
          updatedAt: now
        });
        
        console.log(`[UNASSIGNED_CANCEL] Order ${order.id} cancelled (scheduledDate: ${order.scheduledDate}) - No helper assigned`);
      }
      
      if (expiredUnassignedOrders.length > 0) {
        console.log(`[UNASSIGNED_CANCEL] Cancelled ${expiredUnassignedOrders.length} unassigned orders`);
      }
    } catch (err) {
      console.error("[UNASSIGNED_CANCEL] Scheduler error:", err);
    }
  };
  
  // Run auto-unassigned cancel scheduler every hour
  setInterval(runAutoUnassignedOrderCancel, 60 * 60 * 1000);
  // Also run once on startup (after 15 seconds)
  setTimeout(runAutoUnassignedOrderCancel, 15000);
  console.log("Auto-cancel unassigned orders scheduler initialized (runs every hour)");

  // Monthly settlement email scheduler: sends on 1st of each month
  const runMonthlySettlementEmailScheduler = async () => {
    try {
      const now = new Date();
      const isFirstDay = now.getDate() === 1;
      const isScheduledHour = now.getHours() === 9; // 오전 9시에 발송
      
      if (!isFirstDay || !isScheduledHour) {
        return;
      }
      
      // Get previous month
      const prevMonth = now.getMonth() === 0 ? 12 : now.getMonth();
      const prevYear = now.getMonth() === 0 ? now.getFullYear() - 1 : now.getFullYear();
      
      console.log(`[SETTLEMENT_EMAIL] Starting monthly settlement email for ${prevYear}-${prevMonth}`);
      
      // Get all settlements for previous month
      const allSettlements = await storage.getAllSettlementStatements();
      
      // Group by helperId
      const helperSettlements = new Map<string, typeof allSettlements>();
      for (const settlement of allSettlements) {
        const workDate = settlement.workDate ? new Date(settlement.workDate) : null;
        if (!workDate) continue;
        if (workDate.getFullYear() !== prevYear || (workDate.getMonth() + 1) !== prevMonth) continue;
        
        if (!helperSettlements.has(settlement.helperId)) {
          helperSettlements.set(settlement.helperId, []);
        }
        helperSettlements.get(settlement.helperId)!.push(settlement);
      }
      
      // Get SMTP settings
      const smtpHostSetting = await storage.getSystemSetting("smtp_host");
      const smtpPortSetting = await storage.getSystemSetting("smtp_port");
      const smtpUserSetting = await storage.getSystemSetting("smtp_user");
      const smtpPasswordSetting = await storage.getSystemSetting("smtp_password");
      const smtpFromEmailSetting = await storage.getSystemSetting("smtp_from_email");
      
      const smtpHost = smtpHostSetting?.settingValue;
      const smtpPort = smtpPortSetting?.settingValue || "587";
      const smtpUser = smtpUserSetting?.settingValue;
      const smtpPassword = smtpPasswordSetting?.settingValue;
      const smtpFromEmail = smtpFromEmailSetting?.settingValue;
      
      if (!smtpHost || !smtpUser || !smtpPassword) {
        console.log("[SETTLEMENT_EMAIL] SMTP not configured, skipping auto-send");
        return;
      }
      
      const nodemailer = await import("nodemailer");
      const { generateSettlementEmailHtml } = await import("./templates/settlement-email");
      
      const transporter = nodemailer.createTransport({
        host: smtpHost,
        port: parseInt(smtpPort),
        secure: smtpPort === "465",
        auth: {
          user: smtpUser,
          pass: smtpPassword,
        },
      });
      
      let sentCount = 0;
      let failedCount = 0;
      
      const helperEntries = Array.from(helperSettlements.entries());
      for (const [helperId, settlements] of helperEntries) {
        try {
          const helper = await storage.getUser(helperId);
          if (!helper?.email) {
            console.log(`[SETTLEMENT_EMAIL] No email for helper ${helperId}`);
            failedCount++;
            continue;
          }
          
          // Calculate summary
          const summary = {
            totalDeliveryCount: settlements.reduce((sum, s) => sum + (s.deliveryCount || 0), 0),
            totalReturnCount: settlements.reduce((sum, s) => sum + (s.returnCount || 0), 0),
            totalPickupCount: settlements.reduce((sum, s) => sum + (s.pickupCount || 0), 0),
            totalOtherCount: settlements.reduce((sum, s) => sum + (s.otherCount || 0), 0),
            totalSupplyAmount: settlements.reduce((sum, s) => sum + (s.supplyAmount || 0), 0),
            totalVatAmount: settlements.reduce((sum, s) => sum + (s.vatAmount || 0), 0),
            grandTotalAmount: settlements.reduce((sum, s) => sum + (s.totalAmount || 0), 0),
            totalCommission: settlements.reduce((sum, s) => sum + (s.commissionAmount || 0), 0),
            totalNetAmount: settlements.reduce((sum, s) => sum + (s.netAmount || 0), 0),
            commissionRate: settlements[0]?.commissionRate || 10,
          };
          
          const emailHTML = generateSettlementEmailHtml({
            helperName: helper.name || helperId,
            year: prevYear,
            month: prevMonth,
            settlements: settlements.map((s: any) => {
              const wd = s.workDate ? new Date(s.workDate) : null;
              const formattedDate = wd && !isNaN(wd.getTime()) ? `${wd.getMonth() + 1}/${wd.getDate()}` : "-";
              return {
                workDate: formattedDate,
                orderTitle: s.orderTitle || "작업",
                deliveryCount: s.deliveryCount || 0,
                returnCount: s.returnCount || 0,
                pickupCount: s.pickupCount || 0,
                otherCount: s.otherCount || 0,
                supplyAmount: s.supplyAmount || 0,
                vatAmount: s.vatAmount || 0,
                totalAmount: s.totalAmount || 0,
                commissionAmount: s.commissionAmount || 0,
                netAmount: s.netAmount || 0,
              };
            }),
            summary,
          });
          
          await transporter.sendMail({
            from: smtpFromEmail || smtpUser,
            to: helper.email,
            subject: `[헬프미] ${prevYear}년 ${prevMonth}월 정산서 (1차)`,
            html: emailHTML,
          });
          
          sentCount++;
          console.log(`[SETTLEMENT_EMAIL] Sent to ${helper.email}`);
        } catch (err) {
          console.error(`[SETTLEMENT_EMAIL] Failed for helper ${helperId}:`, err);
          failedCount++;
        }
      }
      
      console.log(`[SETTLEMENT_EMAIL] Completed: ${sentCount} sent, ${failedCount} failed`);
    } catch (err) {
      console.error("[SETTLEMENT_EMAIL] Scheduler error:", err);
    }
  };
  
  // Run monthly settlement email scheduler every hour (checks if it's 1st of month at 9am)
  setInterval(runMonthlySettlementEmailScheduler, 60 * 60 * 1000);
  console.log("Monthly settlement email scheduler initialized");

  // ==================== 운영 핵심 기능 API ====================

  // 지역별 운임 규칙 API
  app.get("/api/admin/settings/region-pricing", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const rules = await db.select().from(regionPricingRules).orderBy(regionPricingRules.priority);
      res.json(rules);
    } catch (err) {
      console.error("Get region pricing rules error:", err);
      res.status(500).json({ message: "Failed to get region pricing rules" });
    }
  });

  app.post("/api/admin/settings/region-pricing", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const actorId = (req as any).adminUser?.id;
      const result = await db.insert(regionPricingRules).values({
        ...req.body,
        createdBy: actorId,
      }).returning();
      res.json(result[0]);
    } catch (err) {
      console.error("Create region pricing rule error:", err);
      res.status(500).json({ message: "Failed to create region pricing rule" });
    }
  });

  app.patch("/api/admin/settings/region-pricing/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const result = await db.update(regionPricingRules)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(regionPricingRules.id, parseInt(req.params.id)))
        .returning();
      res.json(result[0]);
    } catch (err) {
      console.error("Update region pricing rule error:", err);
      res.status(500).json({ message: "Failed to update region pricing rule" });
    }
  });

  app.delete("/api/admin/settings/region-pricing/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await db.delete(regionPricingRules).where(eq(regionPricingRules.id, parseInt(req.params.id)));
      res.json({ success: true });
    } catch (err) {
      console.error("Delete region pricing rule error:", err);
      res.status(500).json({ message: "Failed to delete region pricing rule" });
    }
  });

  // 최소 수입 보장 규칙 API
  app.get("/api/admin/settings/minimum-guarantee", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const rules = await db.select().from(minimumGuaranteeRules).orderBy(minimumGuaranteeRules.createdAt);
      res.json(rules);
    } catch (err) {
      console.error("Get minimum guarantee rules error:", err);
      res.status(500).json({ message: "Failed to get minimum guarantee rules" });
    }
  });

  app.post("/api/admin/settings/minimum-guarantee", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const actorId = (req as any).adminUser?.id;
      const result = await db.insert(minimumGuaranteeRules).values({
        ...req.body,
        createdBy: actorId,
      }).returning();
      res.json(result[0]);
    } catch (err) {
      console.error("Create minimum guarantee rule error:", err);
      res.status(500).json({ message: "Failed to create minimum guarantee rule" });
    }
  });

  app.patch("/api/admin/settings/minimum-guarantee/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const result = await db.update(minimumGuaranteeRules)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(minimumGuaranteeRules.id, parseInt(req.params.id)))
        .returning();
      res.json(result[0]);
    } catch (err) {
      console.error("Update minimum guarantee rule error:", err);
      res.status(500).json({ message: "Failed to update minimum guarantee rule" });
    }
  });

  // 정산 락/언락 API (settlementRecords 사용)
  app.post("/api/admin/settlements/:id/lock", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const settlementId = parseInt(req.params.id);
      const actorId = (req as any).adminUser?.id;
      const { reason } = req.body;
      
      // 현재 정산 조회 (settlementRecords 사용)
      const [settlement] = await db.select().from(settlementRecords).where(eq(settlementRecords.id, settlementId));
      if (!settlement) {
        return res.status(404).json({ message: "Settlement not found" });
      }
      if (settlement.status === "LOCKED") {
        return res.status(400).json({ message: "Settlement is already locked" });
      }
      
      // 락 설정
      const [updated] = await db.update(settlementRecords)
        .set({
          status: "LOCKED",
          updatedAt: new Date(),
        })
        .where(eq(settlementRecords.id, settlementId))
        .returning();
      
      // 감사 로그 기록
      await db.insert(settlementAuditLogs).values({
        settlementId,
        actionType: "locked",
        previousValue: JSON.stringify({ status: settlement.status }),
        newValue: JSON.stringify({ status: "LOCKED" }),
        reason,
        actorId,
        actorRole: (req as any).adminUser?.role || "admin",
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });
      
      res.json(updated);
    } catch (err) {
      console.error("Lock settlement error:", err);
      res.status(500).json({ message: "Failed to lock settlement" });
    }
  });

  app.post("/api/admin/settlements/:id/unlock", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const settlementId = parseInt(req.params.id);
      const actorId = (req as any).adminUser?.id;
      const { reason } = req.body;
      
      const [settlement] = await db.select().from(settlementRecords).where(eq(settlementRecords.id, settlementId));
      if (!settlement) {
        return res.status(404).json({ message: "Settlement not found" });
      }
      if (settlement.status !== "LOCKED") {
        return res.status(400).json({ message: "Settlement is not locked" });
      }
      
      const [updated] = await db.update(settlementRecords)
        .set({
          status: "APPROVED",
          updatedAt: new Date(),
        })
        .where(eq(settlementRecords.id, settlementId))
        .returning();
      
      await db.insert(settlementAuditLogs).values({
        settlementId,
        actionType: "unlocked",
        previousValue: JSON.stringify({ status: "LOCKED" }),
        newValue: JSON.stringify({ status: "APPROVED" }),
        reason,
        actorId,
        actorRole: (req as any).adminUser?.role || "admin",
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });
      
      res.json(updated);
    } catch (err) {
      console.error("Unlock settlement error:", err);
      res.status(500).json({ message: "Failed to unlock settlement" });
    }
  });

  // 정산 금액 수정 API (락 체크 포함) - settlementRecords 사용
  app.patch("/api/admin/settlements/:id/amount", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const settlementId = parseInt(req.params.id);
      const actorId = (req as any).adminUser?.id;
      const { driverPayout, reason } = req.body;
      
      const [settlement] = await db.select().from(settlementRecords).where(eq(settlementRecords.id, settlementId));
      if (!settlement) {
        return res.status(404).json({ message: "Settlement not found" });
      }
      if (settlement.status === "LOCKED" || settlement.status === "CONFIRMED") {
        return res.status(403).json({ message: "Settlement is locked/confirmed and cannot be modified" });
      }
      
      const previousAmount = settlement.driverPayout;
      const [updated] = await db.update(settlementRecords)
        .set({
          driverPayout,
          updatedAt: new Date(),
        })
        .where(eq(settlementRecords.id, settlementId))
        .returning();
      
      await db.insert(settlementAuditLogs).values({
        settlementId,
        actionType: "amount_changed",
        previousValue: JSON.stringify({ driverPayout: previousAmount }),
        newValue: JSON.stringify({ driverPayout }),
        changedFields: JSON.stringify(["driverPayout"]),
        reason,
        actorId,
        actorRole: (req as any).adminUser?.role || "admin",
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });
      
      res.json(updated);
    } catch (err) {
      console.error("Update settlement amount error:", err);
      res.status(500).json({ message: "Failed to update settlement amount" });
    }
  });

  // 정산 감사 로그 조회
  app.get("/api/admin/settlements/:id/audit-logs", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const settlementId = parseInt(req.params.id);
      const logs = await db.select()
        .from(settlementAuditLogs)
        .where(eq(settlementAuditLogs.settlementId, settlementId))
        .orderBy(desc(settlementAuditLogs.createdAt));
      res.json(logs);
    } catch (err) {
      console.error("Get settlement audit logs error:", err);
      res.status(500).json({ message: "Failed to get audit logs" });
    }
  });

  // ============================================
  // Admin 지급 요청/재시도 API (스펙 4-4, 4-6)
  // 스펙: POST /admin/payouts/request, POST /admin/payouts/{payoutId}/retry
  // ============================================

  // 지급 요청 (admin)
  app.post("/api/admin/payouts/request", adminAuth, requirePermission("settlements.pay"), async (req, res) => {
    try {
      const user = (req as any).user || (req as any).adminUser;
      const { settlement_id, payout_account_id } = req.body;

      if (!settlement_id) {
        return res.status(400).json({ 
          error: { code: "INVALID_INPUT", message: "settlement_id는 필수입니다" } 
        });
      }

      // 정산 확인
      const settlement = await storage.getSettlementStatement(Number(settlement_id));
      if (!settlement) {
        return res.status(404).json({ 
          error: { code: "NOT_FOUND", message: "정산을 찾을 수 없습니다" } 
        });
      }

      // READY(confirmed) + locked 상태에서만 지급 요청 가능
      if (settlement.status !== "confirmed") {
        return res.status(400).json({ 
          error: { code: "INVALID_STATUS", message: `정산 상태(${settlement.status})가 READY가 아닙니다` } 
        });
      }

      // 헬퍼 계좌 정보 조회
      const helperBankAccount = await storage.getHelperBankAccount(settlement.helperId);
      if (!helperBankAccount) {
        return res.status(400).json({ 
          error: { code: "NO_BANK_ACCOUNT", message: "헬퍼 계좌 정보가 없습니다" } 
        });
      }

      // 기존 지급 확인
      const existingPayout = await storage.getPayoutBySettlement(Number(settlement_id));
      if (existingPayout && existingPayout.status === "SUCCEEDED") {
        return res.status(400).json({ 
          error: { code: "ALREADY_PAID", message: "이미 지급 완료된 정산입니다" } 
        });
      }

      // 지급 생성
      const payout = await storage.createPayout({
        settlementId: Number(settlement_id),
        helperId: settlement.helperId,
        amount: settlement.netAmount || 0,
        bankName: helperBankAccount.bankName || "",
        accountNumber: helperBankAccount.accountNumber || "",
        accountHolder: helperBankAccount.accountHolder || "",
        status: "REQUESTED",
        requestedAt: new Date(),
      });

      // 지급 이벤트 기록
      await storage.createPayoutEvent({
        payoutId: payout.id,
        previousStatus: null,
        newStatus: "REQUESTED",
        reason: "지급 요청 생성",
        actorId: user.id,
      });

      // 감사 로그 기록
      await logAdminAction({
        userId: user.id,
        action: "payout.request",
        targetType: "payout",
        targetId: String(payout.id),
        reason: `지급 요청: 정산 #${settlement_id}`,
        metadata: { settlement_id, amount: payout.amount },
      });

      res.json({
        payout_id: String(payout.id),
        status: "REQUESTED",
      });
    } catch (err) {
      console.error("Payout request error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 지급 목록 조회 (admin)
  app.get("/api/admin/payouts", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const { status, helper_id, limit } = req.query;
      const parsedLimit = limit ? Math.min(Math.max(parseInt(limit as string) || 100, 1), 500) : 100;

      const payouts = await storage.getAllPayouts({
        status: status as string | undefined,
        helperId: helper_id as string | undefined,
        limit: parsedLimit,
      });

      res.json(payouts.map(p => ({
        payout_id: String(p.id),
        settlement_id: String(p.settlementId),
        helper_id: p.helperId,
        amount: p.amount,
        bank_name: p.bankName,
        account_number: p.accountNumber?.replace(/(\d{4})(\d+)(\d{4})/, "$1****$3"),
        account_holder: p.accountHolder,
        status: p.status,
        requested_at: p.requestedAt,
        sent_at: p.sentAt,
        succeeded_at: p.succeededAt,
        failed_at: p.failedAt,
        failure_message: p.failureMessage,
        retry_count: p.retryCount,
      })));
    } catch (err) {
      console.error("Get payouts error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 지급 재시도 (admin)
  app.post("/api/admin/payouts/:id/retry", adminAuth, requirePermission("settlements.pay"), async (req, res) => {
    try {
      const user = (req as any).user || (req as any).adminUser;
      const id = parseInt(req.params.id);
      const { reason } = req.body;

      const payout = await storage.getPayout(id);
      if (!payout) {
        return res.status(404).json({ 
          error: { code: "NOT_FOUND", message: "지급 기록을 찾을 수 없습니다" } 
        });
      }

      // FAILED 상태에서만 재시도 가능
      if (payout.status !== "FAILED") {
        return res.status(400).json({ 
          error: { code: "INVALID_STATUS", message: `상태(${payout.status})가 FAILED가 아닙니다` } 
        });
      }

      const previousStatus = payout.status;
      const retryCount = (payout.retryCount || 0) + 1;

      // 상태 업데이트
      const updated = await storage.updatePayout(id, {
        status: "REQUESTED",
        requestedAt: new Date(),
        retryCount,
        failedAt: null,
        failureCode: null,
        failureMessage: null,
      });

      // 지급 이벤트 기록
      await storage.createPayoutEvent({
        payoutId: id,
        previousStatus,
        newStatus: "REQUESTED",
        reason: reason || "재시도",
        actorId: user.id,
        metadata: JSON.stringify({ retry_count: retryCount }),
      });

      // 감사 로그 기록
      await logAdminAction({
        userId: user.id,
        action: "payout.retry",
        targetType: "payout",
        targetId: String(id),
        reason: reason || "지급 재시도",
        metadata: { retry_count: retryCount },
      });

      res.json({
        payout_id: String(id),
        status: "REQUESTED",
        retry_count: retryCount,
      });
    } catch (err) {
      console.error("Payout retry error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 지급 상태 업데이트: REQUESTED → SENT (송금 실행됨)
  app.patch("/api/admin/payouts/:id/sent", adminAuth, requirePermission("settlements.pay"), async (req, res) => {
    try {
      const user = (req as any).user || (req as any).adminUser;
      const id = parseInt(req.params.id);

      const payout = await storage.getPayout(id);
      if (!payout) {
        return res.status(404).json({ 
          error: { code: "NOT_FOUND", message: "지급 기록을 찾을 수 없습니다" } 
        });
      }

      if (payout.status !== "REQUESTED") {
        return res.status(400).json({ 
          error: { code: "INVALID_STATUS", message: `상태(${payout.status})가 REQUESTED가 아닙니다` } 
        });
      }

      const updated = await storage.updatePayout(id, {
        status: "SENT",
        sentAt: new Date(),
      });

      await storage.createPayoutEvent({
        payoutId: id,
        previousStatus: "REQUESTED",
        newStatus: "SENT",
        reason: "송금 실행",
        actorId: user.id,
      });

      await logAdminAction({
        userId: user.id,
        action: "payout.sent",
        targetType: "payout",
        targetId: String(id),
        reason: "송금 실행 완료",
      });

      res.json({
        payout_id: String(id),
        status: "SENT",
        sent_at: updated?.sentAt,
      });
    } catch (err) {
      console.error("Payout sent error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 지급 상태 업데이트: SENT → SUCCEEDED (입금 확인됨) - 오더 상태 SETTLEMENT_PAID로 변경
  app.patch("/api/admin/payouts/:id/succeeded", adminAuth, requirePermission("settlements.pay"), async (req, res) => {
    try {
      const user = (req as any).user || (req as any).adminUser;
      const id = parseInt(req.params.id);

      const payout = await storage.getPayout(id);
      if (!payout) {
        return res.status(404).json({ 
          error: { code: "NOT_FOUND", message: "지급 기록을 찾을 수 없습니다" } 
        });
      }

      if (payout.status !== "SENT") {
        return res.status(400).json({ 
          error: { code: "INVALID_STATUS", message: `상태(${payout.status})가 SENT가 아닙니다` } 
        });
      }

      const updated = await storage.updatePayout(id, {
        status: "SUCCEEDED",
        succeededAt: new Date(),
      });

      await storage.createPayoutEvent({
        payoutId: id,
        previousStatus: "SENT",
        newStatus: "SUCCEEDED",
        reason: "입금 확인 완료",
        actorId: user.id,
      });

      // 정산서 조회 및 오더 상태 업데이트 (BALANCE_PAID → SETTLEMENT_PAID)
      const settlement = await storage.getSettlement(payout.settlementId!);
      if (settlement && settlement.orderId) {
        const order = await storage.getOrder(settlement.orderId);
        if (order && order.status === "balance_paid") {
          await storage.updateOrder(settlement.orderId, {
            status: "settlement_paid",
          });

          await storage.createOrderStatusEvent({
            orderId: settlement.orderId,
            previousStatus: "balance_paid",
            newStatus: "settlement_paid",
            reason: "헬퍼 정산 지급 완료",
            changedBy: user.id,
          });

          // 헬퍼에게 알림
          if (settlement.helperId) {
            await storage.createNotification({
              type: "settlement" as any,
              title: "정산금 입금 완료",
              message: `정산금 ${Number(payout.amount).toLocaleString()}원이 입금되었습니다.`,
              data: JSON.stringify({ orderId: settlement.orderId, payoutId: id }),
            });
          }
        }
      }

      await logAdminAction({
        userId: user.id,
        action: "payout.succeeded",
        targetType: "payout",
        targetId: String(id),
        reason: "입금 확인 완료",
        metadata: { orderId: settlement?.orderId },
      });

      res.json({
        payout_id: String(id),
        status: "SUCCEEDED",
        succeeded_at: updated?.succeededAt,
        order_status: "settlement_paid",
      });
    } catch (err) {
      console.error("Payout succeeded error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 지급 상태 업데이트: SENT → FAILED (실패)
  app.patch("/api/admin/payouts/:id/failed", adminAuth, requirePermission("settlements.pay"), async (req, res) => {
    try {
      const user = (req as any).user || (req as any).adminUser;
      const id = parseInt(req.params.id);
      const { failure_code, failure_message } = req.body;

      const payout = await storage.getPayout(id);
      if (!payout) {
        return res.status(404).json({ 
          error: { code: "NOT_FOUND", message: "지급 기록을 찾을 수 없습니다" } 
        });
      }

      if (payout.status !== "SENT" && payout.status !== "REQUESTED") {
        return res.status(400).json({ 
          error: { code: "INVALID_STATUS", message: `현재 상태(${payout.status})에서 실패 처리할 수 없습니다` } 
        });
      }

      const previousStatus = payout.status;
      const updated = await storage.updatePayout(id, {
        status: "FAILED",
        failedAt: new Date(),
        failureCode: failure_code || "UNKNOWN",
        failureMessage: failure_message || "송금 실패",
      });

      await storage.createPayoutEvent({
        payoutId: id,
        previousStatus,
        newStatus: "FAILED",
        reason: failure_message || "송금 실패",
        actorId: user.id,
        metadata: JSON.stringify({ failure_code }),
      });

      await logAdminAction({
        userId: user.id,
        action: "payout.failed",
        targetType: "payout",
        targetId: String(id),
        reason: failure_message || "송금 실패",
        metadata: { failure_code },
      });

      res.json({
        payout_id: String(id),
        status: "FAILED",
        failed_at: updated?.failedAt,
        failure_code,
        failure_message,
      });
    } catch (err) {
      console.error("Payout failed error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // 정산 지급 시도 관리
  app.get("/api/admin/settlements/:id/payout-attempts", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const settlementId = parseInt(req.params.id);
      const attempts = await db.select()
        .from(settlementPayoutAttempts)
        .where(eq(settlementPayoutAttempts.settlementId, settlementId))
        .orderBy(desc(settlementPayoutAttempts.createdAt));
      res.json(attempts);
    } catch (err) {
      console.error("Get payout attempts error:", err);
      res.status(500).json({ message: "Failed to get payout attempts" });
    }
  });

  app.post("/api/admin/settlements/:id/retry-payout", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const settlementId = parseInt(req.params.id);
      const actorId = (req as any).adminUser?.id;
      
      const [settlement] = await db.select().from(settlementStatements).where(eq(settlementStatements.id, settlementId));
      if (!settlement) {
        return res.status(404).json({ message: "Settlement not found" });
      }
      
      // 마지막 시도 조회
      const [lastAttempt] = await db.select()
        .from(settlementPayoutAttempts)
        .where(eq(settlementPayoutAttempts.settlementId, settlementId))
        .orderBy(desc(settlementPayoutAttempts.attemptNumber))
        .limit(1);
      
      const attemptNumber = lastAttempt ? (lastAttempt.attemptNumber || 1) + 1 : 1;
      
      // 헬퍼 계좌 정보 조회
      const [bankAccount] = await db.select()
        .from(helperBankAccounts)
        .where(eq(helperBankAccounts.userId, settlement.helperId));
      
      // 새 지급 시도 기록
      const [attempt] = await db.insert(settlementPayoutAttempts).values({
        settlementId,
        attemptNumber,
        amount: settlement.netAmount || 0,
        bankName: bankAccount?.bankName,
        accountNumber: bankAccount?.accountNumber?.replace(/(\d{4})(\d+)(\d{4})/, "$1****$3"),
        accountHolder: bankAccount?.accountHolder,
        status: "pending",
        processedBy: actorId,
      }).returning();
      
      // TODO: 실제 은행 API 연동 시 여기서 처리
      
      res.json(attempt);
    } catch (err) {
      console.error("Retry payout error:", err);
      res.status(500).json({ message: "Failed to retry payout" });
    }
  });

  // 오더 상태 강제 변경 API
  app.post("/api/admin/orders/:orderId/force-status", adminAuth, requirePermission("orders.edit"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const adminUser = (req as any).adminUser;
      const actorId = adminUser?.id;
      
      // Ensure this is an admin user, not a helper or requester
      if (!actorId || !adminUser) {
        return res.status(401).json({ message: "Admin authentication required" });
      }
      
      const { newStatus, reason, relatedIncidentId, affectedHelperId, forceOverride } = req.body;
      
      if (!newStatus || !reason) {
        return res.status(400).json({ message: "Status and reason are required" });
      }
      
      // Validate the target status is a valid ORDER_STATUS value
      if (!validateOrderStatus(newStatus)) {
        return res.status(400).json({ 
          message: `Invalid status: ${newStatus}. Valid values: ${Object.values(ORDER_STATUS).join(", ")}` 
        });
      }
      
      const [order] = await db.select().from(orders).where(eq(orders.id, orderId));
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      const previousStatus = order.status || "unknown";
      
      // Validate state transition is allowed
      const isValidTransition = canTransitionOrderStatus(previousStatus, newStatus);
      
      if (!isValidTransition) {
        // Check if forceOverride is requested - requires orders.force_override permission
        if (!forceOverride) {
          return res.status(400).json({ 
            message: `Cannot transition from "${previousStatus}" to "${newStatus}". Use forceOverride if you have permission.`
          });
        }
        
        // Verify user has force_override permission via RBAC
        // Fail closed: if RBAC check fails or permissions are empty, deny access
        let hasForceOverridePermission = false;
        try {
          const userPermissions = await storage.getUserPermissions(actorId);
          hasForceOverridePermission = userPermissions.includes("orders.force_override");
        } catch (rbacErr) {
          console.error("[Force-Status] RBAC permission check failed:", rbacErr);
          // Fail closed: deny access if RBAC check fails
        }
        
        if (!hasForceOverridePermission) {
          return res.status(403).json({ 
            message: "forceOverride requires orders.force_override permission (SUPER_ADMIN only)"
          });
        }
      }
      
      // 오더 상태 변경
      const [updated] = await db.update(orders)
        .set({
          status: newStatus,
          updatedAt: new Date(),
        })
        .where(eq(orders.id, orderId))
        .returning();
      
      // Whether force override was actually used to bypass validation
      const wasOverrideUsed = forceOverride && !isValidTransition;
      
      // 강제 변경 로그 기록
      await db.insert(orderForceStatusLogs).values({
        orderId,
        previousStatus,
        newStatus,
        reason,
        actorId,
        actorRole: (req as any).adminUser?.role || "admin",
        forceOverrideUsed: wasOverrideUsed,
        relatedIncidentId,
        affectedHelperId,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });
      
      res.json(updated);
    } catch (err) {
      console.error("Force status change error:", err);
      res.status(500).json({ message: "Failed to force status change" });
    }
  });

  // 오더 상태 강제 변경 이력 조회
  app.get("/api/admin/orders/:orderId/force-status-logs", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const logs = await db.select()
        .from(orderForceStatusLogs)
        .where(eq(orderForceStatusLogs.orderId, orderId))
        .orderBy(desc(orderForceStatusLogs.createdAt));
      res.json(logs);
    } catch (err) {
      console.error("Get force status logs error:", err);
      res.status(500).json({ message: "Failed to get force status logs" });
    }
  });

  // ============================================
  // Admin: 헬퍼 노출 진단 API
  // ============================================

  // 헬퍼 노출 진단 API - 오더가 헬퍼에게 왜 안 보이는지 진단
  app.post("/api/admin/orders/:orderId/diagnose-helper-visibility", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const { helper_user_id, include_filters } = req.body;

      const reasonCodes: string[] = [];
      const actionSuggestions: { reason_code: string; suggestion: string }[] = [];
      const snapshot: Record<string, any> = {};
      
      const addReason = (code: string, suggestion: string) => {
        reasonCodes.push(code);
        actionSuggestions.push({ reason_code: code, suggestion });
      };

      // 1. 오더 조회
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.json({
          order_id: orderId,
          is_visible: false,
          reason_codes: ["ORDER_NOT_FOUND"],
          action_suggestions: [{ reason_code: "ORDER_NOT_FOUND", suggestion: "오더가 존재하지 않습니다. 오더 생성 API/DB 저장 경로를 점검하세요." }],
          snapshot: {},
        });
      }

      snapshot.job_status = order.status;
      snapshot.selected_helper_user_id = order.matchedHelperId || null;
      snapshot.payment_status = order.paymentStatus;

      // 2. 오더 상태 점검 (표준: open만 허용)
      if (order.status !== "open") {
        addReason("JOB_STATUS_NOT_OPEN", `오더 상태가 '${order.status}'입니다. OPEN 상태여야 헬퍼에게 노출됩니다.`);
      }

      // 3. 이미 기사 선택됨
      if (order.matchedHelperId) {
        addReason("ORDER_ALREADY_SELECTED", "이미 기사가 선택되었습니다. 다른 헬퍼에게는 정상적으로 숨김 처리됩니다.");
      }

      // 4. 취소/만료/마감 상태 확인
      if (["closed", "cancelled", "expired"].includes(order.status)) {
        addReason("ORDER_NOT_ACTIVE", `오더가 '${order.status}' 상태입니다. 정상적으로 숨김 처리됩니다.`);
      }

      // 5. 후보 수 확인 (3명 제한)
      try {
        const activeCandidates = await storage.getActiveOrderCandidates(orderId);
        snapshot.active_candidate_count = activeCandidates.length;
        snapshot.candidate_limit = 3;

        if (activeCandidates.length >= 3) {
          addReason("CANDIDATE_LIMIT_REACHED", "후보가 3명 이상 지원했습니다. 더 이상 헬퍼에게 노출되지 않습니다 (정상 동작).");
        }
      } catch (candidateErr) {
        console.error("Candidate count query error:", candidateErr);
        addReason("CANDIDATE_COUNT_QUERY_ERROR", "후보 수 집계 중 오류가 발생했습니다. 쿼리/인덱스를 점검하세요.");
        snapshot.candidate_query_error = true;
      }

      // 6. 계약금 결제 확인
      const depositRequired = order.paymentStatus === "awaiting_deposit" || order.status === "awaiting_deposit";
      snapshot.deposit_required = depositRequired;

      if (depositRequired || order.status === "awaiting_deposit") {
        // 결제 레코드 확인
        const depositPayments = await db.select()
          .from(payments)
          .where(and(
            eq(payments.orderId, orderId),
            eq(payments.paymentType, "deposit")
          ))
          .limit(1);

        if (depositPayments.length === 0) {
          addReason("DEPOSIT_REQUIRED_BUT_MISSING", "계약금이 필수인데 결제 레코드가 없습니다. 결제 생성 로직을 점검하세요.");
          snapshot.deposit_payment_record = null;
        } else {
          const depositPayment = depositPayments[0];
          snapshot.deposit_payment_record = {
            id: depositPayment.id,
            status: depositPayment.status,
            amount: depositPayment.amount,
          };

          // 결제 상태 확인
          if (depositPayment.status !== "captured" && depositPayment.status !== "completed") {
            addReason("DEPOSIT_NOT_CONFIRMED", `계약금 결제 상태가 '${depositPayment.status}'입니다. 결제 확정(captured/completed)이 필요합니다.`);
          }

          // 금액 불일치 확인
          if (order.depositAmount && depositPayment.amount !== order.depositAmount) {
            addReason("PAYMENT_AMOUNT_MISMATCH", `결제 금액(${depositPayment.amount})이 예상 계약금(${order.depositAmount})과 불일치합니다. 위변조 또는 오더 금액 재산정이 필요합니다.`);
            snapshot.payment_amount_mismatch = {
              expected: order.depositAmount,
              actual: depositPayment.amount,
            };
          }
        }
        
        // 웹훅 로그 확인
        const recentWebhooks = await db.select()
          .from(webhookLogs)
          .where(and(
            eq(webhookLogs.relatedEntityType, "order"),
            eq(webhookLogs.relatedEntityId, String(orderId))
          ))
          .orderBy(desc(webhookLogs.createdAt))
          .limit(1);
        
        if (recentWebhooks.length > 0) {
          const lastWebhook = recentWebhooks[0];
          snapshot.webhook_last_status = lastWebhook.status;
          
          if (lastWebhook.status === "failed") {
            addReason("WEBHOOK_FAILED", "웹훅 처리가 실패했습니다. [웹훅 재처리] 버튼을 눌러 재처리하세요.");
          }
        }
      }

      snapshot.deposit_payment_status = order.paymentStatus;

      // 7. 필터 조건 (지역/차량/택배사)
      if (include_filters) {
        snapshot.filters = {
          region_code: order.region || null,
          vehicle_type: order.vehicleType || null,
          carrier_id: order.courierCompany || null,
        };
      }

      // 8. 특정 헬퍼 진단 (helper_user_id가 제공된 경우)
      if (helper_user_id) {
        const helper = await storage.getUser(helper_user_id);
        
        if (!helper) {
          addReason("HELPER_NOT_FOUND", "해당 헬퍼를 찾을 수 없습니다. 계정 정보를 확인하세요.");
        } else {
          const helperContext: Record<string, any> = {
            helper_user_id: helper.id,
            helper_status: helper.status || "active",
            is_filtered_out: false,
            filtered_out_reasons: [] as string[],
          };

          // 헬퍼 계정 상태 확인
          if (helper.status !== "active") {
            addReason("HELPER_NOT_ACTIVE", `헬퍼 계정 상태가 '${helper.status}'입니다. ACTIVE 상태여야 지원 가능합니다.`);
            helperContext.is_filtered_out = true;
            helperContext.filtered_out_reasons.push("HELPER_NOT_ACTIVE");
          }

          // 헬퍼 차량 정보
          const helperVehicle = await storage.getHelperVehicle(helper_user_id);
          if (helperVehicle) {
            helperContext.helper_vehicle_type = helperVehicle.vehicleType;
            
            // 차량 타입 매칭 확인
            if (order.vehicleType && helperVehicle.vehicleType !== order.vehicleType) {
              addReason("VEHICLE_MISMATCH", `헬퍼 차량 타입(${helperVehicle.vehicleType})이 오더 요구 차량(${order.vehicleType})과 일치하지 않습니다.`);
              helperContext.is_filtered_out = true;
              helperContext.filtered_out_reasons.push("VEHICLE_MISMATCH");
            }
          }

          // 헬퍼 서비스 지역 확인
          const helperAreas = await storage.getHelperServiceAreas(helper_user_id);
          if (helperAreas.length > 0) {
            helperContext.helper_region_codes = helperAreas.map(a => a.region);
            
            if (order.region && !helperAreas.some(a => a.region === order.region)) {
              addReason("REGION_MISMATCH", `헬퍼 서비스 지역에 오더 지역(${order.region})이 포함되지 않습니다.`);
              helperContext.is_filtered_out = true;
              helperContext.filtered_out_reasons.push("REGION_MISMATCH");
            }
          }

          // 헬퍼 서류 승인 상태 확인
          const helperLicense = await storage.getHelperLicense(helper_user_id);
          if (helperLicense) {
            helperContext.helper_docs_approved = helperLicense.status === "approved";
            
            if (helperLicense.status !== "approved") {
              addReason("HELPER_DOCS_NOT_APPROVED", `헬퍼 서류가 미승인 상태입니다 (상태: ${helperLicense.status}). 서류 승인이 필요합니다.`);
              helperContext.is_filtered_out = true;
              helperContext.filtered_out_reasons.push("HELPER_DOCS_NOT_APPROVED");
            }
          }

          // 이미 지원했는지 확인
          const existingCandidate = await storage.getOrderCandidate(orderId, helper_user_id);
          if (existingCandidate) {
            addReason("HELPER_ALREADY_APPLIED", `헬퍼가 이미 지원했습니다 (상태: ${existingCandidate.status}). 리스트에는 표시되며 '지원함' 표기됩니다.`);
            helperContext.my_candidate_status = existingCandidate.status;
          }

          snapshot.helper_context = helperContext;
        }
      }

      const isVisible = reasonCodes.length === 0;

      res.json({
        order_id: orderId,
        is_visible: isVisible,
        reason_codes: reasonCodes,
        action_suggestions: actionSuggestions,
        snapshot,
      });
    } catch (err) {
      console.error("Diagnose helper visibility error:", err);
      res.status(500).json({ message: "Failed to diagnose helper visibility" });
    }
  });

  // ============================================
  // Admin: 오더 기준 웹훅 재처리
  // ============================================
  app.post("/api/admin/orders/:orderId/retry-webhook", adminAuth, requirePermission("orders.edit"), async (req, res) => {
    try {
      const user = (req as any).adminUser || (req as any).user;
      const orderId = parseInt(req.params.orderId);
      const { reason } = req.body;

      if (!reason || reason.length < 10) {
        return res.status(400).json({ 
          error: { code: "INVALID_REASON", message: "사유는 최소 10자 이상이어야 합니다" } 
        });
      }

      // 해당 오더의 최신 실패 웹훅 찾기
      const failedWebhooks = await db.select()
        .from(webhookLogs)
        .where(and(
          eq(webhookLogs.relatedEntityType, "order"),
          eq(webhookLogs.relatedEntityId, String(orderId)),
          eq(webhookLogs.status, "failed")
        ))
        .orderBy(desc(webhookLogs.createdAt))
        .limit(1);

      if (failedWebhooks.length === 0) {
        return res.status(404).json({ 
          error: { code: "NO_FAILED_WEBHOOK", message: "재처리할 실패 웹훅이 없습니다" } 
        });
      }

      const webhook = failedWebhooks[0];
      const retryCount = (webhook.retryCount || 0) + 1;

      // 웹훅 재처리 시도
      try {
        await storage.updateWebhookLog(webhook.id, {
          status: "processed",
          processedAt: new Date(),
          retryCount,
        });

        // 결제 웹훅인 경우 오더 상태 업데이트
        if (webhook.eventType?.includes("payment") || webhook.eventType?.includes("deposit")) {
          await storage.updateOrder(orderId, {
            paymentStatus: "deposit_paid",
            status: ORDER_STATUS.OPEN,
          });
        }

        // 감사 로그 기록
        await logAdminAction({
          userId: user.id,
          action: "order_webhook_retry",
          targetType: "order",
          targetId: String(orderId),
          reason,
          metadata: { 
            webhook_id: webhook.id, 
            retry_count: retryCount,
            result: "PROCESSED",
          },
        });

        res.json({
          success: true,
          webhook_log_id: webhook.id,
          status: "PROCESSED",
          retry_count: retryCount,
        });
      } catch (processingError: any) {
        await storage.updateWebhookLog(webhook.id, {
          status: "failed",
          errorMessage: processingError.message || "재처리 중 오류 발생",
          retryCount,
        });

        res.status(500).json({ 
          error: { code: "RETRY_FAILED", message: "웹훅 재처리 실패" } 
        });
      }
    } catch (err) {
      console.error("Order webhook retry error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // ============================================
  // Admin: 새 운영 체계 APIs
  // ============================================

  // 관리자용 후보 목록 조회
  app.get("/api/admin/orders/:orderId/candidates", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const candidates = await storage.getOrderCandidates(orderId);

      const enrichedCandidates = await Promise.all(
        candidates.map(async (c) => {
          const helper = await storage.getUser(c.helperUserId);
          const ratingSummary = await storage.getHelperRatingSummary(c.helperUserId);
          const helperVehicle = await storage.getHelperVehicle(c.helperUserId);

          return {
            ...c,
            helper: helper ? {
              id: helper.id,
              name: helper.name,
              phone: c.status === "selected" ? helper.phoneNumber : null,
              profilePhoto: helper.profilePhoto,
            } : null,
            ratingSummary: ratingSummary ? {
              avgRating: ratingSummary.avgRating,
              totalCompleted: ratingSummary.totalCompleted,
              noShowCount: ratingSummary.noShowCount,
            } : null,
            vehicle: helperVehicle ? {
              type: helperVehicle.vehicleType,
              carModel: helperVehicle.carModel,
            } : null,
          };
        })
      );

      res.json({
        orderId,
        totalCandidates: candidates.length,
        maxCandidates: 3,
        candidates: enrichedCandidates,
      });
    } catch (err) {
      console.error("Admin get candidates error:", err);
      res.status(500).json({ message: "Failed to get candidates" });
    }
  });

  // 관리자용 후보 선택
  app.post("/api/admin/orders/:orderId/candidates/:candidateId/select", adminAuth, requirePermission("orders.manage"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const candidateId = parseInt(req.params.candidateId);
      const actorId = (req as any).adminUser?.id;

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }

      const candidates = await storage.getOrderCandidates(orderId);
      const candidate = candidates.find(c => c.id === candidateId);
      if (!candidate) {
        return res.status(404).json({ message: "Candidate not found" });
      }

      if (candidate.status === "selected") {
        return res.status(400).json({ message: "Already selected" });
      }

      const updatedCandidate = await storage.updateOrderCandidate(candidateId, {
        status: "selected",
        selectedAt: new Date(),
      });

      const helper = await storage.getUser(candidate.helperUserId);

      await storage.createContactShareEvent({
        orderId,
        candidateId,
        helperUserId: candidate.helperUserId,
        requesterUserId: order.requesterId || actorId,
        sharedPhone: helper?.phone || null,
        sharedAt: new Date(),
      });

      await storage.updateOrder(orderId, {
        status: "scheduled",
        helperId: candidate.helperUserId,
      });

      await storage.createOrderStatusEvent({
        orderId,
        previousStatus: "open",
        newStatus: "scheduled",
        reason: "관리자가 헬퍼 선택",
        changedBy: actorId,
      });

      for (const c of candidates) {
        if (c.id !== candidateId && c.status === "applied") {
          await storage.updateOrderCandidate(c.id, {
            status: "rejected",
            rejectedAt: new Date(),
          });
        }
      }

      res.json({
        success: true,
        candidate: updatedCandidate,
        helper: helper ? {
          id: helper.id,
          name: helper.name,
          phone: helper.phoneNumber,
        } : null,
      });
    } catch (err) {
      console.error("Admin select candidate error:", err);
      res.status(500).json({ message: "Failed to select candidate" });
    }
  });

  // 관리자용 마감 보고서 조회
  app.get("/api/admin/orders/:orderId/closure-report", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const report = await storage.getOrderClosureReport(orderId);
      res.json(report || null);
    } catch (err) {
      console.error("Admin get closure report error:", err);
      res.status(500).json({ message: "Failed to get closure report" });
    }
  });

  // 관리자용 마감 보고서 승인 (CLOSING_SUBMITTED → FINAL_AMOUNT_CONFIRMED)
  app.post("/api/admin/orders/:orderId/closure-report/approve", adminAuth, requirePermission("orders.manage"), async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const adminUser = req.user!;
      const { finalAmount, memo } = req.body;

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }

      if (order.status !== "closing_submitted") {
        return res.status(400).json({ 
          message: `마감자료 승인은 closing_submitted 상태에서만 가능합니다 (현재: ${order.status})` 
        });
      }

      // 마감 보고서 조회
      const closureReport = await storage.getOrderClosureReport(orderId);
      if (!closureReport) {
        return res.status(404).json({ message: "마감 보고서를 찾을 수 없습니다" });
      }

      // 마감 보고서 승인 처리
      await db.update(closingReports)
        .set({
          status: "approved",
          reviewedAt: new Date(),
          reviewedBy: adminUser.id,
          calculatedAmount: finalAmount || closureReport.calculatedAmount,
          updatedAt: new Date(),
        })
        .where(eq(closingReports.orderId, orderId));

      // 오더 상태 변경: CLOSING_SUBMITTED → FINAL_AMOUNT_CONFIRMED
      await storage.updateOrder(orderId, {
        status: "final_amount_confirmed",
      });

      // 계약 업데이트: 최종 금액 반영
      const orderContracts = await storage.getOrderContracts(orderId);
      if (orderContracts.length > 0) {
        const contract = orderContracts[0];
        const confirmedFinalAmount = finalAmount || closureReport.calculatedAmount || contract.totalAmount;
        const calculatedBalance = confirmedFinalAmount - (contract.downPaymentAmount || contract.depositAmount);
        
        await db.update(contracts)
          .set({
            finalAmount: confirmedFinalAmount,
            finalAmountConfirmedAt: new Date(),
            calculatedBalanceAmount: calculatedBalance,
          })
          .where(eq(contracts.id, contract.id));
      }

      // 이벤트 로깅
      await db.insert(orderStatusEvents).values({
        orderId,
        fromStatus: "closing_submitted",
        toStatus: "final_amount_confirmed",
        reason: memo || "관리자 마감자료 승인",
        changedBy: adminUser.id,
      });

      res.json({ 
        success: true, 
        message: "마감자료가 승인되었습니다",
        order: { id: orderId, status: "final_amount_confirmed" },
      });
    } catch (err) {
      console.error("Admin approve closure report error:", err);
      res.status(500).json({ message: "마감자료 승인에 실패했습니다" });
    }
  });

  // 관리자용 마감 보고서 반려 (CLOSING_SUBMITTED → IN_PROGRESS)
  app.post("/api/admin/orders/:orderId/closure-report/reject", adminAuth, requirePermission("orders.manage"), async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const adminUser = req.user!;
      const { reason } = req.body;

      if (!reason || reason.trim() === "") {
        return res.status(400).json({ message: "반려 사유를 입력해주세요" });
      }

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }

      if (order.status !== "closing_submitted") {
        return res.status(400).json({ 
          message: `마감자료 반려는 closing_submitted 상태에서만 가능합니다 (현재: ${order.status})` 
        });
      }

      // 마감 보고서 반려 처리
      await db.update(closingReports)
        .set({
          status: "rejected",
          reviewedAt: new Date(),
          reviewedBy: adminUser.id,
          rejectReason: reason,
          updatedAt: new Date(),
        })
        .where(eq(closingReports.orderId, orderId));

      // 오더 상태 변경: CLOSING_SUBMITTED → IN_PROGRESS (재제출 가능하도록)
      await storage.updateOrder(orderId, {
        status: "in_progress",
      });

      // 이벤트 로깅
      await db.insert(orderStatusEvents).values({
        orderId,
        fromStatus: "closing_submitted",
        toStatus: "in_progress",
        reason: `마감자료 반려: ${reason}`,
        changedBy: adminUser.id,
      });

      res.json({ 
        success: true, 
        message: "마감자료가 반려되었습니다",
        order: { id: orderId, status: "in_progress" },
      });
    } catch (err) {
      console.error("Admin reject closure report error:", err);
      res.status(500).json({ message: "마감자료 반려에 실패했습니다" });
    }
  });

  // 관리자용 증빙 목록 조회
  app.get("/api/admin/orders/:orderId/proofs", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const proofs = await storage.getOrderCarrierProofs(orderId);
      res.json(proofs);
    } catch (err) {
      console.error("Admin get proofs error:", err);
      res.status(500).json({ message: "Failed to get proofs" });
    }
  });

  // 관리자용 정산 요약 조회
  app.get("/api/admin/orders/:orderId/settlement-summary", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }

      const pricingSnapshot = await storage.getOrderPricingSnapshot(orderId);
      const costItems = await storage.getOrderCostItems(orderId);
      const balanceInvoice = await storage.getOrderBalanceInvoice(orderId);
      const closureReport = await storage.getOrderClosureReport(orderId);

      const commissionRate = 0.05;
      const baseAmount = pricingSnapshot ? Number(pricingSnapshot.baseAmountKrw) : 0;
      const commissionAmount = Math.round(baseAmount * commissionRate);
      const helperPayout = baseAmount - commissionAmount;

      res.json({
        orderId,
        orderStatus: order.status,
        pricing: pricingSnapshot ? {
          baseAmount: Number(pricingSnapshot.baseAmountKrw),
          additionalCosts: Number(pricingSnapshot.additionalCostsKrw),
          vat: Number(pricingSnapshot.vatKrw),
          totalWithVat: Number(pricingSnapshot.totalWithVatKrw),
          deposit: Number(pricingSnapshot.depositKrw),
          balance: Number(pricingSnapshot.balanceKrw),
        } : null,
        costItems: costItems.map(item => ({
          id: item.id,
          label: item.label,
          amount: Number(item.amount),
        })),
        balanceInvoice: balanceInvoice ? {
          id: balanceInvoice.id,
          amount: Number(balanceInvoice.amount),
          status: balanceInvoice.status,
          issuedAt: balanceInvoice.issuedAt,
          paidAt: balanceInvoice.paidAt,
        } : null,
        closureReport: closureReport ? {
          actualDeliveryCount: closureReport.actualDeliveryCount,
          anomalyFlag: closureReport.anomalyFlag,
          submittedAt: closureReport.submittedAt,
          approvedAt: closureReport.approvedAt,
        } : null,
        helperSettlement: {
          grossAmount: baseAmount,
          commissionRate,
          commissionAmount,
          netPayout: helperPayout,
        },
      });
    } catch (err) {
      console.error("Admin get settlement summary error:", err);
      res.status(500).json({ message: "Failed to get settlement summary" });
    }
  });

  // 관리자용 재정산
  app.post("/api/admin/orders/:orderId/reprice", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const actorId = (req as any).adminUser?.id;

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }

      const costItems = await storage.getOrderCostItems(orderId);
      const costPlusItems = costItems.filter(item => item.type === 'add' || item.type === 'plus');
      const costMinusItems = costItems.filter(item => item.type === 'subtract' || item.type === 'minus');
      const costPlusTotal = costPlusItems.reduce((sum, item) => sum + Number(item.amount || 0), 0);
      const costMinusTotal = costMinusItems.reduce((sum, item) => sum + Number(item.amount || 0), 0);

      const qty = parseInt(String(order.averageQuantity || 0)) || 0;
      const baseSupplyAmount = Number(order.pricePerUnit || 0) * qty + costPlusTotal - costMinusTotal;
      const vatAmount = Math.round(baseSupplyAmount * 0.1);
      const grossAmount = baseSupplyAmount + vatAmount;
      const depositAmount = Math.round(grossAmount * 0.2);
      const balanceAmount = grossAmount - depositAmount;

      const snapshot = await storage.createPricingSnapshot({
        orderId,
        baseSupplyAmount,
        vatAmount,
        grossAmount,
        depositAmount,
        balanceAmount,
        costPlusTotal,
        costMinusTotal,
      });

      res.json({
        success: true,
        snapshot,
        breakdown: {
          baseSupplyAmount,
          costPlusTotal,
          costMinusTotal,
          vatAmount,
          grossAmount,
          depositAmount,
          balanceAmount,
        },
      });
    } catch (err) {
      console.error("Admin reprice error:", err);
      res.status(500).json({ message: "Failed to reprice" });
    }
  });

  // T-11: POST /api/admin/orders/:orderId/settle - 관리자 정산 확정
  app.post("/api/admin/orders/:orderId/settle", adminAuth, requirePermission("settlements.create"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const adminUser = (req as any).adminUser;
      const { commissionRate, deductions, memo } = req.body;

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ error: { code: "NOT_FOUND", message: "오더를 찾을 수 없습니다" } });
      }

      // balance_paid 상태에서만 정산 가능
      if (order.status !== "balance_paid" && order.status !== "final_amount_confirmed") {
        return res.status(400).json({ 
          error: { 
            code: "INVALID_STATUS", 
            message: `현재 상태(${order.status})에서는 정산을 진행할 수 없습니다. 잔금 확인 후 정산이 가능합니다.` 
          } 
        });
      }

      // 계약 조회
      const contracts = await storage.getOrderContracts(orderId);
      const contract = contracts[0];
      if (!contract) {
        return res.status(400).json({ error: { code: "NO_CONTRACT", message: "계약 정보가 없습니다" } });
      }

      // 정산금액 계산
      const finalAmount = contract.finalAmount || contract.totalAmount || 0;
      const rate = commissionRate || 0.03; // 기본 3% 수수료
      const commissionAmount = Math.floor(Number(finalAmount) * rate);
      const deductionAmount = deductions?.reduce((sum: number, d: any) => sum + (d.amount || 0), 0) || 0;
      const helperPayoutAmount = Number(finalAmount) - commissionAmount - deductionAmount;

      // Settlement 생성
      const settlement = await storage.createSettlement({
        orderId,
        helperId: contract.helperId || order.matchedHelperId || "",
        requesterId: order.requesterId || "",
        finalAmount: Number(finalAmount),
        platformFeeAmount: commissionAmount,
        deductionAmount,
        helperPayoutAmount,
        status: "confirmed",
        confirmedAt: new Date(),
        confirmedBy: adminUser?.id,
      });

      // 오더 상태 변경
      await storage.updateOrder(orderId, { status: "settlement_paid" });

      // 계약 상태 업데이트
      await storage.updateContract(contract.id, {
        status: "completed",
      });

      // 오더 상태 이벤트 기록
      await storage.createOrderStatusEvent({
        orderId,
        previousStatus: order.status ?? "balance_paid",
        newStatus: "settlement_paid",
        reason: memo || "관리자 정산 확정",
        triggerType: "settled",
        triggeredBy: adminUser?.id,
      });

      // 감사 로그
      await db.insert(auditLogs).values({
        actorRole: "ADMIN",
        userId: adminUser?.id,
        action: "ORDER_SETTLED",
        orderId,
        targetType: "order",
        targetId: String(orderId),
        reason: memo || "관리자 정산 확정",
        newValue: JSON.stringify({ 
          finalAmount, 
          commissionAmount, 
          deductionAmount, 
          helperPayoutAmount,
          settlementId: settlement.id 
        }),
      });

      // 헬퍼에게 알림
      if (contract.helperId || order.matchedHelperId) {
        await storage.createNotification({
          userId: contract.helperId || order.matchedHelperId || "",
          type: "matching_success",
          title: "정산 완료",
          message: `${order.companyName} 오더의 정산이 완료되었습니다. 지급 예정액: ${helperPayoutAmount.toLocaleString()}원`,
          relatedId: orderId,
        });
      }

      res.json({
        ok: true,
        orderId: order.orderNumber || `O-${orderId}`,
        status: "settlement_paid",
        settlement: {
          id: settlement.id,
          finalAmount: Number(finalAmount),
          commissionAmount,
          deductionAmount,
          helperPayoutAmount,
        },
        message: "정산이 완료되었습니다",
      });
    } catch (err) {
      console.error("Admin settle error:", err);
      res.status(500).json({ error: { code: "INTERNAL_ERROR", message: "정산 처리에 실패했습니다" } });
    }
  });

  // 관리자용 잔여금 청구서 발행
  app.post("/api/admin/orders/:orderId/balance-invoice", adminAuth, requirePermission("settlements.create"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const actorId = (req as any).adminUser?.id;

      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }

      if (!["closed", "settlement_paid"].includes(order.status ?? "")) {
        return res.status(400).json({ message: "Order must be closed to issue balance invoice" });
      }

      const snapshot = await storage.getOrderPricingSnapshot(orderId);
      if (!snapshot) {
        return res.status(400).json({ message: "Please reprice the order first" });
      }

      const existingInvoice = await storage.getOrderBalanceInvoice(orderId);
      if (existingInvoice) {
        return res.status(400).json({ message: "Balance invoice already exists" });
      }

      const invoice = await storage.createBalanceInvoice({
        orderId,
        pricingSnapshotId: snapshot.id,
        balanceAmountKrw: snapshot.balanceKrw,
        status: "pending",
        issuedAt: new Date(),
        issuedBy: actorId,
      });

      res.status(201).json(invoice);
    } catch (err) {
      console.error("Admin create balance invoice error:", err);
      res.status(500).json({ message: "Failed to create balance invoice" });
    }
  });

  // 관리자용 잔여금 결제 확인
  app.patch("/api/admin/orders/:orderId/balance-invoice/paid", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const actorId = (req as any).adminUser?.id;

      const invoice = await storage.getOrderBalanceInvoice(orderId);
      if (!invoice) {
        return res.status(404).json({ message: "Balance invoice not found" });
      }

      if (invoice.status !== "pending") {
        return res.status(400).json({ message: "Invoice already processed" });
      }

      const updated = await storage.updateBalanceInvoice(invoice.id, {
        status: "paid",
        paidAt: new Date(),
      });

      const order = await storage.getOrder(orderId);
      if (order) {
        await storage.updateOrder(orderId, { status: "balance_paid" });
        await storage.createOrderStatusEvent({
          orderId,
          previousStatus: order.status,
          newStatus: "balance_paid",
          reason: "잔여금 결제 완료 (관리자 확인)",
          changedBy: actorId,
        });
      }

      res.json(updated);
    } catch (err) {
      console.error("Admin confirm payment error:", err);
      res.status(500).json({ message: "Failed to confirm payment" });
    }
  });

  // 관리자용 마감 보고서 목록 조회
  // GET /api/admin/closure-reports - 관리자용 마감자료 목록 (closingReports 테이블 사용)
  app.get("/api/admin/closure-reports", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const reports = await db.select({
        id: closingReports.id,
        orderId: closingReports.orderId,
        deliveredCount: closingReports.deliveredCount,
        returnedCount: closingReports.returnedCount,
        extraCostsJson: closingReports.extraCostsJson,
        deliveryHistoryImagesJson: closingReports.deliveryHistoryImagesJson,
        etcImagesJson: closingReports.etcImagesJson,
        memo: closingReports.memo,
        status: closingReports.status,
        calculatedAmount: closingReports.calculatedAmount,
        reviewedAt: closingReports.reviewedAt,
        reviewedBy: closingReports.reviewedBy,
        rejectReason: closingReports.rejectReason,
        createdAt: closingReports.createdAt,
      })
      .from(closingReports)
      .orderBy(desc(closingReports.createdAt))
      .limit(200);

      const enrichedReports = await Promise.all(reports.map(async (report) => {
        const order = await storage.getOrder(report.orderId);
        const helper = await storage.getUser(report.helperId);
        
        const extraCosts = report.extraCostsJson ? JSON.parse(report.extraCostsJson) : [];

        return {
          id: report.id,
          orderId: report.orderId,
          helperName: helper?.name || "알 수 없음",
          deliveredCount: report.deliveredCount,
          returnedCount: report.returnedCount,
          actualDeliveryCount: report.deliveredCount + report.returnedCount,
          extraCosts,
          memo: report.memo,
          status: report.status,
          calculatedAmount: report.calculatedAmount,
          submittedAt: report.createdAt,
          approvedAt: report.reviewedAt,
          confirmedAt: report.reviewedAt,
          confirmedBy: report.reviewedBy,
          rejectionReason: report.rejectReason,
          anomalyFlag: false,
          anomalyDetail: null,
          order: order ? {
            boxCount: order.averageQuantity,
            totalAmount: order.totalAmount,
            requesterName: order.requesterName,
          } : null,
          pricing: {
            baseAmount: report.calculatedAmount || 0,
            additionalCosts: extraCosts.reduce((sum: number, c: any) => sum + (c.amount || c.unitPriceSupply || 0), 0),
            vat: Math.round((report.calculatedAmount || 0) * 0.1),
            totalWithVat: Math.round((report.calculatedAmount || 0) * 1.1),
            deposit: 0,
            balance: 0,
          },
        };
      }));

      res.json(enrichedReports);
    } catch (err) {
      console.error("Admin get closure reports error:", err);
      res.status(500).json({ message: "Failed to get closure reports" });
    }
  });

  // 관리자용 마감 보고서 승인
  // PATCH /api/admin/closure-reports/:reportId/approve - 마감자료 승인 (closingReports 사용)
  app.patch("/api/admin/closure-reports/:reportId/approve", adminAuth, requirePermission("orders.edit"), async (req, res) => {
    try {
      const reportId = parseInt(req.params.reportId);
      const actorId = (req as any).adminUser?.id;

      const [report] = await db.select().from(closingReports).where(eq(closingReports.id, reportId));
      if (!report) {
        return res.status(404).json({ message: "마감자료를 찾을 수 없습니다" });
      }

      if (report.status !== "submitted") {
        return res.status(400).json({ message: "이미 처리된 마감자료입니다" });
      }

      const [updated] = await db.update(closingReports)
        .set({
          status: "approved",
          reviewedAt: new Date(),
          reviewedBy: actorId,
        })
        .where(eq(closingReports.id, reportId))
        .returning();

      // 오더 상태 업데이트
      await storage.updateOrder(report.orderId, { status: "final_amount_confirmed" });

      await storage.createAdminAuditLog({
        adminUserId: actorId,
        action: "closure_report_approved",
        targetType: "closure_report",
        targetId: String(reportId),
        description: `마감보고 승인: 오더#${report.orderId}`,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });

      res.json(updated);
    } catch (err) {
      console.error("Admin approve closure report error:", err);
      res.status(500).json({ message: "마감자료 승인에 실패했습니다" });
    }
  });

  // PATCH /api/admin/closure-reports/:reportId/reject - 마감자료 반려 (closingReports 사용)
  app.patch("/api/admin/closure-reports/:reportId/reject", adminAuth, requirePermission("orders.edit"), async (req, res) => {
    try {
      const reportId = parseInt(req.params.reportId);
      const actorId = (req as any).adminUser?.id;
      const { reason } = req.body;

      if (!reason || reason.trim().length < 5) {
        return res.status(400).json({ message: "반려 사유는 5자 이상 입력해주세요" });
      }

      const [report] = await db.select().from(closingReports).where(eq(closingReports.id, reportId));
      if (!report) {
        return res.status(404).json({ message: "마감자료를 찾을 수 없습니다" });
      }

      if (report.status !== "submitted") {
        return res.status(400).json({ message: "이미 처리된 마감자료입니다" });
      }

      const [updated] = await db.update(closingReports)
        .set({
          status: "rejected",
          reviewedAt: new Date(),
          reviewedBy: actorId,
          rejectReason: reason,
        })
        .where(eq(closingReports.id, reportId))
        .returning();

      await storage.createAdminAuditLog({
        adminUserId: actorId,
        action: "closure_report_rejected",
        targetType: "closure_report",
        targetId: String(reportId),
        description: `마감보고 반려: 오더#${report.orderId}, 사유: ${reason}`,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });

      res.json(updated);
    } catch (err) {
      console.error("Admin reject closure report error:", err);
      res.status(500).json({ message: "Failed to reject closure report" });
    }
  });

  // 관리자용 마감 보고서 배송/반품 수량 업데이트
  app.patch("/api/admin/closure-reports/:reportId/counts", adminAuth, requirePermission("orders.edit"), async (req, res) => {
    try {
      const reportId = parseInt(req.params.reportId);
      const actorId = (req as any).adminUser?.id;
      const { deliveredCount, returnedCount } = req.body;

      if (deliveredCount === undefined && returnedCount === undefined) {
        return res.status(400).json({ message: "배송 또는 반품 수량을 입력해주세요" });
      }

      const [report] = await db.select().from(orderClosureReports).where(eq(orderClosureReports.id, reportId));
      if (!report) {
        return res.status(404).json({ message: "마감 보고서를 찾을 수 없습니다" });
      }

      const updateData: any = {};
      if (deliveredCount !== undefined) {
        updateData.deliveredCount = parseInt(deliveredCount) || 0;
      }
      if (returnedCount !== undefined) {
        updateData.returnedCount = parseInt(returnedCount) || 0;
      }

      const [updated] = await db.update(orderClosureReports)
        .set(updateData)
        .where(eq(orderClosureReports.id, reportId))
        .returning();

      await storage.createAdminAuditLog({
        adminUserId: actorId,
        action: "closure_report_counts_updated",
        targetType: "closure_report",
        targetId: String(reportId),
        description: `마감보고 수량 수정: 오더#${report.orderId}, 배송: ${updateData.deliveredCount ?? report.deliveredCount}, 반품: ${updateData.returnedCount ?? report.returnedCount}`,
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });

      res.json(updated);
    } catch (err) {
      console.error("Admin update closure report counts error:", err);
      res.status(500).json({ message: "수량 업데이트에 실패했습니다" });
    }
  });

  // 수동 배차 API
  app.post("/api/admin/orders/:orderId/manual-dispatch", adminAuth, requirePermission("orders.edit"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const actorId = (req as any).adminUser?.id;
      const { helperId, dispatchType, reason } = req.body;
      
      if (!helperId || !dispatchType || !reason) {
        return res.status(400).json({ message: "Helper ID, dispatch type, and reason are required" });
      }
      
      const [order] = await db.select().from(orders).where(eq(orders.id, orderId));
      if (!order) {
        return res.status(404).json({ message: "Order not found" });
      }
      
      const previousHelperId = order.matchedHelperId;
      
      // 오더 헬퍼 배정
      const [updated] = await db.update(orders)
        .set({
          status: "scheduled",
          matchedAt: new Date(),
          updatedAt: new Date(),
        })
        .where(eq(orders.id, orderId))
        .returning();
      
      // 수동 배차 로그 기록
      await db.insert(manualDispatchLogs).values({
        orderId,
        dispatchType,
        reason,
        previousHelperId,
        actorId,
        actorRole: (req as any).adminUser?.role || "admin",
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
      });
      
      res.json(updated);
    } catch (err) {
      console.error("Manual dispatch error:", err);
      res.status(500).json({ message: "Failed to manual dispatch" });
    }
  });

  // 수동 배차 이력 조회
  app.get("/api/admin/orders/:orderId/dispatch-logs", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const logs = await db.select()
        .from(manualDispatchLogs)
        .where(eq(manualDispatchLogs.orderId, orderId))
        .orderBy(desc(manualDispatchLogs.createdAt));
      res.json(logs);
    } catch (err) {
      console.error("Get dispatch logs error:", err);
      res.status(500).json({ message: "Failed to get dispatch logs" });
    }
  });

  // 증빙 업로드 실패 큐 조회
  app.get("/api/admin/proof-upload-failures", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const failures = await db.select()
        .from(proofUploadFailures)
        .where(eq(proofUploadFailures.status, "pending"))
        .orderBy(desc(proofUploadFailures.createdAt));
      res.json(failures);
    } catch (err) {
      console.error("Get proof upload failures error:", err);
      res.status(500).json({ message: "Failed to get proof upload failures" });
    }
  });

  // VAT 설정 API
  app.get("/api/admin/settings/vat", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const settings = await db.select().from(vatSettings).orderBy(vatSettings.createdAt);
      res.json(settings);
    } catch (err) {
      console.error("Get VAT settings error:", err);
      res.status(500).json({ message: "Failed to get VAT settings" });
    }
  });

  app.post("/api/admin/settings/vat", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const actorId = (req as any).adminUser?.id;
      const result = await db.insert(vatSettings).values({
        ...req.body,
        createdBy: actorId,
      }).returning();
      res.json(result[0]);
    } catch (err) {
      console.error("Create VAT setting error:", err);
      res.status(500).json({ message: "Failed to create VAT setting" });
    }
  });

  app.patch("/api/admin/settings/vat/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const result = await db.update(vatSettings)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(vatSettings.id, parseInt(req.params.id)))
        .returning();
      res.json(result[0]);
    } catch (err) {
      console.error("Update VAT setting error:", err);
      res.status(500).json({ message: "Failed to update VAT setting" });
    }
  });

  // ============================================
  // Wave 2: 추가 운영 API (T-01, T-07, T-08)
  // ============================================

  // T-01: 택배사 최저운임 관리 API
  app.get("/api/admin/carrier-min-rates", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const rates = await db.select()
        .from(carrierMinRates)
        .orderBy(desc(carrierMinRates.createdAt));
      res.json(rates);
    } catch (err) {
      console.error("Get carrier min rates error:", err);
      res.status(500).json({ message: "Failed to get carrier min rates" });
    }
  });

  app.post("/api/admin/carrier-min-rates", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const actorId = (req as any).adminUser?.id;
      const result = await db.insert(carrierMinRates).values({
        ...req.body,
        createdBy: actorId,
      }).returning();
      res.json(result[0]);
    } catch (err) {
      console.error("Create carrier min rate error:", err);
      res.status(500).json({ message: "Failed to create carrier min rate" });
    }
  });

  app.patch("/api/admin/carrier-min-rates/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const actorId = (req as any).adminUser?.id;
      const result = await db.update(carrierMinRates)
        .set({ ...req.body, updatedBy: actorId, updatedAt: new Date() })
        .where(eq(carrierMinRates.id, parseInt(req.params.id)))
        .returning();
      res.json(result[0]);
    } catch (err) {
      console.error("Update carrier min rate error:", err);
      res.status(500).json({ message: "Failed to update carrier min rate" });
    }
  });

  app.delete("/api/admin/carrier-min-rates/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await db.delete(carrierMinRates).where(eq(carrierMinRates.id, parseInt(req.params.id)));
      res.json({ success: true });
    } catch (err) {
      console.error("Delete carrier min rate error:", err);
      res.status(500).json({ message: "Failed to delete carrier min rate" });
    }
  });

  // 표준 운임표 관리 API
  app.get("/api/admin/pricing-tables", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const tables = await db.select()
        .from(pricingTables)
        .orderBy(desc(pricingTables.createdAt));
      res.json(tables);
    } catch (err) {
      console.error("Get pricing tables error:", err);
      res.status(500).json({ message: "Failed to get pricing tables" });
    }
  });

  app.get("/api/admin/pricing-tables/:id", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const [table] = await db.select()
        .from(pricingTables)
        .where(eq(pricingTables.id, parseInt(req.params.id)));
      if (!table) {
        return res.status(404).json({ message: "Pricing table not found" });
      }
      const rows = await db.select()
        .from(pricingTableRows)
        .where(eq(pricingTableRows.tableId, table.id))
        .orderBy(pricingTableRows.sortOrder);
      res.json({ ...table, rows });
    } catch (err) {
      console.error("Get pricing table error:", err);
      res.status(500).json({ message: "Failed to get pricing table" });
    }
  });

  app.post("/api/admin/pricing-tables", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const actorId = (req as any).adminUser?.id;
      const { rows, ...tableData } = req.body;
      const [table] = await db.insert(pricingTables).values({
        ...tableData,
        createdBy: actorId,
      }).returning();
      
      if (rows && rows.length > 0) {
        await db.insert(pricingTableRows).values(
          rows.map((row: any, index: number) => ({ ...row, tableId: table.id, sortOrder: index }))
        );
      }
      res.json(table);
    } catch (err) {
      console.error("Create pricing table error:", err);
      res.status(500).json({ message: "Failed to create pricing table" });
    }
  });

  app.patch("/api/admin/pricing-tables/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const { rows, ...tableData } = req.body;
      const tableId = parseInt(req.params.id);
      
      const [table] = await db.update(pricingTables)
        .set({ ...tableData, updatedAt: new Date() })
        .where(eq(pricingTables.id, tableId))
        .returning();
      
      if (rows) {
        await db.delete(pricingTableRows).where(eq(pricingTableRows.tableId, tableId));
        if (rows.length > 0) {
          await db.insert(pricingTableRows).values(
            rows.map((row: any, index: number) => ({ ...row, tableId, sortOrder: index }))
          );
        }
      }
      res.json(table);
    } catch (err) {
      console.error("Update pricing table error:", err);
      res.status(500).json({ message: "Failed to update pricing table" });
    }
  });

  // 지역별 운임 규칙 관리 API
  app.get("/api/admin/region-pricing-rules", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const rules = await db.select()
        .from(regionPricingRules)
        .orderBy(desc(regionPricingRules.priority), regionPricingRules.regionName);
      res.json(rules);
    } catch (err) {
      console.error("Get region pricing rules error:", err);
      res.status(500).json({ message: "Failed to get region pricing rules" });
    }
  });

  app.post("/api/admin/region-pricing-rules", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const [rule] = await db.insert(regionPricingRules).values({
        ...req.body,
      }).returning();
      res.json(rule);
    } catch (err) {
      console.error("Create region pricing rule error:", err);
      res.status(500).json({ message: "Failed to create region pricing rule" });
    }
  });

  app.patch("/api/admin/region-pricing-rules/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const [rule] = await db.update(regionPricingRules)
        .set({ ...req.body, updatedAt: new Date() })
        .where(eq(regionPricingRules.id, parseInt(req.params.id)))
        .returning();
      res.json(rule);
    } catch (err) {
      console.error("Update region pricing rule error:", err);
      res.status(500).json({ message: "Failed to update region pricing rule" });
    }
  });

  app.delete("/api/admin/region-pricing-rules/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      await db.delete(regionPricingRules).where(eq(regionPricingRules.id, parseInt(req.params.id)));
      res.json({ success: true });
    } catch (err) {
      console.error("Delete region pricing rule error:", err);
      res.status(500).json({ message: "Failed to delete region pricing rule" });
    }
  });

  // T-07: 본인인증 이력 조회 API
  app.get("/api/admin/identity-verifications", adminAuth, requirePermission("users.view"), async (req, res) => {
    try {
      const { status, userId } = req.query;
      let query = db.select().from(identityVerifications);
      
      if (status) {
        query = query.where(eq(identityVerifications.status, status as string)) as any;
      }
      if (userId) {
        query = query.where(eq(identityVerifications.userId, userId as string)) as any;
      }
      
      const verifications = await query.orderBy(desc(identityVerifications.createdAt));
      res.json(verifications);
    } catch (err) {
      console.error("Get identity verifications error:", err);
      res.status(500).json({ message: "Failed to get identity verifications" });
    }
  });

  // T-07: 서류 검토 작업 관리 API
  app.get("/api/admin/document-review-tasks", adminAuth, requirePermission("users.view"), async (req, res) => {
    try {
      const { status, priority, assignedTo } = req.query;
      let query = db.select().from(documentReviewTasks);
      
      if (status) {
        query = query.where(eq(documentReviewTasks.status, status as string)) as any;
      }
      if (priority) {
        query = query.where(eq(documentReviewTasks.priority, priority as string)) as any;
      }
      if (assignedTo) {
        query = query.where(eq(documentReviewTasks.assignedTo, assignedTo as string)) as any;
      }
      
      const tasks = await query.orderBy(desc(documentReviewTasks.createdAt));
      res.json(tasks);
    } catch (err) {
      console.error("Get document review tasks error:", err);
      res.status(500).json({ message: "Failed to get document review tasks" });
    }
  });

  app.patch("/api/admin/document-review-tasks/:id", adminAuth, requirePermission("users.edit"), async (req, res) => {
    try {
      const actorId = (req as any).adminUser?.id;
      const taskId = parseInt(req.params.id);
      const { status, rejectReason, rejectCategory, revisionNote } = req.body;
      
      const updateData: any = { ...req.body, updatedAt: new Date() };
      
      if (status === "approved" || status === "rejected") {
        updateData.reviewedBy = actorId;
        updateData.reviewedAt = new Date();
      }
      if (status === "in_review" && !updateData.assignedTo) {
        updateData.assignedTo = actorId;
        updateData.assignedAt = new Date();
      }
      
      const [task] = await db.update(documentReviewTasks)
        .set(updateData)
        .where(eq(documentReviewTasks.id, taskId))
        .returning();
      
      res.json(task);
    } catch (err) {
      console.error("Update document review task error:", err);
      res.status(500).json({ message: "Failed to update document review task" });
    }
  });

  // 오더 상태 타임라인 API
  app.get("/api/admin/orders/:orderId/status-events", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const events = await db.select()
        .from(orderStatusEvents)
        .where(eq(orderStatusEvents.orderId, orderId))
        .orderBy(desc(orderStatusEvents.createdAt));
      res.json(events);
    } catch (err) {
      console.error("Get order status events error:", err);
      res.status(500).json({ message: "Failed to get order status events" });
    }
  });

  // T-08: SMS 템플릿 관리 API
  app.get("/api/admin/sms-templates", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const templates = await db.select()
        .from(smsTemplates)
        .orderBy(smsTemplates.category, smsTemplates.code);
      res.json(templates);
    } catch (err) {
      console.error("Get SMS templates error:", err);
      res.status(500).json({ message: "Failed to get SMS templates" });
    }
  });

  app.post("/api/admin/sms-templates", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const actorId = (req as any).adminUser?.id;
      const [template] = await db.insert(smsTemplates).values({
        ...req.body,
        createdBy: actorId,
      }).returning();
      res.json(template);
    } catch (err) {
      console.error("Create SMS template error:", err);
      res.status(500).json({ message: "Failed to create SMS template" });
    }
  });

  app.patch("/api/admin/sms-templates/:id", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const actorId = (req as any).adminUser?.id;
      const [template] = await db.update(smsTemplates)
        .set({ ...req.body, updatedBy: actorId, updatedAt: new Date() })
        .where(eq(smsTemplates.id, parseInt(req.params.id)))
        .returning();
      res.json(template);
    } catch (err) {
      console.error("Update SMS template error:", err);
      res.status(500).json({ message: "Failed to update SMS template" });
    }
  });

  // T-08: SMS 발송 로그 조회 API
  app.get("/api/admin/sms-logs", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const { status, phone, limit = "100" } = req.query;
      let query = db.select().from(smsLogs);
      
      if (status) {
        query = query.where(eq(smsLogs.status, status as string)) as any;
      }
      if (phone) {
        query = query.where(eq(smsLogs.recipientPhone, phone as string)) as any;
      }
      
      const logs = await query.orderBy(desc(smsLogs.createdAt)).limit(parseInt(limit as string));
      res.json(logs);
    } catch (err) {
      console.error("Get SMS logs error:", err);
      res.status(500).json({ message: "Failed to get SMS logs" });
    }
  });

  // 웹훅 로그 조회 API

  // 웹훅 재처리 API
  app.post("/api/admin/webhook-logs/:id/retry", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const logId = parseInt(req.params.id);
      const [log] = await db.select().from(webhookLogs).where(eq(webhookLogs.id, logId));
      
      if (!log) {
        return res.status(404).json({ message: "Webhook log not found" });
      }
      
      // 상태 업데이트 (실제 재처리 로직은 별도 구현 필요)
      const [updated] = await db.update(webhookLogs)
        .set({
          status: "processing",
          retryCount: (log.retryCount || 0) + 1,
        })
        .where(eq(webhookLogs.id, logId))
        .returning();
      
      res.json(updated);
    } catch (err) {
      console.error("Retry webhook error:", err);
      res.status(500).json({ message: "Failed to retry webhook" });
    }
  });

  // 연동 상태 조회 API
  app.get("/api/admin/integration-health", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const health = await db.select().from(integrationHealth).orderBy(integrationHealth.serviceName);
      res.json(health);
    } catch (err) {
      console.error("Get integration health error:", err);
      res.status(500).json({ message: "Failed to get integration health" });
    }
  });

  // 시스템 이벤트 로그 조회 API
  app.get("/api/admin/system-events", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const { severity, source, limit = "100" } = req.query;
      let query = db.select().from(systemEvents);
      
      if (severity) {
        query = query.where(eq(systemEvents.severity, severity as string)) as any;
      }
      if (source) {
        query = query.where(eq(systemEvents.source, source as string)) as any;
      }
      
      const events = await query.orderBy(desc(systemEvents.createdAt)).limit(parseInt(limit as string));
      res.json(events);
    } catch (err) {
      console.error("Get system events error:", err);
      res.status(500).json({ message: "Failed to get system events" });
    }
  });

  // 환불 관리 API
  app.get("/api/admin/refunds", adminAuth, requirePermission("payments.view"), async (req, res) => {
    try {
      const { status, limit = "100" } = req.query;
      let query = db.select().from(refunds);
      
      if (status) {
        query = query.where(eq(refunds.status, status as string)) as any;
      }
      
      const refundList = await query.orderBy(desc(refunds.createdAt)).limit(parseInt(limit as string));
      res.json(refundList);
    } catch (err) {
      console.error("Get refunds error:", err);
      res.status(500).json({ message: "Failed to get refunds" });
    }
  });

  app.post("/api/admin/refunds", adminAuth, requirePermission("payments.edit"), async (req, res) => {
    try {
      const actorId = (req as any).adminUser?.id;
      const [refund] = await db.insert(refunds).values({
        ...req.body,
        requestedBy: actorId,
        requestedAt: new Date(),
      }).returning();
      res.json(refund);
    } catch (err) {
      console.error("Create refund error:", err);
      res.status(500).json({ message: "Failed to create refund" });
    }
  });

  app.patch("/api/admin/refunds/:id", adminAuth, requirePermission("payments.edit"), async (req, res) => {
    try {
      const actorId = (req as any).adminUser?.id;
      const refundId = parseInt(req.params.id);
      const { status } = req.body;
      
      const updateData: any = { ...req.body };
      
      if (status === "completed") {
        updateData.approvedBy = actorId;
        updateData.approvedAt = new Date();
        updateData.completedAt = new Date();
      } else if (status === "failed") {
        updateData.failedAt = new Date();
      }
      
      const [refund] = await db.update(refunds)
        .set(updateData)
        .where(eq(refunds.id, refundId))
        .returning();
      
      res.json(refund);
    } catch (err) {
      console.error("Update refund error:", err);
      res.status(500).json({ message: "Failed to update refund" });
    }
  });

  // CS 티켓 에스컬레이션 API
  app.get("/api/admin/ticket-escalations", adminAuth, requirePermission("support.view"), async (req, res) => {
    try {
      const escalations = await db.select()
        .from(supportTicketEscalations)
        .orderBy(desc(supportTicketEscalations.createdAt));
      res.json(escalations);
    } catch (err) {
      console.error("Get ticket escalations error:", err);
      res.status(500).json({ message: "Failed to get ticket escalations" });
    }
  });

  app.post("/api/admin/ticket-escalations", adminAuth, requirePermission("support.edit"), async (req, res) => {
    try {
      const actorId = (req as any).adminUser?.id;
      const [escalation] = await db.insert(supportTicketEscalations).values({
        ...req.body,
        escalatedBy: actorId,
      }).returning();
      res.json(escalation);
    } catch (err) {
      console.error("Create ticket escalation error:", err);
      res.status(500).json({ message: "Failed to create ticket escalation" });
    }
  });

  // ============================================
  // Admin-App Integration APIs (Wave 3)
  // ============================================

  // Documents API (서류 관리)
  app.get("/api/admin/documents", adminAuth, requirePermission("helpers.view"), async (req, res) => {
    try {
      const { userId, status, docType, limit } = req.query;
      
      // Safely parse limit with guard for undefined/invalid values
      const parsedLimit = limit ? parseInt(limit as string, 10) : 100;
      const safeLimit = Number.isNaN(parsedLimit) ? 100 : parsedLimit;
      
      const documents = await storage.getAllDocuments({
        userId: userId as string | undefined,
        status: status as string | undefined,
        docType: docType as string | undefined,
        limit: safeLimit,
      });
      
      res.json(documents);
    } catch (err) {
      console.error("Get documents error:", err);
      res.status(500).json({ message: "서류 목록을 불러오지 못했습니다" });
    }
  });

  app.get("/api/admin/documents/:id", adminAuth, requirePermission("helpers.view"), async (req, res) => {
    try {
      const doc = await storage.getDocument(parseInt(req.params.id));
      if (!doc) {
        return res.status(404).json({ message: "서류를 찾을 수 없습니다" });
      }
      
      const reviews = await storage.getDocumentReviews(doc.id);
      const user = await storage.getUser(doc.userId);
      
      res.json({ ...doc, reviews, user });
    } catch (err) {
      console.error("Get document error:", err);
      res.status(500).json({ message: "서류 정보를 불러오지 못했습니다" });
    }
  });

  // Document review (서류 검토/승인/반려)
  app.post("/api/admin/documents/:id/review", adminAuth, requirePermission("helpers.edit"), async (req, res) => {
    try {
      const docId = parseInt(req.params.id);
      const adminId = (req as any).adminUser?.id;
      const { action, reason } = req.body;
      
      if (!action || !reason) {
        return res.status(400).json({ message: "액션과 사유를 입력해주세요" });
      }
      
      if (!["APPROVE", "REJECT", "REQUEST_MORE"].includes(action)) {
        return res.status(400).json({ message: "유효하지 않은 액션입니다" });
      }
      
      const doc = await storage.getDocument(docId);
      if (!doc) {
        return res.status(404).json({ message: "서류를 찾을 수 없습니다" });
      }
      
      // Create review record
      const review = await storage.createDocumentReview({
        documentId: docId,
        adminId,
        action,
        reason,
      });
      
      // Update document status
      let newStatus: string;
      if (action === "APPROVE") {
        newStatus = "APPROVED";
      } else if (action === "REJECT") {
        newStatus = "REJECTED";
      } else {
        newStatus = "UNDER_REVIEW";
      }
      
      const updatedDoc = await storage.updateDocument(docId, { status: newStatus });
      
      // Log admin action
      await logAdminAction({
        req,
        action: "document.review",
        targetType: "document",
        targetId: docId,
        oldValue: { status: doc.status },
        newValue: { status: newStatus, reason },
      });
      
      res.json({ document: updatedDoc, review });
    } catch (err) {
      console.error("Document review error:", err);
      res.status(500).json({ message: "서류 검토 처리에 실패했습니다" });
    }
  });

  // User sanctions API (사용자 제재)
  app.get("/api/admin/sanctions", adminAuth, requirePermission("staff.view"), async (req, res) => {
    try {
      const sanctions = await storage.getAllUserSanctions();
      const sanctionsWithUsers = await Promise.all(
        sanctions.map(async (s) => {
          const user = await storage.getUser(s.userId);
          return { ...s, user };
        })
      );
      res.json(sanctionsWithUsers);
    } catch (err) {
      console.error("Get sanctions error:", err);
      res.status(500).json({ message: "제재 목록을 불러오지 못했습니다" });
    }
  });

  app.post("/api/admin/sanctions", adminAuth, requirePermission("staff.edit"), async (req, res) => {
    try {
      const adminId = (req as any).adminUser?.id;
      const { userId, sanctionType, reason, startDate, endDate } = req.body;
      
      if (!userId || !sanctionType || !reason) {
        return res.status(400).json({ message: "필수 정보를 입력해주세요" });
      }
      
      const user = await storage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "사용자를 찾을 수 없습니다" });
      }
      
      const sanction = await storage.createUserSanction({
        userId,
        sanctionType,
        reason,
        startDate: startDate || new Date().toISOString().split("T")[0],
        endDate: endDate || null,
        isActive: true,
        createdBy: adminId,
      });
      
      await logAdminAction({
        req,
        action: "sanction.create",
        targetType: "user",
        targetId: userId,
        oldValue: { sanctionType: null },
        newValue: { sanctionType, reason },
      });
      
      res.json(sanction);
    } catch (err) {
      console.error("Create sanction error:", err);
      res.status(500).json({ message: "제재 등록에 실패했습니다" });
    }
  });

  app.patch("/api/admin/sanctions/:id/release", adminAuth, requirePermission("staff.edit"), async (req, res) => {
    try {
      const sanctionId = parseInt(req.params.id);
      const adminId = (req as any).adminUser?.id;
      const { reason } = req.body;
      
      if (!reason) {
        return res.status(400).json({ message: "해제 사유를 입력해주세요" });
      }
      
      const sanction = await storage.getUserSanction(sanctionId);
      if (!sanction) {
        return res.status(404).json({ message: "제재 정보를 찾을 수 없습니다" });
      }
      
      const updated = await storage.updateUserSanction(sanctionId, {
        isActive: false,
        endDate: new Date().toISOString().split("T")[0],
      });
      
      await logAdminAction({
        req,
        action: "sanction.release",
        targetType: "sanction",
        targetId: sanctionId,
        oldValue: { isActive: true },
        newValue: { isActive: false, reason },
      });
      
      res.json(updated);
    } catch (err) {
      console.error("Release sanction error:", err);
      res.status(500).json({ message: "제재 해제에 실패했습니다" });
    }
  });

  // Order reassignment (기사 재배정)
  app.post("/api/admin/orders/:orderId/reassign", adminAuth, requirePermission("orders.edit"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const adminId = (req as any).adminUser?.id;
      const { toHelperId, reason } = req.body;
      
      if (!reason) {
        return res.status(400).json({ message: "재배정 사유를 입력해주세요" });
      }
      
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }
      
      // Get current helper from accepted application
      const applications = await storage.getOrderApplications(orderId);
      const acceptedApp = applications.find(a => a.status === "accepted");
      const fromHelperId = acceptedApp?.helperId || null;
      
      // Validate new helper if provided
      if (toHelperId) {
        const newHelper = await storage.getUser(toHelperId);
        if (!newHelper || newHelper.role !== "helper") {
          return res.status(400).json({ message: "유효한 헬퍼를 선택해주세요" });
        }
      }
      
      // Get previous helper from order
      const previousHelperId = (order as any).matchedHelperId || fromHelperId;
      
      // Create reassignment record
      const reassignment = await storage.createReassignment({
        orderId,
        fromHelperId: previousHelperId,
        toHelperId: toHelperId || null,
        reason,
        createdBy: adminId,
      });
      
      // Update order with new helper and status
      const newOrderStatus = toHelperId ? "scheduled" : "matching";
      await storage.updateOrder(orderId, { 
        status: newOrderStatus,
        matchedHelperId: toHelperId || null,
        matchedAt: toHelperId ? new Date() : null,
      });
      
      // Update applications - cancel accepted one
      if (acceptedApp) {
        await storage.updateOrderApplication(acceptedApp.id, { status: "cancelled" });
      }
      
      // Create order status event
      await storage.createOrderStatusEvent({
        orderId,
        triggerType: "admin",
        triggeredBy: adminId,
        previousStatus: order.status,
        newStatus: newOrderStatus,
        reason: `재배정: ${reason}`,
      });
      
      await logAdminAction({
        req,
        action: "order.reassign",
        targetType: "order",
        targetId: orderId,
        oldValue: { helperId: previousHelperId, status: order.status },
        newValue: { helperId: toHelperId, status: newOrderStatus, reason },
      });
      
      res.json(reassignment);
    } catch (err) {
      console.error("Reassign order error:", err);
      res.status(500).json({ message: "기사 재배정에 실패했습니다" });
    }
  });

  // Webhook logs API (웹훅 로그)
  app.get("/api/admin/webhook-logs", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const { source, status, limit = "100" } = req.query;
      const logs = await storage.getAllWebhookLogs({
        source: source as string,
        status: status as string,
        limit: parseInt(limit as string),
      });
      res.json(logs);
    } catch (err) {
      console.error("Get webhook logs error:", err);
      res.status(500).json({ message: "웹훅 로그를 불러오지 못했습니다" });
    }
  });

  app.post("/api/admin/webhook-logs/:id/retry", adminAuth, requirePermission("settings.edit"), async (req, res) => {
    try {
      const logId = parseInt(req.params.id);
      const adminId = (req as any).adminUser?.id;
      
      const log = await storage.getWebhookLog(logId);
      if (!log) {
        return res.status(404).json({ message: "웹훅 로그를 찾을 수 없습니다" });
      }
      
      if (log.status !== "failed") {
        return res.status(400).json({ message: "실패한 웹훅만 재처리할 수 있습니다" });
      }
      
      // Update status to indicate retry attempt
      const updated = await storage.updateWebhookLog(logId, {
        status: "processing",
        retryCount: (log.retryCount || 0) + 1,
      });
      
      await logAdminAction({
        req,
        action: "webhook.retry",
        targetType: "webhook_log",
        targetId: logId,
        oldValue: { status: log.status },
        newValue: { status: "processing" },
      });
      
      res.json(updated);
    } catch (err) {
      console.error("Retry webhook error:", err);
      res.status(500).json({ message: "웹훅 재처리에 실패했습니다" });
    }
  });

  // Identity verifications API (본인인증 이력)
  app.get("/api/admin/users/:userId/identity-verifications", adminAuth, requirePermission("staff.view"), async (req, res) => {
    try {
      const { userId } = req.params;
      const verifications = await storage.getUserIdentityVerifications(userId);
      res.json(verifications);
    } catch (err) {
      console.error("Get identity verifications error:", err);
      res.status(500).json({ message: "본인인증 이력을 불러오지 못했습니다" });
    }
  });

  // Order status events API (오더 상태 이력)
  app.get("/api/admin/orders/:orderId/status-events", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const events = await storage.getOrderStatusEvents(orderId);
      
      // Enrich with actor info
      const enrichedEvents = await Promise.all(
        events.map(async (e) => {
          const actor = e.triggeredBy ? await storage.getUser(e.triggeredBy) : null;
          return { ...e, actor };
        })
      );
      
      res.json(enrichedEvents);
    } catch (err) {
      console.error("Get order status events error:", err);
      res.status(500).json({ message: "오더 상태 이력을 불러오지 못했습니다" });
    }
  });

  // Reassignment history (재배정 이력)
  app.get("/api/admin/orders/:orderId/reassignments", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const reassignments = await storage.getOrderReassignments(orderId);
      
      const enriched = await Promise.all(
        reassignments.map(async (r) => {
          const fromHelper = r.fromHelperId ? await storage.getUser(r.fromHelperId) : null;
          const toHelper = r.toHelperId ? await storage.getUser(r.toHelperId) : null;
          const createdByUser = await storage.getUser(r.createdBy);
          return { ...r, fromHelper, toHelper, createdByUser };
        })
      );
      
      res.json(enriched);
    } catch (err) {
      console.error("Get reassignments error:", err);
      res.status(500).json({ message: "재배정 이력을 불러오지 못했습니다" });
    }
  });

  // =====================================================
  // 관리자 리뉴얼 API (앱 연동 100%)
  // =====================================================

  // GET /api/admin/closings - 마감 검수함 목록
  app.get("/api/admin/closings", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const status = req.query.status as string || 'pending';
      const startDate = req.query.startDate as string | undefined;
      const endDate = req.query.endDate as string | undefined;
      
      // 간단한 쿼리 - closing_reports만 조회 후 order 정보 별도 조회
      const reports = await db.select().from(closingReports).orderBy(desc(closingReports.createdAt));
      
      const courierSettings = await storage.getAllCourierSettings();
      
      const enriched = await Promise.all(
        reports.map(async (cr) => {
          const order = await storage.getOrder(cr.orderId);
          if (!order) return null;
          
          const helper = await storage.getUser(cr.helperId);
          const requester = order.requesterId ? await storage.getUser(order.requesterId) : null;
          const settlement = await db
            .select()
            .from(settlementRecords)
            .where(eq(settlementRecords.orderId, cr.orderId))
            .limit(1);
          
          // Get category from courier_settings
          const courierSetting = courierSettings.find(c => c.courierName === order.companyName);
          const category = courierSetting?.category || "parcel";
          const categoryBasePrice = courierSetting?.basePricePerBox || 0;
          const categoryEtcPrice = courierSetting?.etcPricePerBox || 0;
          
          let closingStatus = 'pending';
          const os = order.status;
          if (os === 'closing_submitted') closingStatus = 'pending';
          else if (['final_amount_confirmed', 'balance_paid', 'settlement_paid', 'closed'].includes(os || '')) closingStatus = 'approved';
          else if (['open', 'scheduled'].includes(os || '')) closingStatus = 'rejected';
          
          if (status !== 'all') {
            if (status === 'pending' && closingStatus !== 'pending') return null;
            if (status === 'approved' && closingStatus !== 'approved') return null;
            if (status === 'rejected' && closingStatus !== 'rejected') return null;
          }
          
          return {
            id: cr.id,
            orderId: cr.orderId,
            helperName: helper?.nickname || helper?.name || null,
            helperPhone: helper?.phoneNumber || null,
            requesterId: order.requesterId,
            requesterName: requester?.nickname || requester?.name || requester?.companyName || null,
            requesterPhone: requester?.phoneNumber || null,
            category,
            categoryBasePrice,
            deliveredCount: cr.deliveredCount,
            returnedCount: cr.returnedCount,
            etcCount: cr.etcCount || 0,
            deliveryHistoryImages: cr.deliveryHistoryImagesJson ? JSON.parse(cr.deliveryHistoryImagesJson) : [],
            etcImages: cr.etcImagesJson ? JSON.parse(cr.etcImagesJson) : [],
            extraCostsJson: cr.extraCostsJson,
            closingMemo: cr.closingMemo,
            createdAt: cr.createdAt,
            status: closingStatus,
            order: {
              status: order.status,
              courierCompany: order.courierCompany || order.companyName,
              averageQuantity: order.averageQuantity,
              finalPricePerBox: order.finalPricePerBox,
              pricePerUnit: order.pricePerUnit,
            },
            settlement: settlement[0] || null,
          };
        })
      );

      let filtered = enriched.filter(Boolean);

      // Date filtering
      if (startDate || endDate) {
        filtered = filtered.filter((item: any) => {
          if (!item.createdAt) return true;
          const createdDate = item.createdAt instanceof Date ? item.createdAt.toISOString().split("T")[0] : String(item.createdAt).split("T")[0];
          if (startDate && createdDate < startDate) return false;
          if (endDate && createdDate > endDate) return false;
          return true;
        });
      }

      res.json(filtered);
    } catch (err) {
      console.error("Get closings error:", err);
      res.status(500).json({ message: "마감 목록을 불러오지 못했습니다" });
    }
  });

  // POST /api/admin/orders/:orderId/closing/reject - 마감 반려
  app.post("/api/admin/orders/:orderId/closing/reject", adminAuth, requirePermission("orders.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const { reason } = req.body;
      
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      await storage.updateOrder(orderId, { status: 'scheduled' });
      
      if (order.matchedHelperId) {
        await storage.createNotification({
          userId: order.matchedHelperId,
          type: 'closing_rejected',
          title: '마감 반려',
          message: reason || '마감이 반려되었습니다. 다시 제출해주세요.',
          data: { orderId },
        });
      }

      res.json({ success: true, message: '마감이 반려되었습니다' });
    } catch (err) {
      console.error("Reject closing error:", err);
      res.status(500).json({ message: "마감 반려에 실패했습니다" });
    }
  });

  // GET /api/admin/requesters/pending - 승인 대기 요청자 목록
  app.get("/api/admin/requesters/pending", adminAuth, requirePermission("requesters.view"), async (req, res) => {
    try {
      const pendingRequesters = await db
        .select()
        .from(users)
        .where(
          and(
            eq(users.role, 'requester'),
            eq(users.isVerified, false),
            isNull(users.deletedAt)
          )
        )
        .orderBy(desc(users.createdAt));

      res.json(pendingRequesters.map(u => ({
        id: u.id,
        name: u.name,
        email: u.email,
        phone: u.phone,
        companyName: u.companyName,
        createdAt: u.createdAt,
        status: 'pending',
      })));
    } catch (err) {
      console.error("Get pending requesters error:", err);
      res.status(500).json({ message: "대기 요청자 목록을 불러오지 못했습니다" });
    }
  });

  // POST /api/admin/requesters/:id/approve - 요청자 승인
  app.post("/api/admin/requesters/:id/approve", adminAuth, requirePermission("requesters.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const userId = parseInt(req.params.id);
      
      await db.update(users)
        .set({ isVerified: true, verifiedAt: new Date() })
        .where(eq(users.id, userId));

      await storage.createNotification({
        userId,
        type: 'account_approved',
        title: '계정 승인',
        message: '회원가입이 승인되었습니다. 이제 서비스를 이용할 수 있습니다.',
        data: {},
      });

      res.json({ success: true, message: '요청자가 승인되었습니다' });
    } catch (err) {
      console.error("Approve requester error:", err);
      res.status(500).json({ message: "요청자 승인에 실패했습니다" });
    }
  });

  // POST /api/admin/requesters/:id/reject - 요청자 반려
  app.post("/api/admin/requesters/:id/reject", adminAuth, requirePermission("requesters.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const userId = parseInt(req.params.id);
      const { reason } = req.body;
      
      await storage.createNotification({
        userId,
        type: 'account_rejected',
        title: '가입 반려',
        message: reason || '회원가입이 반려되었습니다.',
        data: {},
      });

      await db.update(users)
        .set({ deletedAt: new Date() })
        .where(eq(users.id, userId));

      res.json({ success: true, message: '요청자가 반려되었습니다' });
    } catch (err) {
      console.error("Reject requester error:", err);
      res.status(500).json({ message: "요청자 반려에 실패했습니다" });
    }
  });

  // GET /api/admin/incidents - 사고/차감 목록
  app.get("/api/admin/incidents", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const incidents = await db
        .select({
          id: incidentReports.id,
          orderId: incidentReports.orderId,
          type: incidentReports.incidentType,
          description: incidentReports.description,
          deductionAmount: incidentReports.deductionAmount,
          status: incidentReports.status,
          createdAt: incidentReports.createdAt,
        })
        .from(incidentReports)
        .orderBy(desc(incidentReports.createdAt));

      const enriched = incidents.map(inc => ({
        id: inc.id,
        orderId: inc.orderId,
        incidentType: inc.type || 'damage',
        amount: inc.deductionAmount || 0,
        reason: inc.description || '',
        status: inc.status || 'pending',
        createdAt: inc.createdAt,
      }));

      res.json(enriched);
    } catch (err) {
      console.error("Get incidents error:", err);
      res.status(500).json({ message: "사고 목록을 불러오지 못했습니다" });
    }
  });

  // POST /api/admin/incidents - 사고 등록
  app.post("/api/admin/incidents", adminAuth, requirePermission("orders.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { orderId, type, amount, reason, images, helperResponseHours = 48 } = req.body;
      const adminId = req.user?.id;
      
      // 헬퍼 응답 기한 계산 (기본 48시간)
      const helperResponseDeadline = new Date();
      helperResponseDeadline.setHours(helperResponseDeadline.getHours() + helperResponseHours);
      
      const [incident] = await db.insert(incidentReports).values({
        orderId,
        incidentType: type || 'damage',
        description: reason,
        deductionAmount: amount || 0,
        status: 'pending',
        reportedBy: adminId,
        helperResponseDeadline,
        helperResponseRequired: true,
        adminForceProcessed: false,
      }).returning();

      if (images && images.length > 0) {
        for (const img of images) {
          await db.insert(incidentEvidence).values({
            incidentReportId: incident.id,
            fileUrl: img,
            fileType: 'image',
          });
        }
      }

      res.json({ success: true, incident });
    } catch (err) {
      console.error("Create incident error:", err);
      res.status(500).json({ message: "사고 등록에 실패했습니다" });
    }
  });


  // PATCH /api/admin/incidents/:id - 사고 상태 변경
  app.patch("/api/admin/incidents/:id", adminAuth, requirePermission("orders.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const incidentId = parseInt(req.params.id);
      const { status, deductionAmount, deductionReason, adminReply } = req.body;
      
      const updateData: any = {};
      if (status) updateData.status = status;
      if (deductionAmount !== undefined) updateData.deductionAmount = deductionAmount;
      if (deductionReason !== undefined) updateData.deductionReason = deductionReason;
      if (adminReply !== undefined) updateData.adminReply = adminReply;
      
      await db.update(incidentReports)
        .set(updateData)
        .where(eq(incidentReports.id, incidentId));

      // 액션 이력 추가
      const adminUser = req.user;
      if (adminUser) {
        await storage.createIncidentAction({
          incidentId,
          actionType: status ? 'status_change' : 'update',
          actorId: adminUser.id,
          notes: status ? `상태 변경: ${status}` : (adminReply ? `답변 등록` : '정보 수정'),
        });
      }

      res.json({ success: true });
    } catch (err) {
      console.error("Update incident error:", err);
      res.status(500).json({ message: "사고 상태 변경에 실패했습니다" });
    }
  });

  // GET /api/admin/incidents/:id - 사고 상세 조회
  app.get("/api/admin/incidents/:id", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const incidentId = parseInt(req.params.id);
      
      const [incident] = await db.select().from(incidentReports)
        .where(eq(incidentReports.id, incidentId))
        .limit(1);
      
      if (!incident) {
        return res.status(404).json({ message: "사고를 찾을 수 없습니다" });
      }

      // Get order info with helper name
      let order = null;
      let helperName = null;
      if (incident.orderId) {
        const [orderData] = await db.select({
          id: orders.id,
          campAddress: orders.campAddress,
          deliveryArea: orders.deliveryArea,
          scheduledDate: orders.scheduledDate,
          courierCompany: orders.courierCompany,
          averageQuantity: orders.averageQuantity,
          matchedHelperId: orders.matchedHelperId,
        }).from(orders).where(eq(orders.id, incident.orderId));
        order = orderData;
        
        if (orderData?.matchedHelperId) {
          const [helperData] = await db.select({ name: users.name })
            .from(users)
            .where(eq(users.id, orderData.matchedHelperId));
          helperName = helperData?.name || null;
        }
      }

      // Get helper info
      let helper = null;
      if (incident.helperId) {
        const [helperData] = await db.select({
          id: users.id,
          name: users.name,
          phone: users.phone,
        }).from(users).where(eq(users.id, incident.helperId));
        helper = helperData;
      }

      // Get evidence
      const evidence = await db.select()
        .from(incidentEvidence)
        .where(eq(incidentEvidence.incidentId, incidentId));

      res.json({
        ...incident,
        createdAt: incident.createdAt?.toISOString() || null,
        resolvedAt: incident.resolvedAt?.toISOString() || null,
        helperActionAt: incident.helperActionAt?.toISOString() || null,
        order: order ? { ...order, helperName } : null,
        helper,
        evidence,
      });
    } catch (err) {
      console.error("Get incident detail error:", err);
      res.status(500).json({ message: "사고 상세 조회에 실패했습니다" });
    }
  });

  // GET /api/admin/incidents/:id/actions - 사고 처리 이력 조회
  app.get("/api/admin/incidents/:id/actions", adminAuth, requirePermission("orders.view"), async (req, res) => {
    try {
      const incidentId = parseInt(req.params.id);
      const actions = await storage.getIncidentActions(incidentId);
      
      // 액션에 담당자 정보 추가
      const actionsWithUser = await Promise.all(actions.map(async (action) => {
        if (action.performedBy) {
          const user = await storage.getUser(action.performedBy);
          return { ...action, performerName: user?.name || '알 수 없음' };
        }
        return { ...action, performerName: '시스템' };
      }));

      res.json(actionsWithUser);
    } catch (err) {
      console.error("Get incident actions error:", err);
      res.status(500).json({ message: "처리 이력 조회에 실패했습니다" });
    }
  });

  // POST /api/admin/incidents/:id/actions - 사고 처리 액션/코멘트 추가
  app.post("/api/admin/incidents/:id/actions", adminAuth, requirePermission("orders.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const incidentId = parseInt(req.params.id);
      const { actionType, notes } = req.body;
      const adminUser = req.user;

      if (!notes) {
        return res.status(400).json({ message: "코멘트 내용을 입력해주세요" });
      }

      const action = await storage.createIncidentAction({
        incidentId,
        actionType: actionType || 'comment',
        actorId: adminUser?.id,
        notes,
      });

      res.json({ ...action, performerName: adminUser?.name || '관리자' });
    } catch (err) {
      console.error("Add incident action error:", err);
      res.status(500).json({ message: "코멘트 등록에 실패했습니다" });
    }
  });


  // POST /api/admin/incidents/:id/confirm-deduction - 사고 차감 확정
  app.post("/api/admin/incidents/:id/confirm-deduction", adminAuth, requirePermission("settlements.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const incidentId = parseInt(req.params.id);
      const { 
        deductionAmount, 
        deductionReason, 
        deductionMethod, // helper_deduct, requester_refund, both
        adminMemo 
      } = req.body;
      
      if (!deductionAmount || deductionAmount <= 0) {
        return res.status(400).json({ message: "차감 금액을 입력해주세요" });
      }
      
      if (!deductionMethod || !['helper_deduct', 'requester_refund', 'both'].includes(deductionMethod)) {
        return res.status(400).json({ message: "처리 방식을 선택해주세요" });
      }

      // 사고 조회
      const [incident] = await db.select()
        .from(incidentReports)
        .where(eq(incidentReports.id, incidentId))
        .limit(1);

      if (!incident) {
        return res.status(404).json({ message: "사고를 찾을 수 없습니다" });
      }

      const adminUser = req.user;
      const now = new Date();
      
      // 1. 헬퍼 정산 공제 처리
      let helperDeductionApplied = false;
      if ((deductionMethod === 'helper_deduct' || deductionMethod === 'both') && incident.helperId) {
        // deductions 테이블에 차감 내역 추가
        await db.insert(deductions).values({
          orderId: incident.orderId,
          incidentId: incidentId,
          reasonCategory: "incident",
          targetType: 'helper',
          amount: deductionAmount,
          reason: deductionReason || `화물사고 차감 (사고번호: ${incidentId})`,
          category: 'incident',
          sourceType: 'incident',
          sourceId: incidentId,
          status: 'pending',
          createdBy: adminUser?.id,
        });
        
        // 해당 오더의 정산 레코드가 있으면 차감 반영
        if (incident.orderId) {
          const [settlement] = await db.select()
            .from(settlementRecords)
            .where(eq(settlementRecords.orderId, incident.orderId))
            .limit(1);
          
          if (settlement) {
            const currentDeductions = settlement.damageDeduction || 0;
            await db.update(settlementRecords)
              .set({
                damageDeduction: currentDeductions + deductionAmount,
                updatedAt: now,
              })
              .where(eq(settlementRecords.id, settlement.id));
          }
        }
        
        helperDeductionApplied = true;
        
        // 헬퍼에게 알림
        if (incident.helperId) {
          sendPushToUser(incident.helperId, {
            title: '사고 차감 확정',
            body: `사고 건에 대해 ${deductionAmount.toLocaleString()}원이 차감되었습니다.`,
            data: { type: 'incident_deduction', incidentId },
          });
        }
      }
      
      // 2. 요청자 환불 처리
      let requesterRefundApplied = false;
      if ((deductionMethod === 'requester_refund' || deductionMethod === 'both') && incident.requesterId) {
        // refunds 테이블에 환불 내역 추가
        await db.insert(refunds).values({
          orderId: incident.orderId,
          incidentId: incidentId,
          reasonCategory: "incident",
          requesterId: incident.requesterId,
          amount: deductionAmount,
          reason: deductionReason || `화물사고 환불 (사고번호: ${incidentId})`,
          status: 'pending',
          requestedAt: now,
          createdBy: adminUser?.id,
        });
        
        requesterRefundApplied = true;
        
        // 요청자에게 알림
        if (incident.requesterId) {
          sendPushToUser(incident.requesterId, {
            title: '사고 환불 처리',
            body: `사고 건에 대해 ${deductionAmount.toLocaleString()}원 환불이 진행됩니다.`,
            data: { type: 'incident_refund', incidentId },
          });
        }
      }
      
      // 3. 사고 상태 업데이트
      await db.update(incidentReports)
        .set({
          status: 'resolved',
          deductionAmount,
          deductionReason,
          deductionMethod,
          deductionConfirmedAt: now,
          helperDeductionApplied,
          requesterRefundApplied,
          adminMemo,
          resolvedBy: adminUser?.id,
          resolvedAt: now,
          updatedAt: now,
        })
        .where(eq(incidentReports.id, incidentId));
      
      // 4. 액션 이력 추가
      await storage.createIncidentAction({
        incidentId,
        actionType: 'deduction_confirmed',
        actorId: adminUser?.id,
        notes: `차감 확정: ${deductionAmount.toLocaleString()}원 (${
          deductionMethod === 'helper_deduct' ? '헬퍼 정산 공제' :
          deductionMethod === 'requester_refund' ? '요청자 환불' : '헬퍼 공제 + 요청자 환불'
        })`,
      });

      res.json({ 
        success: true, 
        message: '차감이 확정되었습니다',
        helperDeductionApplied,
        requesterRefundApplied,
      });
    } catch (err) {
      console.error("Confirm incident deduction error:", err);
      res.status(500).json({ message: "차감 확정에 실패했습니다" });
    }
  });
  // POST /api/admin/incidents/:id/force-process - 관리자 강제 처리 (헬퍼 응답 기한 초과)
  app.post("/api/admin/incidents/:id/force-process", adminAuth, requirePermission("orders.manage"), async (req: AuthenticatedRequest, res) => {
    try {
      const incidentId = parseInt(req.params.id);
      const { reason, deductionAmount, deductionMethod, adminMemo } = req.body;
      const adminUser = req.user;
      const now = new Date();
      
      // 사고 조회
      const [incident] = await db.select().from(incidentReports)
        .where(eq(incidentReports.id, incidentId))
        .limit(1);
      
      if (!incident) {
        return res.status(404).json({ message: "사고를 찾을 수 없습니다" });
      }
      
      // 이미 처리된 사고인지 확인
      if (incident.status === 'resolved' || incident.adminForceProcessed) {
        return res.status(400).json({ message: "이미 처리된 사고입니다" });
      }
      
      // 헬퍼 응답 기한 확인 (기한 초과 또는 관리자 권한)
      const isDeadlinePassed = incident.helperResponseDeadline && new Date(incident.helperResponseDeadline) < now;
      const hasHelperResponse = !!incident.helperStatus;
      
      if (!isDeadlinePassed && !hasHelperResponse) {
        // 기한 전이고 헬퍼 응답도 없으면 경고만 (관리자 권한으로 강제 처리 가능)
        console.log(`[ForceProcess] 기한 전 강제 처리: incidentId=${incidentId}, deadline=${incident.helperResponseDeadline}`);
      }
      
      // 차감 금액이 있는 경우 처리
      let helperDeductionApplied = false;
      let requesterRefundApplied = false;
      
      if (deductionAmount && deductionAmount > 0) {
        const method = deductionMethod || 'helper_deduct';
        
        if (method === 'helper_deduct' || method === 'both') {
          // 헬퍼 차감 처리
          if (incident.orderId) {
            await db.insert(deductions).values({
              orderId: incident.orderId,
          incidentId: incidentId,
          reasonCategory: "incident",
              amount: deductionAmount,
              reason: reason || `화물사고 차감 (관리자 강제처리, 사고번호: ${incidentId})`,
              deductionType: 'damage',
              status: 'applied',
              appliedAt: now,
              createdBy: adminUser?.id,
            });
          }
          helperDeductionApplied = true;
          
          if (incident.helperId) {
            sendPushToUser(incident.helperId, {
              title: '사고 처리 알림',
              body: `관리자가 사고 건을 처리했습니다. 차감액: ${deductionAmount.toLocaleString()}원`,
              data: { type: 'incident_force_processed', incidentId },
            });
          }
        }
        
        if (method === 'requester_refund' || method === 'both') {
          // 요청자 환불 처리
          if (incident.orderId) {
            await db.insert(refunds).values({
              orderId: incident.orderId,
          incidentId: incidentId,
          reasonCategory: "incident",
              requesterId: incident.requesterId,
              amount: deductionAmount,
              reason: reason || `화물사고 환불 (관리자 강제처리, 사고번호: ${incidentId})`,
              status: 'pending',
              requestedAt: now,
              createdBy: adminUser?.id,
            });
          }
          requesterRefundApplied = true;
          
          if (incident.requesterId) {
            sendPushToUser(incident.requesterId, {
              title: '사고 환불 처리',
              body: `사고 건에 대해 ${deductionAmount.toLocaleString()}원 환불이 진행됩니다.`,
              data: { type: 'incident_refund', incidentId },
            });
          }
        }
      }
      
      // 사고 상태 업데이트
      await db.update(incidentReports)
        .set({
          status: 'resolved',
          adminForceProcessed: true,
          adminForceProcessedAt: now,
          adminForceProcessedBy: adminUser?.id,
          adminForceProcessedReason: reason,
          deductionAmount: deductionAmount || 0,
          deductionMethod: deductionMethod || null,
          helperDeductionApplied,
          requesterRefundApplied,
          adminMemo,
          resolvedBy: adminUser?.id,
          resolvedAt: now,
          updatedAt: now,
        })
        .where(eq(incidentReports.id, incidentId));
      
      // 액션 이력 추가
      await storage.createIncidentAction({
        incidentId,
        actionType: 'admin_force_processed',
        actorId: adminUser?.id,
        notes: `관리자 강제 처리: ${reason || '헬퍼 응답 없음'}${deductionAmount ? ` (차감: ${deductionAmount.toLocaleString()}원)` : ''}`,
      });

      res.json({ 
        success: true, 
        message: '관리자 강제 처리가 완료되었습니다',
        helperDeductionApplied,
        requesterRefundApplied,
      });
    } catch (err) {
      console.error("Force process incident error:", err);
      res.status(500).json({ message: "강제 처리에 실패했습니다" });
    }
  });

  // PATCH /api/admin/settlements/by-order/:orderId/deduct - 정산에 차감 반영
  app.patch("/api/admin/settlements/by-order/:orderId/deduct", adminAuth, requirePermission("settlements.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      const { amount, reason } = req.body;
      
      const [settlement] = await db
        .select()
        .from(settlementRecords)
        .where(eq(settlementRecords.orderId, orderId))
        .limit(1);

      if (!settlement) {
        return res.status(404).json({ message: "정산 기록을 찾을 수 없습니다" });
      }

      const newDeduction = (settlement.damageDeduction || 0) + amount;
      const newPayout = (settlement.finalTotal || 0) - (settlement.platformFee || 0) - newDeduction;

      await db.update(settlementRecords)
        .set({
          damageDeduction: newDeduction,
          damageReason: reason,
          driverPayout: newPayout,
        })
        .where(eq(settlementRecords.id, settlement.id));

      res.json({ success: true, newDeduction, newPayout });
    } catch (err) {
      console.error("Deduct settlement error:", err);
      res.status(500).json({ message: "차감 반영에 실패했습니다" });
    }
  });

  // GET /api/admin/cs - CS 티켓 목록
  app.get("/api/admin/cs", adminAuth, async (req, res) => {
    try {
      const tickets = await db
        .select()
        .from(customerServiceInquiries)
        .orderBy(desc(customerServiceInquiries.createdAt));

      const enriched = await Promise.all(
        tickets.map(async (t) => {
          const user = await storage.getUser(t.userId);
          return {
            id: t.id,
            orderId: t.orderId,
            userId: t.userId,
            userName: user?.name || '알 수 없음',
            userRole: user?.role || 'unknown',
            type: t.type || 'inquiry',
            subject: t.subject || '',
            message: t.message,
            status: t.status,
            createdAt: t.createdAt,
          };
        })
      );

      res.json(enriched);
    } catch (err) {
      console.error("Get CS tickets error:", err);
      res.status(500).json({ message: "CS 목록을 불러오지 못했습니다" });
    }
  });

  // PATCH /api/admin/cs/:id - CS 티켓 상태 변경
  app.patch("/api/admin/cs/:id", adminAuth, async (req, res) => {
    try {
      const ticketId = parseInt(req.params.id);
      const { status } = req.body;
      
      await db.update(customerServiceInquiries)
        .set({ status })
        .where(eq(customerServiceInquiries.id, ticketId));

      res.json({ success: true });
    } catch (err) {
      console.error("Update CS ticket error:", err);
      res.status(500).json({ message: "CS 상태 변경에 실패했습니다" });
    }
  });

  // GET /api/admin/outstanding - 미수금 목록
  app.get("/api/admin/outstanding", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const outstandingOrders = await db
        .select({
          orderId: orders.id,
          requesterId: orders.requesterId,
          finalTotal: settlementRecords.finalTotal,
          status: orders.status,
          createdAt: orders.createdAt,
        })
        .from(orders)
        .innerJoin(settlementRecords, eq(orders.id, settlementRecords.orderId))
        .where(eq(orders.status, 'final_amount_confirmed'))
        .orderBy(desc(orders.createdAt));

      const enriched = await Promise.all(
        outstandingOrders.map(async (o) => {
          const requester = await storage.getUser(o.requesterId);
          return {
            ...o,
            requesterName: requester?.name,
            companyName: requester?.companyName,
          };
        })
      );

      res.json(enriched);
    } catch (err) {
      console.error("Get outstanding error:", err);
      res.status(500).json({ message: "미수금 목록을 불러오지 못했습니다" });
    }
  });

  // POST /api/admin/outstanding/:orderId/remind - 미수금 알림 발송
  app.post("/api/admin/outstanding/:orderId/remind", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const orderId = parseInt(req.params.orderId);
      
      const order = await storage.getOrder(orderId);
      if (!order) {
        return res.status(404).json({ message: "오더를 찾을 수 없습니다" });
      }

      await storage.createNotification({
        userId: order.requesterId,
        type: 'payment_reminder',
        title: '결제 안내',
        message: '잔금 결제가 필요합니다. 결제를 진행해주세요.',
        data: { orderId },
      });

      res.json({ success: true, message: '알림이 발송되었습니다' });
    } catch (err) {
      console.error("Send reminder error:", err);
      res.status(500).json({ message: "알림 발송에 실패했습니다" });
    }
  });
  // POST /api/admin/settlements/:id/mark-paid - 정산 수동 지급 완료 처리
  // NOTE: 은행 API 연동 전까지 수동 처리. 연동 후 자동화 예정.
  app.post("/api/admin/settlements/:id/mark-paid", adminAuth, requirePermission("settlements.pay"), async (req: AuthenticatedRequest, res) => {
    try {
      const settlementId = parseInt(req.params.id);
      const { paymentMethod, transactionId, paidAmount, notes, confirmManualPayment } = req.body;
      
      // 안전장치: 수동 지급 확인 필수
      if (!confirmManualPayment) {
        return res.status(400).json({ 
          code: "CONFIRMATION_REQUIRED",
          message: "수동 지급 완료를 확인해주세요. confirmManualPayment: true 필요" 
        });
      }
      
      // 기존 정산 레코드 확인
      const [existingSettlement] = await db.select().from(settlementRecords).where(eq(settlementRecords.id, settlementId));
      if (!existingSettlement) {
        return res.status(404).json({ message: "정산 레코드를 찾을 수 없습니다" });
      }
      
      // 이미 지급된 경우 중복 방지
      if (existingSettlement.status === 'paid') {
        return res.status(400).json({ 
          code: "ALREADY_PAID",
          message: "이미 지급 완료된 정산입니다",
          paidAt: existingSettlement.paidAt
        });
      }
      
      // 지급 금액 불일치 경고 (지정된 경우)
      if (paidAmount && existingSettlement.driverPayout && Math.abs(paidAmount - existingSettlement.driverPayout) > 100) {
        console.warn(`[Settlement ${settlementId}] Payment amount mismatch: expected ${existingSettlement.driverPayout}, got ${paidAmount}`);
      }
      
      await db.update(settlementRecords)
        .set({ 
          status: 'paid', 
          paidAt: new Date()
        })
        .where(eq(settlementRecords.id, settlementId));

      if (existingSettlement.orderId) {
        await storage.updateOrder(existingSettlement.orderId, { status: 'settlement_paid' });
      }
      
      // 감사 로그
      console.log(`[Settlement] Manual payment marked: ID=${settlementId}, Admin=${req.user?.id}, Method=${paymentMethod || 'unspecified'}, TxId=${transactionId || 'none'}`);

      res.json({ 
        success: true,
        settlementId,
        message: "지급 완료 처리되었습니다. 은행 API 연동 전 수동 처리입니다."
      });
    } catch (err) {
      console.error("Mark paid error:", err);
      res.status(500).json({ message: "지급 완료 처리에 실패했습니다" });
    }
  });

  // GET /api/admin/helpers/:helperId/card - 헬퍼 카드 상세
  app.get("/api/admin/helpers/:helperId/card", adminAuth, requirePermission("helpers.view"), async (req, res) => {
    try {
      const helperId = parseInt(req.params.helperId);
      const helper = await storage.getUser(helperId);
      
      if (!helper) {
        return res.status(404).json({ message: "헬퍼를 찾을 수 없습니다" });
      }

      // 누적 통계
      const completedOrders = await db
        .select()
        .from(orders)
        .where(
          and(
            eq(orders.matchedHelperId, helperId),
            inArray(orders.status, ['closed', 'settlement_paid'])
          )
        );
      
      const settlements = await db
        .select()
        .from(settlementRecords)
        .where(eq(settlementRecords.helperId, helperId));

      const totalPayout = settlements.reduce((sum, s) => sum + (s.driverPayout || 0), 0);
      const lastOrder = completedOrders[completedOrders.length - 1];

      res.json({
        id: helper.id,
        name: helper.name,
        email: helper.email,
        phone: helper.phoneNumber,
        region: helper.region,
        vehicleType: helper.vehicleType,
        isActive: !helper.isSuspended,
        isVerified: helper.isVerified,
        totalOrders: completedOrders.length,
        totalPayout,
        lastWorkDate: lastOrder?.createdAt,
        createdAt: helper.createdAt,
      });
    } catch (err) {
      console.error("Get helper card error:", err);
      res.status(500).json({ message: "헬퍼 정보를 불러오지 못했습니다" });
    }
  });

  // GET /api/admin/requesters/:requesterId/card - 요청자 카드 상세
  app.get("/api/admin/requesters/:requesterId/card", adminAuth, requirePermission("requesters.view"), async (req, res) => {
    try {
      const requesterId = parseInt(req.params.requesterId);
      const requester = await storage.getUser(requesterId);
      
      if (!requester) {
        return res.status(404).json({ message: "요청자를 찾을 수 없습니다" });
      }

      // 누적 통계
      const allOrders = await db
        .select()
        .from(orders)
        .where(eq(orders.requesterId, requesterId));
      
      const settlements = await db
        .select()
        .from(settlementRecords)
        .where(eq(settlementRecords.requesterId, requesterId));

      const totalPaid = settlements.reduce((sum, s) => sum + (s.finalTotal || 0), 0);
      
      // 미수금 (final_amount_confirmed 상태인 오더들)
      const outstandingOrders = allOrders.filter(o => o.status === 'final_amount_confirmed');
      const outstandingSettlements = await Promise.all(
        outstandingOrders.map(o => db.select().from(settlementRecords).where(eq(settlementRecords.orderId, o.id)).limit(1))
      );
      const outstandingAmount = outstandingSettlements.flat().reduce((sum, s) => sum + (s?.finalTotal || 0), 0);

      const lastOrder = allOrders[allOrders.length - 1];

      res.json({
        id: requester.id,
        name: requester.name,
        companyName: requester.companyName,
        email: requester.email,
        phone: requester.phoneNumber,
        address: requester.address,
        isVerified: requester.isVerified,
        totalOrders: allOrders.length,
        totalPaid,
        outstandingAmount,
        lastOrderDate: lastOrder?.createdAt,
        createdAt: requester.createdAt,
      });
    } catch (err) {
      console.error("Get requester card error:", err);
      res.status(500).json({ message: "요청자 정보를 불러오지 못했습니다" });
    }
  });

  // GET /api/admin/payments-detail - 결제 목록 (계약금/잔금 구분)
  app.get("/api/admin/payments-detail", adminAuth, requirePermission("payments.view"), async (req, res) => {
    try {
      const { type } = req.query;
      
      const allClosings = await db.select().from(closingReports);
      const allContracts = await db.select().from(contracts);
      const allOrders = await db.select().from(orders);
      
      const results = [];
      
      for (const order of allOrders) {
        const contract = allContracts.find(c => c.orderId === order.id);
        const closing = allClosings.find(c => c.orderId === order.id);
        const requester = order.requesterId ? await storage.getUser(order.requesterId) : null;
        // 헬퍼 정보: contract.helperUserId 또는 order.matchedHelperId 사용
        const helperUserId = contract?.helperUserId || order.matchedHelperId;
        const helper = helperUserId ? await storage.getUser(helperUserId) : null;
        
        const unitPrice = Number(order.finalPricePerBox || order.pricePerUnit || 1200);
        
        if (type === 'deposit') {
          // 입금대기 상태이거나 계약이 있는 오더 표시
          if (order.status === 'awaiting_deposit' || order.paymentStatus === 'deposit_confirmed' || contract) {
            // 공통 함수로 계약금 정보 조회 (SSOT)
            const depositInfo = await getOrderDepositInfo(order.id);
            results.push({
              id: order.id,
              orderId: order.id,
              orderDate: order.createdAt,
              requesterName: requester?.name || '-',
              requesterEmail: requester?.email || '-',
              requesterPhone: requester?.phoneNumber || '-',
              depositAmount: depositInfo.depositAmount,
              orderStatus: order.status,
              paymentStatus: depositInfo.paymentStatus,
              virtualAccountNumber: null,
              virtualAccountBank: null,
              createdAt: order.createdAt,
            });
          }
        } else if (type === 'balance') {
          if (closing) {
            const deliveredCount = closing.deliveredCount || 0;
            const returnedCount = closing.returnedCount || 0;
            const etcCount = closing.etcCount || 0;
            const closingEtcPrice = closing.etcPricePerUnit || 0;
            // 마감자료에 기타단가가 없으면 운임정책에서 기본값 사용
            const orderCourierSettings = await storage.getAllCourierSettings();
            const orderCourier = orderCourierSettings.find(c => c.courierName === order.companyName);
            const etcPricePerUnit = closingEtcPrice > 0 ? closingEtcPrice : (orderCourier?.etcPricePerBox || 0);
            
            // 기타비용 파싱 (extraCostsJson)
            let extraCostsTotal = 0;
            let extraCostsItems: Array<{code: string; amount: number; memo?: string}> = [];
            if (closing.extraCostsJson) {
              try {
                extraCostsItems = JSON.parse(closing.extraCostsJson);
                extraCostsTotal = extraCostsItems.reduce((sum: number, item: any) => sum + (Number(item.amount) || 0), 0);
              } catch { /* ignore */ }
            }
            
            // 배송수 × 단가
            const deliveryTotal = deliveredCount * unitPrice;
            // 반품수 × 단가 (반품도 비용에 포함)
            const returnTotal = returnedCount * unitPrice;
            // 기타수량 × 기타단가
            const etcTotal = etcCount * etcPricePerUnit;
            
            // 공급가액 = 배송수 + 반품수 + 기타수량 + 기타비용
            const supplyAmount = deliveryTotal + returnTotal + etcTotal + extraCostsTotal;
            // 부가세 (10%)
            const vatAmount = Math.round(supplyAmount * 0.1);
            // 총액 (부가세 포함)
            const grossAmount = supplyAmount + vatAmount;
            
            const depositAmount = contract?.depositAmount || 0;
            const balanceAmount = Math.max(0, grossAmount - depositAmount);
            
            results.push({
              id: order.id,
              orderId: order.id,
              orderDate: order.createdAt,
              requesterName: requester?.name || '-',
              requesterEmail: requester?.email || '-',
              requesterPhone: requester?.phoneNumber || '-',
              helperName: helper?.name || '-',
              helperEmail: helper?.email || '-',
              deliveredCount: deliveredCount,
              returnedCount: returnedCount,
              etcCount: etcCount,
              etcPricePerUnit: etcPricePerUnit,
              extraCostsTotal: extraCostsTotal,
              supplyAmount: supplyAmount,
              vatAmount: vatAmount,
              grossAmount: grossAmount,
              depositAmount: depositAmount,
              unitPrice: unitPrice,
              balanceAmount: balanceAmount,
              orderStatus: order.status,
              paymentStatus: ['balance_paid', 'settlement_paid', 'closed'].includes(order.status || '') ? 'paid' : 'unpaid',
              balancePaidAt: (contract as any)?.balancePaidAt || null,
              balanceDueDate: (contract as any)?.balanceDueDate || null,
              virtualAccountNumber: null,
              virtualAccountBank: null,
              closingSubmittedAt: closing.createdAt,
              createdAt: order.createdAt,
            });
          }
        }
      }
      
      res.json(results);
    } catch (err) {
      console.error("Get payments detail error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });

  // GET /api/admin/refunds-detail - 환불 목록 (일반/CS 구분)
  app.get("/api/admin/refunds-detail", adminAuth, requirePermission("payments.view"), async (req, res) => {
    try {
      const { type } = req.query;
      
      if (type === 'cs') {
        const incidents = await db.select().from(incidentReports).where(isNotNull(incidentReports.deductionAmount));
        const results = [];
        
        for (const incident of incidents) {
          const order = await storage.getOrder(incident.orderId);
          if (!order) continue;
          
          const requester = order.requesterId ? await storage.getUser(order.requesterId) : null;
          const contractList = await db.select().from(contracts).where(eq(contracts.orderId, order.id)).limit(1);
          const helper = contractList[0]?.helperUserId ? await storage.getUser(contractList[0].helperUserId) : null;
          
          results.push({
            id: incident.id,
            orderId: incident.orderId,
            orderDate: order.createdAt,
            requesterName: requester?.name || '-',
            requesterEmail: requester?.email || '-',
            requesterPhone: requester?.phoneNumber || '-',
            helperName: helper?.name || '-',
            helperEmail: helper?.email || '-',
            trackingNumber: null,
            csReason: incident.type || 'other',
            csReasonDetail: incident.reason || null,
            refundAmount: incident.deductionAmount || 0,
            refundBankName: null,
            refundAccountNumber: null,
            refundAccountHolder: null,
            receiptStatus: 'received',
            helperConfirmed: incident.status === 'applied',
            refundCompleted: incident.status === 'applied',
            status: incident.status === 'applied' ? 'completed' : incident.status === 'pending' ? 'pending' : 'helper_confirmed',
            processedAt: incident.status === 'applied' ? incident.createdAt : null,
            createdAt: incident.createdAt,
          });
        }
        
        res.json(results);
      } else {
        const cancelledOrders = await db.select().from(orders).where(eq(orders.status, 'cancelled'));
        const refundPolicy = await getActiveRefundPolicy();
        const results = [];
        
        for (const order of cancelledOrders) {
          const requester = order.requesterId ? await storage.getUser(order.requesterId) : null;
          const contractList = await db.select().from(contracts).where(eq(contracts.orderId, order.id)).limit(1);
          const depositAmount = contractList[0]?.depositAmount || 0;
          
          const hasHelper = !!contractList[0]?.helperUserId;
          const refundRate = hasHelper ? refundPolicy.afterMatchingRate : refundPolicy.beforeMatchingRate;
          const refundAmount = Math.round(depositAmount * refundRate / 100);
          
          // 환불 사유 카테고리 결정
          let reasonCategory = 'customer_request'; // 기본: 고객요청
          const cancelReasonText = (order.cancelReason || '').toLowerCase();
          
          if (cancelReasonText.includes('미배정') || cancelReasonText.includes('unassigned') || cancelReasonText.includes('timeout')) {
            reasonCategory = 'unassigned_timeout'; // 미배정 타임아웃
          } else if (cancelReasonText.includes('입금') || cancelReasonText.includes('deposit')) {
            reasonCategory = 'deposit_issue'; // 입금 문제
          } else if (hasHelper) {
            reasonCategory = 'after_matching_cancel'; // 매칭 후 취소
          }
          
          results.push({
            id: order.id,
            orderId: order.id,
            orderDate: order.createdAt,
            requesterName: requester?.name || '-',
            requesterEmail: requester?.email || '-',
            requesterPhone: requester?.phoneNumber || '-',
            refundAmount: refundAmount,
            depositAmount: depositAmount,
            refundRate: refundRate,
            refundType: hasHelper ? 'after_matching' : 'before_matching',
            reasonCategory: reasonCategory,
            cancelReason: order.cancelReason || '-',
            refundBankName: null,
            refundAccountNumber: null,
            refundAccountHolder: null,
            status: 'completed',
            processedAt: order.updatedAt || order.createdAt,
            createdAt: order.createdAt,
          });
        }
        
        res.json(results);
      }
    } catch (err) {
      console.error("Get refunds detail error:", err);
      res.status(500).json({ message: "Internal server error" });
    }
  });



  // ============================================
  // CS Ticket Management CRUD APIs
  // ============================================

  // Get single inquiry
  app.get("/api/admin/customer-inquiries/:id", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const { id } = req.params;
      const [inquiry] = await db.select().from(customerInquiries).where(eq(customerInquiries.id, parseInt(id)));
      if (!inquiry) {
        return res.status(404).json({ message: "Inquiry not found" });
      }
      
      const comments = await db.select().from(inquiryComments)
        .where(eq(inquiryComments.inquiryId, parseInt(id)))
        .orderBy(inquiryComments.createdAt);
      
      res.json({ ...inquiry, comments });
    } catch (err) {
      console.error("Get inquiry error:", err);
      res.status(500).json({ message: "Failed to fetch inquiry" });
    }
  });

  // Update inquiry status
  app.patch("/api/admin/customer-inquiries/:id", adminAuth, requirePermission("settings.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { id } = req.params;
      const { status, priority, assigneeId, assigneeName } = req.body;
      
      const updateData: any = { updatedAt: new Date() };
      if (status) updateData.status = status;
      if (priority) updateData.priority = priority;
      if (assigneeId !== undefined) updateData.assigneeId = assigneeId;
      if (assigneeName !== undefined) updateData.assigneeName = assigneeName;
      
      if (status === 'resolved') updateData.resolvedAt = new Date();
      if (status === 'closed') updateData.closedAt = new Date();
      
      const [updated] = await db.update(customerInquiries)
        .set(updateData)
        .where(eq(customerInquiries.id, parseInt(id)))
        .returning();
      
      if (!updated) {
        return res.status(404).json({ message: "Inquiry not found" });
      }
      res.json(updated);
    } catch (err) {
      console.error("Update inquiry error:", err);
      res.status(500).json({ message: "Failed to update inquiry" });
    }
  });

  // Reply to inquiry
  app.post("/api/admin/customer-inquiries/:id/reply", adminAuth, requirePermission("settings.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { id } = req.params;
      const { content, isInternal = false } = req.body;
      
      const [comment] = await db.insert(inquiryComments).values({
        inquiryId: parseInt(id),
        authorId: req.adminUser?.id,
        authorName: req.adminUser?.name || 'Admin',
        authorRole: 'admin',
        content,
        isInternal,
      }).returning();
      
      // Update inquiry status to in_progress or waiting_response
      if (!isInternal) {
        await db.update(customerInquiries)
          .set({ 
            status: 'waiting_response',
            responseContent: content,
            respondedAt: new Date(),
            updatedAt: new Date()
          })
          .where(eq(customerInquiries.id, parseInt(id)));
      }
      
      res.json(comment);
    } catch (err) {
      console.error("Reply to inquiry error:", err);
      res.status(500).json({ message: "Failed to add reply" });
    }
  });

  // Escalate inquiry
  app.post("/api/admin/customer-inquiries/:id/escalate", adminAuth, requirePermission("settings.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { id } = req.params;
      const { escalationType, reason, priority = 'high', assignedTo, assignedToName, dueDate } = req.body;
      
      const [escalation] = await db.insert(ticketEscalations).values({
        inquiryId: parseInt(id),
        escalationType,
        reason,
        priority,
        escalatedBy: req.adminUser?.id,
        escalatedByName: req.adminUser?.name || 'Admin',
        assignedTo,
        assignedToName,
        dueDate: dueDate ? new Date(dueDate) : undefined,
      }).returning();
      
      // Update inquiry priority
      await db.update(customerInquiries)
        .set({ priority: 'urgent', updatedAt: new Date() })
        .where(eq(customerInquiries.id, parseInt(id)));
      
      res.json(escalation);
    } catch (err) {
      console.error("Escalate inquiry error:", err);
      res.status(500).json({ message: "Failed to escalate inquiry" });
    }
  });

  // Resolve escalation
  app.patch("/api/admin/ticket-escalations/:id", adminAuth, requirePermission("settings.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { id } = req.params;
      const { status, resolution, adminReply } = req.body;
      
      const updateData: any = { status, updatedAt: new Date() };
      if (resolution) updateData.resolution = resolution;
      if (adminReply) { updateData.adminReply = adminReply; updateData.adminReplyAt = new Date(); updateData.adminReplyBy = decoded?.userId || null; }
      if (status === 'resolved') {
        updateData.resolvedAt = new Date();
        updateData.resolvedBy = req.adminUser?.id;
      }
      
      const [updated] = await db.update(ticketEscalations)
        .set(updateData)
        .where(eq(ticketEscalations.id, parseInt(id)))
        .returning();
      
      if (!updated) {
        return res.status(404).json({ message: "Escalation not found" });
      }
      res.json(updated);
    } catch (err) {
      console.error("Update escalation error:", err);
      res.status(500).json({ message: "Failed to update escalation" });
    }
  });

  // ============================================
  // SMS Management APIs
  // ============================================

  // Create SMS template
  app.post("/api/admin/sms-templates", adminAuth, requirePermission("settings.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { code, name, category, content, variables, senderType } = req.body;
      
      const [template] = await db.insert(smsTemplates).values({
        code,
        name,
        category,
            categoryBasePrice,
        content,
        variables,
        senderType,
        createdBy: req.adminUser?.id,
      }).returning();
      
      res.json(template);
    } catch (err) {
      console.error("Create SMS template error:", err);
      res.status(500).json({ message: "Failed to create SMS template" });
    }
  });

  // Update SMS template
  app.patch("/api/admin/sms-templates/:id", adminAuth, requirePermission("settings.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { id } = req.params;
      const { name, content, variables, senderType, isActive } = req.body;
      
      const updateData: any = { updatedBy: req.adminUser?.id, updatedAt: new Date() };
      if (name !== undefined) updateData.name = name;
      if (content !== undefined) updateData.content = content;
      if (variables !== undefined) updateData.variables = variables;
      if (senderType !== undefined) updateData.senderType = senderType;
      if (isActive !== undefined) updateData.isActive = isActive;
      
      const [updated] = await db.update(smsTemplates)
        .set(updateData)
        .where(eq(smsTemplates.id, parseInt(id)))
        .returning();
      
      if (!updated) {
        return res.status(404).json({ message: "Template not found" });
      }
      res.json(updated);
    } catch (err) {
      console.error("Update SMS template error:", err);
      res.status(500).json({ message: "Failed to update template" });
    }
  });

  // Send SMS
  app.post("/api/admin/send-sms", adminAuth, requirePermission("notifications.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { recipientPhone, recipientUserId, content, templateId, metadata } = req.body;
      
      // Log SMS attempt
      const [smsLog] = await db.insert(smsLogs).values({
        templateId,
        recipientPhone,
        recipientUserId,
        content,
        status: 'pending',
        provider: 'solapi',
        metadata: metadata ? JSON.stringify(metadata) : undefined,
      }).returning();
      
      // Try to send via SMS service
      try {
        const result = await smsService.sendSms({ to: recipientPhone, message: content });
        
        await db.update(smsLogs)
          .set({ 
            status: result.success ? 'sent' : 'failed',
            providerId: result.messageId,
            errorMessage: result.error,
            sentAt: new Date()
          })
          .where(eq(smsLogs.id, smsLog.id));
        
        res.json({ success: result.success, messageId: result.messageId, error: result.error });
      } catch (sendErr: any) {
        await db.update(smsLogs)
          .set({ status: 'failed', errorMessage: sendErr.message })
          .where(eq(smsLogs.id, smsLog.id));
        
        res.json({ success: false, error: sendErr.message });
      }
    } catch (err) {
      console.error("Send SMS error:", err);
      res.status(500).json({ message: "Failed to send SMS" });
    }
  });

  // ============================================
  // Push Notification APIs
  // ============================================

  // Send push notification
  app.post("/api/admin/send-push", adminAuth, requirePermission("notifications.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { recipientUserId, title, body, data, category, relatedEntityType, relatedEntityId } = req.body;
      
      // Log push attempt
      const [pushLog] = await db.insert(pushNotificationLogs).values({
        recipientUserId,
        title,
        body,
        data: data ? JSON.stringify(data) : undefined,
        category,
            categoryBasePrice,
        relatedEntityType,
        relatedEntityId,
        status: 'pending',
      }).returning();
      
      // Try to send via notification service
      try {
        await notificationWS.sendNotification(recipientUserId, title, body, data);
        
        await db.update(pushNotificationLogs)
          .set({ status: 'sent', sentAt: new Date() })
          .where(eq(pushNotificationLogs.id, pushLog.id));
        
        res.json({ success: true });
      } catch (sendErr: any) {
        await db.update(pushNotificationLogs)
          .set({ status: 'failed', errorMessage: sendErr.message })
          .where(eq(pushNotificationLogs.id, pushLog.id));
        
        res.json({ success: false, error: sendErr.message });
      }
    } catch (err) {
      console.error("Send push error:", err);
      res.status(500).json({ message: "Failed to send push notification" });
    }
  });

  // Bulk send push notification
  app.post("/api/admin/send-bulk-push", adminAuth, requirePermission("notifications.edit"), async (req: AuthenticatedRequest, res) => {
    try {
      const { userIds, title, body, data, category } = req.body;
      
      const results = [];
      for (const userId of userIds) {
        try {
          await notificationWS.sendNotification(userId, title, body, data);
          
          await db.insert(pushNotificationLogs).values({
            recipientUserId: userId,
            title,
            body,
            data: data ? JSON.stringify(data) : undefined,
            category,
            categoryBasePrice,
            status: 'sent',
            sentAt: new Date(),
          });
          
          results.push({ userId, success: true });
        } catch (err: any) {
          results.push({ userId, success: false, error: err.message });
        }
      }
      
      res.json({ sent: results.filter(r => r.success).length, failed: results.filter(r => !r.success).length, results });
    } catch (err) {
      console.error("Bulk push error:", err);
      res.status(500).json({ message: "Failed to send bulk push" });
    }
  });

  // ============================================
  // System Health Check API
  // ============================================

  // Health check for all integrations
  app.post("/api/admin/integration-health/check", adminAuth, requirePermission("settings.view"), async (req, res) => {
    try {
      const checkResults: any[] = [];
      
      // Check Database
      try {
        await db.execute(sql`SELECT 1`);
        checkResults.push({ serviceName: 'PostgreSQL', serviceType: 'database', status: 'healthy' });
      } catch {
        checkResults.push({ serviceName: 'PostgreSQL', serviceType: 'database', status: 'down' });
      }
      
      // Check SMS (Solapi)
      if (process.env.SOLAPI_API_KEY) {
        checkResults.push({ serviceName: 'Solapi SMS', serviceType: 'sms', status: 'healthy' });
      } else {
        checkResults.push({ serviceName: 'Solapi SMS', serviceType: 'sms', status: 'not_configured' });
      }
      
      // Check Popbill
      if (process.env.POPBILL_LINK_ID) {
        checkResults.push({ serviceName: 'Popbill', serviceType: 'tax_invoice', status: 'healthy' });
      } else {
        checkResults.push({ serviceName: 'Popbill', serviceType: 'tax_invoice', status: 'not_configured' });
      }
      
      // Check Kakao OAuth
      if (process.env.KAKAO_REST_API_KEY) {
        checkResults.push({ serviceName: 'Kakao OAuth', serviceType: 'oauth', status: 'healthy' });
      } else {
        checkResults.push({ serviceName: 'Kakao OAuth', serviceType: 'oauth', status: 'not_configured' });
      }
      
      // Update integration_health table
      for (const result of checkResults) {
        const existing = await db.select().from(integrationHealth)
          .where(eq(integrationHealth.serviceName, result.serviceName));
        
        if (existing.length > 0) {
          await db.update(integrationHealth)
            .set({ 
              status: result.status, 
              lastCheckAt: new Date(),
              lastSuccessAt: result.status === 'healthy' ? new Date() : undefined,
              lastFailureAt: result.status === 'down' ? new Date() : undefined,
            })
            .where(eq(integrationHealth.serviceName, result.serviceName));
        } else {
          await db.insert(integrationHealth).values({
            serviceName: result.serviceName,
            serviceType: result.serviceType,
            status: result.status,
            lastCheckAt: new Date(),
            lastSuccessAt: result.status === 'healthy' ? new Date() : undefined,
          });
        }
      }
      
      res.json({ checked: checkResults.length, results: checkResults });
    } catch (err) {
      console.error("Health check error:", err);
      res.status(500).json({ message: "Failed to perform health check" });
    }
  });


  // ============================================
  // 차감(Deduction) 관리 API
  // ============================================

  // GET /api/admin/deductions - 차감 목록 조회
  app.get("/api/admin/deductions", adminAuth, requirePermission("settlements.view"), async (req, res) => {
    try {
      const { status, startDate, endDate } = req.query;
      
      const conditions: any[] = [];
      if (status && status !== "all") {
        conditions.push(eq(deductions.status, status as string));
      }
      if (startDate) {
        conditions.push(gte(deductions.createdAt, new Date(startDate as string)));
      }
      if (endDate) {
        conditions.push(lte(deductions.createdAt, new Date(endDate as string)));
      }
      
      const results = await db.select({
        deduction: deductions,
        helper: {
          id: users.id,
          name: users.name,
          phone: users.phone,
        },
        order: {
          id: orders.id,
          courierCompany: orders.courierCompany,
          scheduledDate: orders.scheduledDate,
        },
      })
      .from(deductions)
      .leftJoin(users, eq(deductions.targetId, users.id))
      .leftJoin(orders, eq(deductions.orderId, orders.id))
      .where(conditions.length > 0 ? and(...conditions) : undefined)
      .orderBy(desc(deductions.createdAt));
      
      const formatted = results.map(r => ({
        ...r.deduction,
        targetName: r.helper?.name || null,
        targetPhone: r.helper?.phone || null,
        orderInfo: r.order ? {
          id: r.order.id,
          courierCompany: r.order.courierCompany,
          scheduledDate: r.order.scheduledDate,
        } : null,
      }));
      
      res.json(formatted);
    } catch (err) {
      console.error("Get deductions error:", err);
      res.status(500).json({ message: "차감 목록 조회에 실패했습니다" });
    }
  });

  // PATCH /api/admin/deductions/:id/apply - 차감 적용
  app.patch("/api/admin/deductions/:id/apply", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const adminUser = (req as any).adminUser;
      const { settlementId, memo } = req.body;
      
      const [deduction] = await db.select().from(deductions).where(eq(deductions.id, id));
      if (!deduction) {
        return res.status(404).json({ message: "차감 내역을 찾을 수 없습니다" });
      }
      
      if (deduction.status !== "pending") {
        return res.status(400).json({ message: "적용할 수 없는 상태입니다: " + deduction.status });
      }
      
      const [updated] = await db.update(deductions)
        .set({
          status: "applied",
          appliedToSettlementId: settlementId || null,
          appliedAt: new Date(),
          appliedBy: adminUser?.id,
          memo: memo || deduction.memo,
          updatedAt: new Date(),
        })
        .where(eq(deductions.id, id))
        .returning();
      
      res.json({ success: true, deduction: updated });
    } catch (err) {
      console.error("Apply deduction error:", err);
      res.status(500).json({ message: "차감 적용에 실패했습니다" });
    }
  });

  // PATCH /api/admin/deductions/:id/cancel - 차감 취소
  app.patch("/api/admin/deductions/:id/cancel", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const id = Number(req.params.id);
      const adminUser = (req as any).adminUser;
      const { reason } = req.body;
      
      const [deduction] = await db.select().from(deductions).where(eq(deductions.id, id));
      if (!deduction) {
        return res.status(404).json({ message: "차감 내역을 찾을 수 없습니다" });
      }
      
      if (deduction.status === "applied") {
        return res.status(400).json({ message: "이미 적용된 차감은 취소할 수 없습니다" });
      }
      
      const [updated] = await db.update(deductions)
        .set({
          status: "cancelled",
          memo: reason || deduction.memo,
          updatedAt: new Date(),
        })
        .where(eq(deductions.id, id))
        .returning();
      
      if (deduction.incidentId) {
        await db.update(incidentReports)
          .set({ status: "resolved", deductionAmount: 0 })
          .where(eq(incidentReports.id, deduction.incidentId));
      }
      
      res.json({ success: true, deduction: updated });
    } catch (err) {
      console.error("Cancel deduction error:", err);
      res.status(500).json({ message: "차감 취소에 실패했습니다" });
    }
  });

  // POST /api/admin/deductions - 수동 차감 생성
  app.post("/api/admin/deductions", adminAuth, requirePermission("settlements.edit"), async (req, res) => {
    try {
      const adminUser = (req as any).adminUser;
      const { orderId, targetType, targetId, amount, reason, category, memo } = req.body;
      
      if (!targetId || !amount || !reason) {
        return res.status(400).json({ message: "필수 정보가 누락되었습니다" });
      }
      
      const [created] = await db.insert(deductions).values({
        orderId: orderId || null,
        targetType: targetType || "helper",
        targetId,
        amount,
        reason,
        category: category || "other",
        status: "pending",
        createdBy: adminUser?.id,
        memo,
      }).returning();
      
      res.json({ success: true, deduction: created });
    } catch (err) {
      console.error("Create deduction error:", err);
      res.status(500).json({ message: "차감 생성에 실패했습니다" });
    }
  });

  return httpServer;
}
